package matchmaking

import (
	"github.com/rotisserie/eris"

	"github.com/argus-labs/world-engine/pkg/matchmaking/types"
	"github.com/argus-labs/world-engine/pkg/micro"
	microv1 "github.com/argus-labs/world-engine/proto/gen/go/worldengine/micro/v1"
)

// CreateTicketCommand is the command to create a matchmaking ticket.
// Communication is async fire-and-forget. Result is sent via callback.
type CreateTicketCommand struct {
	// PartyID is a correlation ID generated by the Game Shard.
	// Used to correlate the callback response with the original request.
	PartyID string `json:"party_id"`
	// MatchProfileName specifies which queue to join (must exist in Matchmaking config).
	MatchProfileName string `json:"match_profile_name"`
	// AllowBackfill indicates if this ticket can fill incomplete matches.
	AllowBackfill bool `json:"allow_backfill"`
	// Players contains all players in this ticket (solo = 1, party = N).
	Players []types.PlayerInfo `json:"players"`
	// TTLSeconds is the time-to-live for the ticket in seconds (required).
	TTLSeconds int64 `json:"ttl_seconds"`
	// CallbackAddress is the service address to notify when ticket is created or matched (required).
	// Format: "<region>.<realm>.<organization>.<project>.<service_id>"
	// Example: "local.world.demo.matchmaking-demo.game-1"
	// Callbacks sent to: <callback_address>.matchmaking.ticket-created
	//                    <callback_address>.matchmaking.ticket-error
	//                    <callback_address>.matchmaking.match
	CallbackAddress string `json:"callback_address"`
}

// Ensure CreateTicketCommand implements ValidatableCommand.
var _ micro.ValidatableCommand = CreateTicketCommand{}

// Name returns the command name for registration.
func (c CreateTicketCommand) Name() string {
	return "create-ticket"
}

// Validate validates the command fields before enqueuing.
// This provides immediate feedback to the caller via request-reply.
func (c CreateTicketCommand) Validate() error {
	if c.PartyID == "" {
		return eris.New("party_id is required")
	}
	if c.MatchProfileName == "" {
		return eris.New("match_profile_name is required")
	}
	if len(c.Players) == 0 {
		return eris.New("players is required")
	}
	if c.TTLSeconds <= 0 {
		return eris.New("ttl_seconds is required and must be positive")
	}
	if c.CallbackAddress == "" {
		return eris.New("callback_address is required")
	}
	if _, err := micro.ParseAddress(c.CallbackAddress); err != nil {
		return eris.Wrapf(err, "invalid callback_address: %s", c.CallbackAddress)
	}
	// Validate player IDs are not empty
	for i, p := range c.Players {
		if p.PlayerID == "" {
			return eris.Errorf("players[%d].player_id is required", i)
		}
	}
	return nil
}

// CancelTicketCommand is the command to cancel a matchmaking ticket.
type CancelTicketCommand struct {
	TicketID string `json:"ticket_id"`
}

// Name returns the command name for registration.
func (c CancelTicketCommand) Name() string {
	return "cancel-ticket"
}

// CreateBackfillCommand is the command to create a backfill request.
// Communication is async fire-and-forget. Result is sent via callback when backfill match found.
type CreateBackfillCommand struct {
	// MatchID is the ID of the match that needs backfill.
	MatchID string `json:"match_id"`
	// MatchProfileName specifies which profile to use for backfill matching.
	MatchProfileName string `json:"match_profile_name"`
	// TeamName is the team that needs backfill players.
	TeamName string `json:"team_name"`
	// SlotsNeeded specifies how many players are needed for each pool.
	SlotsNeeded []types.SlotNeeded `json:"slots_needed"`
	// LobbyAddress is the service address of the lobby that requested backfill (required).
	// Format: "<region>.<realm>.<organization>.<project>.<service_id>"
	// Example: "local.world.demo.matchmaking-demo.lobby-1"
	// Callback sent to: <lobby_address>.matchmaking.backfill-match
	LobbyAddress string `json:"lobby_address"`
}

// Ensure CreateBackfillCommand implements ValidatableCommand.
var _ micro.ValidatableCommand = CreateBackfillCommand{}

// Name returns the command name for registration.
func (c CreateBackfillCommand) Name() string {
	return "create-backfill"
}

// Validate validates the command fields before enqueuing.
func (c CreateBackfillCommand) Validate() error {
	if c.MatchID == "" {
		return eris.New("match_id is required")
	}
	if c.MatchProfileName == "" {
		return eris.New("match_profile_name is required")
	}
	if c.TeamName == "" {
		return eris.New("team_name is required")
	}
	if len(c.SlotsNeeded) == 0 {
		return eris.New("slots_needed is required")
	}
	if c.LobbyAddress == "" {
		return eris.New("lobby_address is required")
	}
	if _, err := micro.ParseAddress(c.LobbyAddress); err != nil {
		return eris.Wrapf(err, "invalid lobby_address: %s", c.LobbyAddress)
	}
	return nil
}

// CancelBackfillCommand is the command to cancel a backfill request.
type CancelBackfillCommand struct {
	BackfillRequestID string `json:"backfill_request_id"`
}

// Name returns the command name for registration.
func (c CancelBackfillCommand) Name() string {
	return "cancel-backfill"
}
