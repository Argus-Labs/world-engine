// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file cosmos/ics23/v1/proofs.proto (package cosmos.ics23.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file cosmos/ics23/v1/proofs.proto.
 */
export const file_cosmos_ics23_v1_proofs: GenFile = /*@__PURE__*/
  fileDesc("Chxjb3Ntb3MvaWNzMjMvdjEvcHJvb2ZzLnByb3RvEg9jb3Ntb3MuaWNzMjMudjEiewoORXhpc3RlbmNlUHJvb2YSCwoDa2V5GAEgASgMEg0KBXZhbHVlGAIgASgMEiUKBGxlYWYYAyABKAsyFy5jb3Ntb3MuaWNzMjMudjEuTGVhZk9wEiYKBHBhdGgYBCADKAsyGC5jb3Ntb3MuaWNzMjMudjEuSW5uZXJPcCJ/ChFOb25FeGlzdGVuY2VQcm9vZhILCgNrZXkYASABKAwSLQoEbGVmdBgCIAEoCzIfLmNvc21vcy5pY3MyMy52MS5FeGlzdGVuY2VQcm9vZhIuCgVyaWdodBgDIAEoCzIfLmNvc21vcy5pY3MyMy52MS5FeGlzdGVuY2VQcm9vZiLvAQoPQ29tbWl0bWVudFByb29mEjAKBWV4aXN0GAEgASgLMh8uY29zbW9zLmljczIzLnYxLkV4aXN0ZW5jZVByb29mSAASNgoIbm9uZXhpc3QYAiABKAsyIi5jb3Ntb3MuaWNzMjMudjEuTm9uRXhpc3RlbmNlUHJvb2ZIABIsCgViYXRjaBgDIAEoCzIbLmNvc21vcy5pY3MyMy52MS5CYXRjaFByb29mSAASOwoKY29tcHJlc3NlZBgEIAEoCzIlLmNvc21vcy5pY3MyMy52MS5Db21wcmVzc2VkQmF0Y2hQcm9vZkgAQgcKBXByb29mIsgBCgZMZWFmT3ASJQoEaGFzaBgBIAEoDjIXLmNvc21vcy5pY3MyMy52MS5IYXNoT3ASLAoLcHJlaGFzaF9rZXkYAiABKA4yFy5jb3Ntb3MuaWNzMjMudjEuSGFzaE9wEi4KDXByZWhhc2hfdmFsdWUYAyABKA4yFy5jb3Ntb3MuaWNzMjMudjEuSGFzaE9wEikKBmxlbmd0aBgEIAEoDjIZLmNvc21vcy5pY3MyMy52MS5MZW5ndGhPcBIOCgZwcmVmaXgYBSABKAwiUAoHSW5uZXJPcBIlCgRoYXNoGAEgASgOMhcuY29zbW9zLmljczIzLnYxLkhhc2hPcBIOCgZwcmVmaXgYAiABKAwSDgoGc3VmZml4GAMgASgMIrQBCglQcm9vZlNwZWMSKgoJbGVhZl9zcGVjGAEgASgLMhcuY29zbW9zLmljczIzLnYxLkxlYWZPcBIuCgppbm5lcl9zcGVjGAIgASgLMhouY29zbW9zLmljczIzLnYxLklubmVyU3BlYxIRCgltYXhfZGVwdGgYAyABKAUSEQoJbWluX2RlcHRoGAQgASgFEiUKHXByZWhhc2hfa2V5X2JlZm9yZV9jb21wYXJpc29uGAUgASgIIqYBCglJbm5lclNwZWMSEwoLY2hpbGRfb3JkZXIYASADKAUSEgoKY2hpbGRfc2l6ZRgCIAEoBRIZChFtaW5fcHJlZml4X2xlbmd0aBgDIAEoBRIZChFtYXhfcHJlZml4X2xlbmd0aBgEIAEoBRITCgtlbXB0eV9jaGlsZBgFIAEoDBIlCgRoYXNoGAYgASgOMhcuY29zbW9zLmljczIzLnYxLkhhc2hPcCI6CgpCYXRjaFByb29mEiwKB2VudHJpZXMYASADKAsyGy5jb3Ntb3MuaWNzMjMudjEuQmF0Y2hFbnRyeSJ/CgpCYXRjaEVudHJ5EjAKBWV4aXN0GAEgASgLMh8uY29zbW9zLmljczIzLnYxLkV4aXN0ZW5jZVByb29mSAASNgoIbm9uZXhpc3QYAiABKAsyIi5jb3Ntb3MuaWNzMjMudjEuTm9uRXhpc3RlbmNlUHJvb2ZIAEIHCgVwcm9vZiJ/ChRDb21wcmVzc2VkQmF0Y2hQcm9vZhI2CgdlbnRyaWVzGAEgAygLMiUuY29zbW9zLmljczIzLnYxLkNvbXByZXNzZWRCYXRjaEVudHJ5Ei8KDWxvb2t1cF9pbm5lcnMYAiADKAsyGC5jb3Ntb3MuaWNzMjMudjEuSW5uZXJPcCKdAQoUQ29tcHJlc3NlZEJhdGNoRW50cnkSOgoFZXhpc3QYASABKAsyKS5jb3Ntb3MuaWNzMjMudjEuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mSAASQAoIbm9uZXhpc3QYAiABKAsyLC5jb3Ntb3MuaWNzMjMudjEuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mSABCBwoFcHJvb2YiawoYQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mEgsKA2tleRgBIAEoDBINCgV2YWx1ZRgCIAEoDBIlCgRsZWFmGAMgASgLMhcuY29zbW9zLmljczIzLnYxLkxlYWZPcBIMCgRwYXRoGAQgAygFIp0BChtDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YSCwoDa2V5GAEgASgMEjcKBGxlZnQYAiABKAsyKS5jb3Ntb3MuaWNzMjMudjEuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mEjgKBXJpZ2h0GAMgASgLMikuY29zbW9zLmljczIzLnYxLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiqWAQoGSGFzaE9wEgsKB05PX0hBU0gQABIKCgZTSEEyNTYQARIKCgZTSEE1MTIQAhINCglLRUNDQUsyNTYQAxINCglSSVBFTUQxNjAQBBILCgdCSVRDT0lOEAUSDgoKU0hBNTEyXzI1NhAGEg8KC0JMQUtFMkJfNTEyEAcSDwoLQkxBS0UyU18yNTYQCBIKCgZCTEFLRTMQCSqrAQoITGVuZ3RoT3ASDQoJTk9fUFJFRklYEAASDQoJVkFSX1BST1RPEAESCwoHVkFSX1JMUBACEg8KC0ZJWEVEMzJfQklHEAMSEgoORklYRUQzMl9MSVRUTEUQBBIPCgtGSVhFRDY0X0JJRxAFEhIKDkZJWEVENjRfTElUVExFEAYSFAoQUkVRVUlSRV8zMl9CWVRFUxAHEhQKEFJFUVVJUkVfNjRfQllURVMQCEIiWiBnaXRodWIuY29tL2Nvc21vcy9pY3MyMy9nbztpY3MyM2IGcHJvdG8z");

/**
 * *
 * ExistenceProof takes a key and a value and a set of steps to perform on it.
 * The result of peforming all these steps will provide a "root hash", which can
 * be compared to the value in a header.
 *
 * Since it is computationally infeasible to produce a hash collission for any of the used
 * cryptographic hash functions, if someone can provide a series of operations to transform
 * a given key and value into a root hash that matches some trusted root, these key and values
 * must be in the referenced merkle tree.
 *
 * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
 * which should be controlled by a spec. Eg. with lengthOp as NONE,
 * prefix = FOO, key = BAR, value = CHOICE
 * and
 * prefix = F, key = OOBAR, value = CHOICE
 * would produce the same value.
 *
 * With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
 * in the ProofSpec is valuable to prevent this mutability. And why all trees should
 * length-prefix the data before hashing it.
 *
 * @generated from message cosmos.ics23.v1.ExistenceProof
 */
export type ExistenceProof = Message<"cosmos.ics23.v1.ExistenceProof"> & {
  /**
   * @generated from field: bytes key = 1;
   */
  key: Uint8Array;

  /**
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;

  /**
   * @generated from field: cosmos.ics23.v1.LeafOp leaf = 3;
   */
  leaf?: LeafOp;

  /**
   * @generated from field: repeated cosmos.ics23.v1.InnerOp path = 4;
   */
  path: InnerOp[];
};

/**
 * Describes the message cosmos.ics23.v1.ExistenceProof.
 * Use `create(ExistenceProofSchema)` to create a new message.
 */
export const ExistenceProofSchema: GenMessage<ExistenceProof> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 0);

/**
 *
 * NonExistenceProof takes a proof of two neighbors, one left of the desired key,
 * one right of the desired key. If both proofs are valid AND they are neighbors,
 * then there is no valid proof for the given key.
 *
 * @generated from message cosmos.ics23.v1.NonExistenceProof
 */
export type NonExistenceProof = Message<"cosmos.ics23.v1.NonExistenceProof"> & {
  /**
   * TODO: remove this as unnecessary??? we prove a range
   *
   * @generated from field: bytes key = 1;
   */
  key: Uint8Array;

  /**
   * @generated from field: cosmos.ics23.v1.ExistenceProof left = 2;
   */
  left?: ExistenceProof;

  /**
   * @generated from field: cosmos.ics23.v1.ExistenceProof right = 3;
   */
  right?: ExistenceProof;
};

/**
 * Describes the message cosmos.ics23.v1.NonExistenceProof.
 * Use `create(NonExistenceProofSchema)` to create a new message.
 */
export const NonExistenceProofSchema: GenMessage<NonExistenceProof> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 1);

/**
 *
 * CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
 *
 * @generated from message cosmos.ics23.v1.CommitmentProof
 */
export type CommitmentProof = Message<"cosmos.ics23.v1.CommitmentProof"> & {
  /**
   * @generated from oneof cosmos.ics23.v1.CommitmentProof.proof
   */
  proof: {
    /**
     * @generated from field: cosmos.ics23.v1.ExistenceProof exist = 1;
     */
    value: ExistenceProof;
    case: "exist";
  } | {
    /**
     * @generated from field: cosmos.ics23.v1.NonExistenceProof nonexist = 2;
     */
    value: NonExistenceProof;
    case: "nonexist";
  } | {
    /**
     * @generated from field: cosmos.ics23.v1.BatchProof batch = 3;
     */
    value: BatchProof;
    case: "batch";
  } | {
    /**
     * @generated from field: cosmos.ics23.v1.CompressedBatchProof compressed = 4;
     */
    value: CompressedBatchProof;
    case: "compressed";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message cosmos.ics23.v1.CommitmentProof.
 * Use `create(CommitmentProofSchema)` to create a new message.
 */
export const CommitmentProofSchema: GenMessage<CommitmentProof> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 2);

/**
 * *
 * LeafOp represents the raw key-value data we wish to prove, and
 * must be flexible to represent the internal transformation from
 * the original key-value pairs into the basis hash, for many existing
 * merkle trees.
 *
 * key and value are passed in. So that the signature of this operation is:
 * leafOp(key, value) -> output
 *
 * To process this, first prehash the keys and values if needed (ANY means no hash in this case):
 * hkey = prehashKey(key)
 * hvalue = prehashValue(value)
 *
 * Then combine the bytes, and hash it
 * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
 *
 * @generated from message cosmos.ics23.v1.LeafOp
 */
export type LeafOp = Message<"cosmos.ics23.v1.LeafOp"> & {
  /**
   * @generated from field: cosmos.ics23.v1.HashOp hash = 1;
   */
  hash: HashOp;

  /**
   * @generated from field: cosmos.ics23.v1.HashOp prehash_key = 2;
   */
  prehashKey: HashOp;

  /**
   * @generated from field: cosmos.ics23.v1.HashOp prehash_value = 3;
   */
  prehashValue: HashOp;

  /**
   * @generated from field: cosmos.ics23.v1.LengthOp length = 4;
   */
  length: LengthOp;

  /**
   * prefix is a fixed bytes that may optionally be included at the beginning to differentiate
   * a leaf node from an inner node.
   *
   * @generated from field: bytes prefix = 5;
   */
  prefix: Uint8Array;
};

/**
 * Describes the message cosmos.ics23.v1.LeafOp.
 * Use `create(LeafOpSchema)` to create a new message.
 */
export const LeafOpSchema: GenMessage<LeafOp> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 3);

/**
 * *
 * InnerOp represents a merkle-proof step that is not a leaf.
 * It represents concatenating two children and hashing them to provide the next result.
 *
 * The result of the previous step is passed in, so the signature of this op is:
 * innerOp(child) -> output
 *
 * The result of applying InnerOp should be:
 * output = op.hash(op.prefix || child || op.suffix)
 *
 * where the || operator is concatenation of binary data,
 * and child is the result of hashing all the tree below this step.
 *
 * Any special data, like prepending child with the length, or prepending the entire operation with
 * some value to differentiate from leaf nodes, should be included in prefix and suffix.
 * If either of prefix or suffix is empty, we just treat it as an empty string
 *
 * @generated from message cosmos.ics23.v1.InnerOp
 */
export type InnerOp = Message<"cosmos.ics23.v1.InnerOp"> & {
  /**
   * @generated from field: cosmos.ics23.v1.HashOp hash = 1;
   */
  hash: HashOp;

  /**
   * @generated from field: bytes prefix = 2;
   */
  prefix: Uint8Array;

  /**
   * @generated from field: bytes suffix = 3;
   */
  suffix: Uint8Array;
};

/**
 * Describes the message cosmos.ics23.v1.InnerOp.
 * Use `create(InnerOpSchema)` to create a new message.
 */
export const InnerOpSchema: GenMessage<InnerOp> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 4);

/**
 * *
 * ProofSpec defines what the expected parameters are for a given proof type.
 * This can be stored in the client and used to validate any incoming proofs.
 *
 * verify(ProofSpec, Proof) -> Proof | Error
 *
 * As demonstrated in tests, if we don't fix the algorithm used to calculate the
 * LeafHash for a given tree, there are many possible key-value pairs that can
 * generate a given hash (by interpretting the preimage differently).
 * We need this for proper security, requires client knows a priori what
 * tree format server uses. But not in code, rather a configuration object.
 *
 * @generated from message cosmos.ics23.v1.ProofSpec
 */
export type ProofSpec = Message<"cosmos.ics23.v1.ProofSpec"> & {
  /**
   * any field in the ExistenceProof must be the same as in this spec.
   * except Prefix, which is just the first bytes of prefix (spec can be longer)
   *
   * @generated from field: cosmos.ics23.v1.LeafOp leaf_spec = 1;
   */
  leafSpec?: LeafOp;

  /**
   * @generated from field: cosmos.ics23.v1.InnerSpec inner_spec = 2;
   */
  innerSpec?: InnerSpec;

  /**
   * max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
   * the max_depth is interpreted as 128 if set to 0
   *
   * @generated from field: int32 max_depth = 3;
   */
  maxDepth: number;

  /**
   * min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
   *
   * @generated from field: int32 min_depth = 4;
   */
  minDepth: number;

  /**
   * prehash_key_before_comparison is a flag that indicates whether to use the
   * prehash_key specified by LeafOp to compare lexical ordering of keys for
   * non-existence proofs.
   *
   * @generated from field: bool prehash_key_before_comparison = 5;
   */
  prehashKeyBeforeComparison: boolean;
};

/**
 * Describes the message cosmos.ics23.v1.ProofSpec.
 * Use `create(ProofSpecSchema)` to create a new message.
 */
export const ProofSpecSchema: GenMessage<ProofSpec> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 5);

/**
 *
 * InnerSpec contains all store-specific structure info to determine if two proofs from a
 * given store are neighbors.
 *
 * This enables:
 *
 * isLeftMost(spec: InnerSpec, op: InnerOp)
 * isRightMost(spec: InnerSpec, op: InnerOp)
 * isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
 *
 * @generated from message cosmos.ics23.v1.InnerSpec
 */
export type InnerSpec = Message<"cosmos.ics23.v1.InnerSpec"> & {
  /**
   * Child order is the ordering of the children node, must count from 0
   * iavl tree is [0, 1] (left then right)
   * merk is [0, 2, 1] (left, right, here)
   *
   * @generated from field: repeated int32 child_order = 1;
   */
  childOrder: number[];

  /**
   * @generated from field: int32 child_size = 2;
   */
  childSize: number;

  /**
   * @generated from field: int32 min_prefix_length = 3;
   */
  minPrefixLength: number;

  /**
   * the max prefix length must be less than the minimum prefix length + child size
   *
   * @generated from field: int32 max_prefix_length = 4;
   */
  maxPrefixLength: number;

  /**
   * empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
   *
   * @generated from field: bytes empty_child = 5;
   */
  emptyChild: Uint8Array;

  /**
   * hash is the algorithm that must be used for each InnerOp
   *
   * @generated from field: cosmos.ics23.v1.HashOp hash = 6;
   */
  hash: HashOp;
};

/**
 * Describes the message cosmos.ics23.v1.InnerSpec.
 * Use `create(InnerSpecSchema)` to create a new message.
 */
export const InnerSpecSchema: GenMessage<InnerSpec> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 6);

/**
 *
 * BatchProof is a group of multiple proof types than can be compressed
 *
 * @generated from message cosmos.ics23.v1.BatchProof
 */
export type BatchProof = Message<"cosmos.ics23.v1.BatchProof"> & {
  /**
   * @generated from field: repeated cosmos.ics23.v1.BatchEntry entries = 1;
   */
  entries: BatchEntry[];
};

/**
 * Describes the message cosmos.ics23.v1.BatchProof.
 * Use `create(BatchProofSchema)` to create a new message.
 */
export const BatchProofSchema: GenMessage<BatchProof> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 7);

/**
 * Use BatchEntry not CommitmentProof, to avoid recursion
 *
 * @generated from message cosmos.ics23.v1.BatchEntry
 */
export type BatchEntry = Message<"cosmos.ics23.v1.BatchEntry"> & {
  /**
   * @generated from oneof cosmos.ics23.v1.BatchEntry.proof
   */
  proof: {
    /**
     * @generated from field: cosmos.ics23.v1.ExistenceProof exist = 1;
     */
    value: ExistenceProof;
    case: "exist";
  } | {
    /**
     * @generated from field: cosmos.ics23.v1.NonExistenceProof nonexist = 2;
     */
    value: NonExistenceProof;
    case: "nonexist";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message cosmos.ics23.v1.BatchEntry.
 * Use `create(BatchEntrySchema)` to create a new message.
 */
export const BatchEntrySchema: GenMessage<BatchEntry> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 8);

/**
 * @generated from message cosmos.ics23.v1.CompressedBatchProof
 */
export type CompressedBatchProof = Message<"cosmos.ics23.v1.CompressedBatchProof"> & {
  /**
   * @generated from field: repeated cosmos.ics23.v1.CompressedBatchEntry entries = 1;
   */
  entries: CompressedBatchEntry[];

  /**
   * @generated from field: repeated cosmos.ics23.v1.InnerOp lookup_inners = 2;
   */
  lookupInners: InnerOp[];
};

/**
 * Describes the message cosmos.ics23.v1.CompressedBatchProof.
 * Use `create(CompressedBatchProofSchema)` to create a new message.
 */
export const CompressedBatchProofSchema: GenMessage<CompressedBatchProof> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 9);

/**
 * Use BatchEntry not CommitmentProof, to avoid recursion
 *
 * @generated from message cosmos.ics23.v1.CompressedBatchEntry
 */
export type CompressedBatchEntry = Message<"cosmos.ics23.v1.CompressedBatchEntry"> & {
  /**
   * @generated from oneof cosmos.ics23.v1.CompressedBatchEntry.proof
   */
  proof: {
    /**
     * @generated from field: cosmos.ics23.v1.CompressedExistenceProof exist = 1;
     */
    value: CompressedExistenceProof;
    case: "exist";
  } | {
    /**
     * @generated from field: cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2;
     */
    value: CompressedNonExistenceProof;
    case: "nonexist";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message cosmos.ics23.v1.CompressedBatchEntry.
 * Use `create(CompressedBatchEntrySchema)` to create a new message.
 */
export const CompressedBatchEntrySchema: GenMessage<CompressedBatchEntry> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 10);

/**
 * @generated from message cosmos.ics23.v1.CompressedExistenceProof
 */
export type CompressedExistenceProof = Message<"cosmos.ics23.v1.CompressedExistenceProof"> & {
  /**
   * @generated from field: bytes key = 1;
   */
  key: Uint8Array;

  /**
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;

  /**
   * @generated from field: cosmos.ics23.v1.LeafOp leaf = 3;
   */
  leaf?: LeafOp;

  /**
   * these are indexes into the lookup_inners table in CompressedBatchProof
   *
   * @generated from field: repeated int32 path = 4;
   */
  path: number[];
};

/**
 * Describes the message cosmos.ics23.v1.CompressedExistenceProof.
 * Use `create(CompressedExistenceProofSchema)` to create a new message.
 */
export const CompressedExistenceProofSchema: GenMessage<CompressedExistenceProof> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 11);

/**
 * @generated from message cosmos.ics23.v1.CompressedNonExistenceProof
 */
export type CompressedNonExistenceProof = Message<"cosmos.ics23.v1.CompressedNonExistenceProof"> & {
  /**
   * TODO: remove this as unnecessary??? we prove a range
   *
   * @generated from field: bytes key = 1;
   */
  key: Uint8Array;

  /**
   * @generated from field: cosmos.ics23.v1.CompressedExistenceProof left = 2;
   */
  left?: CompressedExistenceProof;

  /**
   * @generated from field: cosmos.ics23.v1.CompressedExistenceProof right = 3;
   */
  right?: CompressedExistenceProof;
};

/**
 * Describes the message cosmos.ics23.v1.CompressedNonExistenceProof.
 * Use `create(CompressedNonExistenceProofSchema)` to create a new message.
 */
export const CompressedNonExistenceProofSchema: GenMessage<CompressedNonExistenceProof> = /*@__PURE__*/
  messageDesc(file_cosmos_ics23_v1_proofs, 12);

/**
 * @generated from enum cosmos.ics23.v1.HashOp
 */
export enum HashOp {
  /**
   * NO_HASH is the default if no data passed. Note this is an illegal argument some places.
   *
   * @generated from enum value: NO_HASH = 0;
   */
  NO_HASH = 0,

  /**
   * @generated from enum value: SHA256 = 1;
   */
  SHA256 = 1,

  /**
   * @generated from enum value: SHA512 = 2;
   */
  SHA512 = 2,

  /**
   * @generated from enum value: KECCAK256 = 3;
   */
  KECCAK256 = 3,

  /**
   * @generated from enum value: RIPEMD160 = 4;
   */
  RIPEMD160 = 4,

  /**
   * ripemd160(sha256(x))
   *
   * @generated from enum value: BITCOIN = 5;
   */
  BITCOIN = 5,

  /**
   * @generated from enum value: SHA512_256 = 6;
   */
  SHA512_256 = 6,

  /**
   * @generated from enum value: BLAKE2B_512 = 7;
   */
  BLAKE2B_512 = 7,

  /**
   * @generated from enum value: BLAKE2S_256 = 8;
   */
  BLAKE2S_256 = 8,

  /**
   * @generated from enum value: BLAKE3 = 9;
   */
  BLAKE3 = 9,
}

/**
 * Describes the enum cosmos.ics23.v1.HashOp.
 */
export const HashOpSchema: GenEnum<HashOp> = /*@__PURE__*/
  enumDesc(file_cosmos_ics23_v1_proofs, 0);

/**
 * *
 * LengthOp defines how to process the key and value of the LeafOp
 * to include length information. After encoding the length with the given
 * algorithm, the length will be prepended to the key and value bytes.
 * (Each one with it's own encoded length)
 *
 * @generated from enum cosmos.ics23.v1.LengthOp
 */
export enum LengthOp {
  /**
   * NO_PREFIX don't include any length info
   *
   * @generated from enum value: NO_PREFIX = 0;
   */
  NO_PREFIX = 0,

  /**
   * VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
   *
   * @generated from enum value: VAR_PROTO = 1;
   */
  VAR_PROTO = 1,

  /**
   * VAR_RLP uses rlp int encoding of the length
   *
   * @generated from enum value: VAR_RLP = 2;
   */
  VAR_RLP = 2,

  /**
   * FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
   *
   * @generated from enum value: FIXED32_BIG = 3;
   */
  FIXED32_BIG = 3,

  /**
   * FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
   *
   * @generated from enum value: FIXED32_LITTLE = 4;
   */
  FIXED32_LITTLE = 4,

  /**
   * FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
   *
   * @generated from enum value: FIXED64_BIG = 5;
   */
  FIXED64_BIG = 5,

  /**
   * FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
   *
   * @generated from enum value: FIXED64_LITTLE = 6;
   */
  FIXED64_LITTLE = 6,

  /**
   * REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
   *
   * @generated from enum value: REQUIRE_32_BYTES = 7;
   */
  REQUIRE_32_BYTES = 7,

  /**
   * REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
   *
   * @generated from enum value: REQUIRE_64_BYTES = 8;
   */
  REQUIRE_64_BYTES = 8,
}

/**
 * Describes the enum cosmos.ics23.v1.LengthOp.
 */
export const LengthOpSchema: GenEnum<LengthOp> = /*@__PURE__*/
  enumDesc(file_cosmos_ics23_v1_proofs, 1);

