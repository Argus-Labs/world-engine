// Code generated by mockery v2.38.0. DO NOT EDIT.

package mocks

import (
	context "context"

	api "github.com/heroiclabs/nakama-common/api"

	mock "github.com/stretchr/testify/mock"

	os "os"

	rtapi "github.com/heroiclabs/nakama-common/rtapi"

	runtime "github.com/heroiclabs/nakama-common/runtime"

	time "time"
)

// NakamaModule is an autogenerated mock type for the NakamaModule type
type NakamaModule struct {
	mock.Mock
}

type NakamaModule_Expecter struct {
	mock *mock.Mock
}

func (_m *NakamaModule) EXPECT() *NakamaModule_Expecter {
	return &NakamaModule_Expecter{mock: &_m.Mock}
}

// AccountDeleteId provides a mock function with given fields: ctx, userID, recorded
func (_m *NakamaModule) AccountDeleteId(ctx context.Context, userID string, recorded bool) error {
	ret := _m.Called(ctx, userID, recorded)

	if len(ret) == 0 {
		panic("no return value specified for AccountDeleteId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = rf(ctx, userID, recorded)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_AccountDeleteId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountDeleteId'
type NakamaModule_AccountDeleteId_Call struct {
	*mock.Call
}

// AccountDeleteId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - recorded bool
func (_e *NakamaModule_Expecter) AccountDeleteId(ctx interface{}, userID interface{}, recorded interface{}) *NakamaModule_AccountDeleteId_Call {
	return &NakamaModule_AccountDeleteId_Call{Call: _e.mock.On("AccountDeleteId", ctx, userID, recorded)}
}

func (_c *NakamaModule_AccountDeleteId_Call) Run(run func(ctx context.Context, userID string, recorded bool)) *NakamaModule_AccountDeleteId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *NakamaModule_AccountDeleteId_Call) Return(_a0 error) *NakamaModule_AccountDeleteId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_AccountDeleteId_Call) RunAndReturn(run func(context.Context, string, bool) error) *NakamaModule_AccountDeleteId_Call {
	_c.Call.Return(run)
	return _c
}

// AccountExportId provides a mock function with given fields: ctx, userID
func (_m *NakamaModule) AccountExportId(ctx context.Context, userID string) (string, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for AccountExportId")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_AccountExportId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountExportId'
type NakamaModule_AccountExportId_Call struct {
	*mock.Call
}

// AccountExportId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *NakamaModule_Expecter) AccountExportId(ctx interface{}, userID interface{}) *NakamaModule_AccountExportId_Call {
	return &NakamaModule_AccountExportId_Call{Call: _e.mock.On("AccountExportId", ctx, userID)}
}

func (_c *NakamaModule_AccountExportId_Call) Run(run func(ctx context.Context, userID string)) *NakamaModule_AccountExportId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *NakamaModule_AccountExportId_Call) Return(_a0 string, _a1 error) *NakamaModule_AccountExportId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_AccountExportId_Call) RunAndReturn(run func(context.Context, string) (string, error)) *NakamaModule_AccountExportId_Call {
	_c.Call.Return(run)
	return _c
}

// AccountGetId provides a mock function with given fields: ctx, userID
func (_m *NakamaModule) AccountGetId(ctx context.Context, userID string) (*api.Account, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for AccountGetId")
	}

	var r0 *api.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*api.Account, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.Account); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_AccountGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountGetId'
type NakamaModule_AccountGetId_Call struct {
	*mock.Call
}

// AccountGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *NakamaModule_Expecter) AccountGetId(ctx interface{}, userID interface{}) *NakamaModule_AccountGetId_Call {
	return &NakamaModule_AccountGetId_Call{Call: _e.mock.On("AccountGetId", ctx, userID)}
}

func (_c *NakamaModule_AccountGetId_Call) Run(run func(ctx context.Context, userID string)) *NakamaModule_AccountGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *NakamaModule_AccountGetId_Call) Return(_a0 *api.Account, _a1 error) *NakamaModule_AccountGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_AccountGetId_Call) RunAndReturn(run func(context.Context, string) (*api.Account, error)) *NakamaModule_AccountGetId_Call {
	_c.Call.Return(run)
	return _c
}

// AccountUpdateId provides a mock function with given fields: ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl
func (_m *NakamaModule) AccountUpdateId(ctx context.Context, userID string, username string, metadata map[string]interface{}, displayName string, timezone string, location string, langTag string, avatarUrl string) error {
	ret := _m.Called(ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl)

	if len(ret) == 0 {
		panic("no return value specified for AccountUpdateId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, string, string, string, string, string) error); ok {
		r0 = rf(ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_AccountUpdateId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountUpdateId'
type NakamaModule_AccountUpdateId_Call struct {
	*mock.Call
}

// AccountUpdateId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - metadata map[string]interface{}
//   - displayName string
//   - timezone string
//   - location string
//   - langTag string
//   - avatarUrl string
func (_e *NakamaModule_Expecter) AccountUpdateId(ctx interface{}, userID interface{}, username interface{}, metadata interface{}, displayName interface{}, timezone interface{}, location interface{}, langTag interface{}, avatarUrl interface{}) *NakamaModule_AccountUpdateId_Call {
	return &NakamaModule_AccountUpdateId_Call{Call: _e.mock.On("AccountUpdateId", ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl)}
}

func (_c *NakamaModule_AccountUpdateId_Call) Run(run func(ctx context.Context, userID string, username string, metadata map[string]interface{}, displayName string, timezone string, location string, langTag string, avatarUrl string)) *NakamaModule_AccountUpdateId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string]interface{}), args[4].(string), args[5].(string), args[6].(string), args[7].(string), args[8].(string))
	})
	return _c
}

func (_c *NakamaModule_AccountUpdateId_Call) Return(_a0 error) *NakamaModule_AccountUpdateId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_AccountUpdateId_Call) RunAndReturn(run func(context.Context, string, string, map[string]interface{}, string, string, string, string, string) error) *NakamaModule_AccountUpdateId_Call {
	_c.Call.Return(run)
	return _c
}

// AccountsGetId provides a mock function with given fields: ctx, userIDs
func (_m *NakamaModule) AccountsGetId(ctx context.Context, userIDs []string) ([]*api.Account, error) {
	ret := _m.Called(ctx, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for AccountsGetId")
	}

	var r0 []*api.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Account, error)); ok {
		return rf(ctx, userIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Account); ok {
		r0 = rf(ctx, userIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, userIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_AccountsGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountsGetId'
type NakamaModule_AccountsGetId_Call struct {
	*mock.Call
}

// AccountsGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - userIDs []string
func (_e *NakamaModule_Expecter) AccountsGetId(ctx interface{}, userIDs interface{}) *NakamaModule_AccountsGetId_Call {
	return &NakamaModule_AccountsGetId_Call{Call: _e.mock.On("AccountsGetId", ctx, userIDs)}
}

func (_c *NakamaModule_AccountsGetId_Call) Run(run func(ctx context.Context, userIDs []string)) *NakamaModule_AccountsGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *NakamaModule_AccountsGetId_Call) Return(_a0 []*api.Account, _a1 error) *NakamaModule_AccountsGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_AccountsGetId_Call) RunAndReturn(run func(context.Context, []string) ([]*api.Account, error)) *NakamaModule_AccountsGetId_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateApple provides a mock function with given fields: ctx, token, username, create
func (_m *NakamaModule) AuthenticateApple(ctx context.Context, token string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateApple")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, token, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, token, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, token, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, token, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// NakamaModule_AuthenticateApple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateApple'
type NakamaModule_AuthenticateApple_Call struct {
	*mock.Call
}

// AuthenticateApple is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
//   - username string
//   - create bool
func (_e *NakamaModule_Expecter) AuthenticateApple(ctx interface{}, token interface{}, username interface{}, create interface{}) *NakamaModule_AuthenticateApple_Call {
	return &NakamaModule_AuthenticateApple_Call{Call: _e.mock.On("AuthenticateApple", ctx, token, username, create)}
}

func (_c *NakamaModule_AuthenticateApple_Call) Run(run func(ctx context.Context, token string, username string, create bool)) *NakamaModule_AuthenticateApple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *NakamaModule_AuthenticateApple_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *NakamaModule_AuthenticateApple_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *NakamaModule_AuthenticateApple_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *NakamaModule_AuthenticateApple_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateCustom provides a mock function with given fields: ctx, id, username, create
func (_m *NakamaModule) AuthenticateCustom(ctx context.Context, id string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, id, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateCustom")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, id, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, id, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, id, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, id, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, id, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// NakamaModule_AuthenticateCustom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateCustom'
type NakamaModule_AuthenticateCustom_Call struct {
	*mock.Call
}

// AuthenticateCustom is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - username string
//   - create bool
func (_e *NakamaModule_Expecter) AuthenticateCustom(ctx interface{}, id interface{}, username interface{}, create interface{}) *NakamaModule_AuthenticateCustom_Call {
	return &NakamaModule_AuthenticateCustom_Call{Call: _e.mock.On("AuthenticateCustom", ctx, id, username, create)}
}

func (_c *NakamaModule_AuthenticateCustom_Call) Run(run func(ctx context.Context, id string, username string, create bool)) *NakamaModule_AuthenticateCustom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *NakamaModule_AuthenticateCustom_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *NakamaModule_AuthenticateCustom_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *NakamaModule_AuthenticateCustom_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *NakamaModule_AuthenticateCustom_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateDevice provides a mock function with given fields: ctx, id, username, create
func (_m *NakamaModule) AuthenticateDevice(ctx context.Context, id string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, id, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateDevice")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, id, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, id, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, id, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, id, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, id, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// NakamaModule_AuthenticateDevice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateDevice'
type NakamaModule_AuthenticateDevice_Call struct {
	*mock.Call
}

// AuthenticateDevice is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - username string
//   - create bool
func (_e *NakamaModule_Expecter) AuthenticateDevice(ctx interface{}, id interface{}, username interface{}, create interface{}) *NakamaModule_AuthenticateDevice_Call {
	return &NakamaModule_AuthenticateDevice_Call{Call: _e.mock.On("AuthenticateDevice", ctx, id, username, create)}
}

func (_c *NakamaModule_AuthenticateDevice_Call) Run(run func(ctx context.Context, id string, username string, create bool)) *NakamaModule_AuthenticateDevice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *NakamaModule_AuthenticateDevice_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *NakamaModule_AuthenticateDevice_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *NakamaModule_AuthenticateDevice_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *NakamaModule_AuthenticateDevice_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateEmail provides a mock function with given fields: ctx, email, password, username, create
func (_m *NakamaModule) AuthenticateEmail(ctx context.Context, email string, password string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, email, password, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateEmail")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, email, password, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) string); ok {
		r0 = rf(ctx, email, password, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, bool) string); ok {
		r1 = rf(ctx, email, password, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, bool) bool); ok {
		r2 = rf(ctx, email, password, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, string, bool) error); ok {
		r3 = rf(ctx, email, password, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// NakamaModule_AuthenticateEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateEmail'
type NakamaModule_AuthenticateEmail_Call struct {
	*mock.Call
}

// AuthenticateEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - password string
//   - username string
//   - create bool
func (_e *NakamaModule_Expecter) AuthenticateEmail(ctx interface{}, email interface{}, password interface{}, username interface{}, create interface{}) *NakamaModule_AuthenticateEmail_Call {
	return &NakamaModule_AuthenticateEmail_Call{Call: _e.mock.On("AuthenticateEmail", ctx, email, password, username, create)}
}

func (_c *NakamaModule_AuthenticateEmail_Call) Run(run func(ctx context.Context, email string, password string, username string, create bool)) *NakamaModule_AuthenticateEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(bool))
	})
	return _c
}

func (_c *NakamaModule_AuthenticateEmail_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *NakamaModule_AuthenticateEmail_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *NakamaModule_AuthenticateEmail_Call) RunAndReturn(run func(context.Context, string, string, string, bool) (string, string, bool, error)) *NakamaModule_AuthenticateEmail_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateFacebook provides a mock function with given fields: ctx, token, importFriends, username, create
func (_m *NakamaModule) AuthenticateFacebook(ctx context.Context, token string, importFriends bool, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, importFriends, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateFacebook")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, importFriends, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, bool) string); ok {
		r0 = rf(ctx, token, importFriends, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool, string, bool) string); ok {
		r1 = rf(ctx, token, importFriends, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, bool, string, bool) bool); ok {
		r2 = rf(ctx, token, importFriends, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, bool, string, bool) error); ok {
		r3 = rf(ctx, token, importFriends, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// NakamaModule_AuthenticateFacebook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateFacebook'
type NakamaModule_AuthenticateFacebook_Call struct {
	*mock.Call
}

// AuthenticateFacebook is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
//   - importFriends bool
//   - username string
//   - create bool
func (_e *NakamaModule_Expecter) AuthenticateFacebook(ctx interface{}, token interface{}, importFriends interface{}, username interface{}, create interface{}) *NakamaModule_AuthenticateFacebook_Call {
	return &NakamaModule_AuthenticateFacebook_Call{Call: _e.mock.On("AuthenticateFacebook", ctx, token, importFriends, username, create)}
}

func (_c *NakamaModule_AuthenticateFacebook_Call) Run(run func(ctx context.Context, token string, importFriends bool, username string, create bool)) *NakamaModule_AuthenticateFacebook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool), args[3].(string), args[4].(bool))
	})
	return _c
}

func (_c *NakamaModule_AuthenticateFacebook_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *NakamaModule_AuthenticateFacebook_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *NakamaModule_AuthenticateFacebook_Call) RunAndReturn(run func(context.Context, string, bool, string, bool) (string, string, bool, error)) *NakamaModule_AuthenticateFacebook_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateFacebookInstantGame provides a mock function with given fields: ctx, signedPlayerInfo, username, create
func (_m *NakamaModule) AuthenticateFacebookInstantGame(ctx context.Context, signedPlayerInfo string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, signedPlayerInfo, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateFacebookInstantGame")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, signedPlayerInfo, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// NakamaModule_AuthenticateFacebookInstantGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateFacebookInstantGame'
type NakamaModule_AuthenticateFacebookInstantGame_Call struct {
	*mock.Call
}

// AuthenticateFacebookInstantGame is a helper method to define mock.On call
//   - ctx context.Context
//   - signedPlayerInfo string
//   - username string
//   - create bool
func (_e *NakamaModule_Expecter) AuthenticateFacebookInstantGame(ctx interface{}, signedPlayerInfo interface{}, username interface{}, create interface{}) *NakamaModule_AuthenticateFacebookInstantGame_Call {
	return &NakamaModule_AuthenticateFacebookInstantGame_Call{Call: _e.mock.On("AuthenticateFacebookInstantGame", ctx, signedPlayerInfo, username, create)}
}

func (_c *NakamaModule_AuthenticateFacebookInstantGame_Call) Run(run func(ctx context.Context, signedPlayerInfo string, username string, create bool)) *NakamaModule_AuthenticateFacebookInstantGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *NakamaModule_AuthenticateFacebookInstantGame_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *NakamaModule_AuthenticateFacebookInstantGame_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *NakamaModule_AuthenticateFacebookInstantGame_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *NakamaModule_AuthenticateFacebookInstantGame_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateGameCenter provides a mock function with given fields: ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create
func (_m *NakamaModule) AuthenticateGameCenter(ctx context.Context, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateGameCenter")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, string, string, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, string, string, string, string, bool) string); ok {
		r0 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int64, string, string, string, string, bool) string); ok {
		r1 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, int64, string, string, string, string, bool) bool); ok {
		r2 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, int64, string, string, string, string, bool) error); ok {
		r3 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// NakamaModule_AuthenticateGameCenter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateGameCenter'
type NakamaModule_AuthenticateGameCenter_Call struct {
	*mock.Call
}

// AuthenticateGameCenter is a helper method to define mock.On call
//   - ctx context.Context
//   - playerID string
//   - bundleID string
//   - timestamp int64
//   - salt string
//   - signature string
//   - publicKeyUrl string
//   - username string
//   - create bool
func (_e *NakamaModule_Expecter) AuthenticateGameCenter(ctx interface{}, playerID interface{}, bundleID interface{}, timestamp interface{}, salt interface{}, signature interface{}, publicKeyUrl interface{}, username interface{}, create interface{}) *NakamaModule_AuthenticateGameCenter_Call {
	return &NakamaModule_AuthenticateGameCenter_Call{Call: _e.mock.On("AuthenticateGameCenter", ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)}
}

func (_c *NakamaModule_AuthenticateGameCenter_Call) Run(run func(ctx context.Context, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string, username string, create bool)) *NakamaModule_AuthenticateGameCenter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64), args[4].(string), args[5].(string), args[6].(string), args[7].(string), args[8].(bool))
	})
	return _c
}

func (_c *NakamaModule_AuthenticateGameCenter_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *NakamaModule_AuthenticateGameCenter_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *NakamaModule_AuthenticateGameCenter_Call) RunAndReturn(run func(context.Context, string, string, int64, string, string, string, string, bool) (string, string, bool, error)) *NakamaModule_AuthenticateGameCenter_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateGoogle provides a mock function with given fields: ctx, token, username, create
func (_m *NakamaModule) AuthenticateGoogle(ctx context.Context, token string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateGoogle")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, token, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, token, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, token, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, token, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// NakamaModule_AuthenticateGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateGoogle'
type NakamaModule_AuthenticateGoogle_Call struct {
	*mock.Call
}

// AuthenticateGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
//   - username string
//   - create bool
func (_e *NakamaModule_Expecter) AuthenticateGoogle(ctx interface{}, token interface{}, username interface{}, create interface{}) *NakamaModule_AuthenticateGoogle_Call {
	return &NakamaModule_AuthenticateGoogle_Call{Call: _e.mock.On("AuthenticateGoogle", ctx, token, username, create)}
}

func (_c *NakamaModule_AuthenticateGoogle_Call) Run(run func(ctx context.Context, token string, username string, create bool)) *NakamaModule_AuthenticateGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *NakamaModule_AuthenticateGoogle_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *NakamaModule_AuthenticateGoogle_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *NakamaModule_AuthenticateGoogle_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *NakamaModule_AuthenticateGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateSteam provides a mock function with given fields: ctx, token, username, create
func (_m *NakamaModule) AuthenticateSteam(ctx context.Context, token string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateSteam")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, token, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, token, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, token, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, token, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// NakamaModule_AuthenticateSteam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateSteam'
type NakamaModule_AuthenticateSteam_Call struct {
	*mock.Call
}

// AuthenticateSteam is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
//   - username string
//   - create bool
func (_e *NakamaModule_Expecter) AuthenticateSteam(ctx interface{}, token interface{}, username interface{}, create interface{}) *NakamaModule_AuthenticateSteam_Call {
	return &NakamaModule_AuthenticateSteam_Call{Call: _e.mock.On("AuthenticateSteam", ctx, token, username, create)}
}

func (_c *NakamaModule_AuthenticateSteam_Call) Run(run func(ctx context.Context, token string, username string, create bool)) *NakamaModule_AuthenticateSteam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *NakamaModule_AuthenticateSteam_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *NakamaModule_AuthenticateSteam_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *NakamaModule_AuthenticateSteam_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *NakamaModule_AuthenticateSteam_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateTokenGenerate provides a mock function with given fields: userID, username, exp, vars
func (_m *NakamaModule) AuthenticateTokenGenerate(userID string, username string, exp int64, vars map[string]string) (string, int64, error) {
	ret := _m.Called(userID, username, exp, vars)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateTokenGenerate")
	}

	var r0 string
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, int64, map[string]string) (string, int64, error)); ok {
		return rf(userID, username, exp, vars)
	}
	if rf, ok := ret.Get(0).(func(string, string, int64, map[string]string) string); ok {
		r0 = rf(userID, username, exp, vars)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string, int64, map[string]string) int64); ok {
		r1 = rf(userID, username, exp, vars)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(string, string, int64, map[string]string) error); ok {
		r2 = rf(userID, username, exp, vars)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NakamaModule_AuthenticateTokenGenerate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateTokenGenerate'
type NakamaModule_AuthenticateTokenGenerate_Call struct {
	*mock.Call
}

// AuthenticateTokenGenerate is a helper method to define mock.On call
//   - userID string
//   - username string
//   - exp int64
//   - vars map[string]string
func (_e *NakamaModule_Expecter) AuthenticateTokenGenerate(userID interface{}, username interface{}, exp interface{}, vars interface{}) *NakamaModule_AuthenticateTokenGenerate_Call {
	return &NakamaModule_AuthenticateTokenGenerate_Call{Call: _e.mock.On("AuthenticateTokenGenerate", userID, username, exp, vars)}
}

func (_c *NakamaModule_AuthenticateTokenGenerate_Call) Run(run func(userID string, username string, exp int64, vars map[string]string)) *NakamaModule_AuthenticateTokenGenerate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(int64), args[3].(map[string]string))
	})
	return _c
}

func (_c *NakamaModule_AuthenticateTokenGenerate_Call) Return(_a0 string, _a1 int64, _a2 error) *NakamaModule_AuthenticateTokenGenerate_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NakamaModule_AuthenticateTokenGenerate_Call) RunAndReturn(run func(string, string, int64, map[string]string) (string, int64, error)) *NakamaModule_AuthenticateTokenGenerate_Call {
	_c.Call.Return(run)
	return _c
}

// ChannelIdBuild provides a mock function with given fields: ctx, sender, target, chanType
func (_m *NakamaModule) ChannelIdBuild(ctx context.Context, sender string, target string, chanType runtime.ChannelType) (string, error) {
	ret := _m.Called(ctx, sender, target, chanType)

	if len(ret) == 0 {
		panic("no return value specified for ChannelIdBuild")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, runtime.ChannelType) (string, error)); ok {
		return rf(ctx, sender, target, chanType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, runtime.ChannelType) string); ok {
		r0 = rf(ctx, sender, target, chanType)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, runtime.ChannelType) error); ok {
		r1 = rf(ctx, sender, target, chanType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_ChannelIdBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChannelIdBuild'
type NakamaModule_ChannelIdBuild_Call struct {
	*mock.Call
}

// ChannelIdBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - sender string
//   - target string
//   - chanType runtime.ChannelType
func (_e *NakamaModule_Expecter) ChannelIdBuild(ctx interface{}, sender interface{}, target interface{}, chanType interface{}) *NakamaModule_ChannelIdBuild_Call {
	return &NakamaModule_ChannelIdBuild_Call{Call: _e.mock.On("ChannelIdBuild", ctx, sender, target, chanType)}
}

func (_c *NakamaModule_ChannelIdBuild_Call) Run(run func(ctx context.Context, sender string, target string, chanType runtime.ChannelType)) *NakamaModule_ChannelIdBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(runtime.ChannelType))
	})
	return _c
}

func (_c *NakamaModule_ChannelIdBuild_Call) Return(_a0 string, _a1 error) *NakamaModule_ChannelIdBuild_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_ChannelIdBuild_Call) RunAndReturn(run func(context.Context, string, string, runtime.ChannelType) (string, error)) *NakamaModule_ChannelIdBuild_Call {
	_c.Call.Return(run)
	return _c
}

// ChannelMessageRemove provides a mock function with given fields: ctx, channelId, messageId, senderId, senderUsername, persist
func (_m *NakamaModule) ChannelMessageRemove(ctx context.Context, channelId string, messageId string, senderId string, senderUsername string, persist bool) (*rtapi.ChannelMessageAck, error) {
	ret := _m.Called(ctx, channelId, messageId, senderId, senderUsername, persist)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageRemove")
	}

	var r0 *rtapi.ChannelMessageAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, bool) (*rtapi.ChannelMessageAck, error)); ok {
		return rf(ctx, channelId, messageId, senderId, senderUsername, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, bool) *rtapi.ChannelMessageAck); ok {
		r0 = rf(ctx, channelId, messageId, senderId, senderUsername, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtapi.ChannelMessageAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, bool) error); ok {
		r1 = rf(ctx, channelId, messageId, senderId, senderUsername, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_ChannelMessageRemove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChannelMessageRemove'
type NakamaModule_ChannelMessageRemove_Call struct {
	*mock.Call
}

// ChannelMessageRemove is a helper method to define mock.On call
//   - ctx context.Context
//   - channelId string
//   - messageId string
//   - senderId string
//   - senderUsername string
//   - persist bool
func (_e *NakamaModule_Expecter) ChannelMessageRemove(ctx interface{}, channelId interface{}, messageId interface{}, senderId interface{}, senderUsername interface{}, persist interface{}) *NakamaModule_ChannelMessageRemove_Call {
	return &NakamaModule_ChannelMessageRemove_Call{Call: _e.mock.On("ChannelMessageRemove", ctx, channelId, messageId, senderId, senderUsername, persist)}
}

func (_c *NakamaModule_ChannelMessageRemove_Call) Run(run func(ctx context.Context, channelId string, messageId string, senderId string, senderUsername string, persist bool)) *NakamaModule_ChannelMessageRemove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(bool))
	})
	return _c
}

func (_c *NakamaModule_ChannelMessageRemove_Call) Return(_a0 *rtapi.ChannelMessageAck, _a1 error) *NakamaModule_ChannelMessageRemove_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_ChannelMessageRemove_Call) RunAndReturn(run func(context.Context, string, string, string, string, bool) (*rtapi.ChannelMessageAck, error)) *NakamaModule_ChannelMessageRemove_Call {
	_c.Call.Return(run)
	return _c
}

// ChannelMessageSend provides a mock function with given fields: ctx, channelID, content, senderId, senderUsername, persist
func (_m *NakamaModule) ChannelMessageSend(ctx context.Context, channelID string, content map[string]interface{}, senderId string, senderUsername string, persist bool) (*rtapi.ChannelMessageAck, error) {
	ret := _m.Called(ctx, channelID, content, senderId, senderUsername, persist)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageSend")
	}

	var r0 *rtapi.ChannelMessageAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, string, string, bool) (*rtapi.ChannelMessageAck, error)); ok {
		return rf(ctx, channelID, content, senderId, senderUsername, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, string, string, bool) *rtapi.ChannelMessageAck); ok {
		r0 = rf(ctx, channelID, content, senderId, senderUsername, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtapi.ChannelMessageAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]interface{}, string, string, bool) error); ok {
		r1 = rf(ctx, channelID, content, senderId, senderUsername, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_ChannelMessageSend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChannelMessageSend'
type NakamaModule_ChannelMessageSend_Call struct {
	*mock.Call
}

// ChannelMessageSend is a helper method to define mock.On call
//   - ctx context.Context
//   - channelID string
//   - content map[string]interface{}
//   - senderId string
//   - senderUsername string
//   - persist bool
func (_e *NakamaModule_Expecter) ChannelMessageSend(ctx interface{}, channelID interface{}, content interface{}, senderId interface{}, senderUsername interface{}, persist interface{}) *NakamaModule_ChannelMessageSend_Call {
	return &NakamaModule_ChannelMessageSend_Call{Call: _e.mock.On("ChannelMessageSend", ctx, channelID, content, senderId, senderUsername, persist)}
}

func (_c *NakamaModule_ChannelMessageSend_Call) Run(run func(ctx context.Context, channelID string, content map[string]interface{}, senderId string, senderUsername string, persist bool)) *NakamaModule_ChannelMessageSend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]interface{}), args[3].(string), args[4].(string), args[5].(bool))
	})
	return _c
}

func (_c *NakamaModule_ChannelMessageSend_Call) Return(_a0 *rtapi.ChannelMessageAck, _a1 error) *NakamaModule_ChannelMessageSend_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_ChannelMessageSend_Call) RunAndReturn(run func(context.Context, string, map[string]interface{}, string, string, bool) (*rtapi.ChannelMessageAck, error)) *NakamaModule_ChannelMessageSend_Call {
	_c.Call.Return(run)
	return _c
}

// ChannelMessageUpdate provides a mock function with given fields: ctx, channelID, messageID, content, senderId, senderUsername, persist
func (_m *NakamaModule) ChannelMessageUpdate(ctx context.Context, channelID string, messageID string, content map[string]interface{}, senderId string, senderUsername string, persist bool) (*rtapi.ChannelMessageAck, error) {
	ret := _m.Called(ctx, channelID, messageID, content, senderId, senderUsername, persist)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageUpdate")
	}

	var r0 *rtapi.ChannelMessageAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, string, string, bool) (*rtapi.ChannelMessageAck, error)); ok {
		return rf(ctx, channelID, messageID, content, senderId, senderUsername, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, string, string, bool) *rtapi.ChannelMessageAck); ok {
		r0 = rf(ctx, channelID, messageID, content, senderId, senderUsername, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtapi.ChannelMessageAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, map[string]interface{}, string, string, bool) error); ok {
		r1 = rf(ctx, channelID, messageID, content, senderId, senderUsername, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_ChannelMessageUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChannelMessageUpdate'
type NakamaModule_ChannelMessageUpdate_Call struct {
	*mock.Call
}

// ChannelMessageUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - channelID string
//   - messageID string
//   - content map[string]interface{}
//   - senderId string
//   - senderUsername string
//   - persist bool
func (_e *NakamaModule_Expecter) ChannelMessageUpdate(ctx interface{}, channelID interface{}, messageID interface{}, content interface{}, senderId interface{}, senderUsername interface{}, persist interface{}) *NakamaModule_ChannelMessageUpdate_Call {
	return &NakamaModule_ChannelMessageUpdate_Call{Call: _e.mock.On("ChannelMessageUpdate", ctx, channelID, messageID, content, senderId, senderUsername, persist)}
}

func (_c *NakamaModule_ChannelMessageUpdate_Call) Run(run func(ctx context.Context, channelID string, messageID string, content map[string]interface{}, senderId string, senderUsername string, persist bool)) *NakamaModule_ChannelMessageUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string]interface{}), args[4].(string), args[5].(string), args[6].(bool))
	})
	return _c
}

func (_c *NakamaModule_ChannelMessageUpdate_Call) Return(_a0 *rtapi.ChannelMessageAck, _a1 error) *NakamaModule_ChannelMessageUpdate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_ChannelMessageUpdate_Call) RunAndReturn(run func(context.Context, string, string, map[string]interface{}, string, string, bool) (*rtapi.ChannelMessageAck, error)) *NakamaModule_ChannelMessageUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// ChannelMessagesList provides a mock function with given fields: ctx, channelId, limit, forward, cursor
func (_m *NakamaModule) ChannelMessagesList(ctx context.Context, channelId string, limit int, forward bool, cursor string) ([]*api.ChannelMessage, string, string, error) {
	ret := _m.Called(ctx, channelId, limit, forward, cursor)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessagesList")
	}

	var r0 []*api.ChannelMessage
	var r1 string
	var r2 string
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, bool, string) ([]*api.ChannelMessage, string, string, error)); ok {
		return rf(ctx, channelId, limit, forward, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, bool, string) []*api.ChannelMessage); ok {
		r0 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.ChannelMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, bool, string) string); ok {
		r1 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, bool, string) string); ok {
		r2 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, int, bool, string) error); ok {
		r3 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// NakamaModule_ChannelMessagesList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChannelMessagesList'
type NakamaModule_ChannelMessagesList_Call struct {
	*mock.Call
}

// ChannelMessagesList is a helper method to define mock.On call
//   - ctx context.Context
//   - channelId string
//   - limit int
//   - forward bool
//   - cursor string
func (_e *NakamaModule_Expecter) ChannelMessagesList(ctx interface{}, channelId interface{}, limit interface{}, forward interface{}, cursor interface{}) *NakamaModule_ChannelMessagesList_Call {
	return &NakamaModule_ChannelMessagesList_Call{Call: _e.mock.On("ChannelMessagesList", ctx, channelId, limit, forward, cursor)}
}

func (_c *NakamaModule_ChannelMessagesList_Call) Run(run func(ctx context.Context, channelId string, limit int, forward bool, cursor string)) *NakamaModule_ChannelMessagesList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(bool), args[4].(string))
	})
	return _c
}

func (_c *NakamaModule_ChannelMessagesList_Call) Return(messages []*api.ChannelMessage, nextCursor string, prevCursor string, err error) *NakamaModule_ChannelMessagesList_Call {
	_c.Call.Return(messages, nextCursor, prevCursor, err)
	return _c
}

func (_c *NakamaModule_ChannelMessagesList_Call) RunAndReturn(run func(context.Context, string, int, bool, string) ([]*api.ChannelMessage, string, string, error)) *NakamaModule_ChannelMessagesList_Call {
	_c.Call.Return(run)
	return _c
}

// Event provides a mock function with given fields: ctx, evt
func (_m *NakamaModule) Event(ctx context.Context, evt *api.Event) error {
	ret := _m.Called(ctx, evt)

	if len(ret) == 0 {
		panic("no return value specified for Event")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.Event) error); ok {
		r0 = rf(ctx, evt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_Event_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Event'
type NakamaModule_Event_Call struct {
	*mock.Call
}

// Event is a helper method to define mock.On call
//   - ctx context.Context
//   - evt *api.Event
func (_e *NakamaModule_Expecter) Event(ctx interface{}, evt interface{}) *NakamaModule_Event_Call {
	return &NakamaModule_Event_Call{Call: _e.mock.On("Event", ctx, evt)}
}

func (_c *NakamaModule_Event_Call) Run(run func(ctx context.Context, evt *api.Event)) *NakamaModule_Event_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*api.Event))
	})
	return _c
}

func (_c *NakamaModule_Event_Call) Return(_a0 error) *NakamaModule_Event_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_Event_Call) RunAndReturn(run func(context.Context, *api.Event) error) *NakamaModule_Event_Call {
	_c.Call.Return(run)
	return _c
}

// FriendsAdd provides a mock function with given fields: ctx, userID, username, ids, usernames
func (_m *NakamaModule) FriendsAdd(ctx context.Context, userID string, username string, ids []string, usernames []string) error {
	ret := _m.Called(ctx, userID, username, ids, usernames)

	if len(ret) == 0 {
		panic("no return value specified for FriendsAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, []string) error); ok {
		r0 = rf(ctx, userID, username, ids, usernames)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_FriendsAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FriendsAdd'
type NakamaModule_FriendsAdd_Call struct {
	*mock.Call
}

// FriendsAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - ids []string
//   - usernames []string
func (_e *NakamaModule_Expecter) FriendsAdd(ctx interface{}, userID interface{}, username interface{}, ids interface{}, usernames interface{}) *NakamaModule_FriendsAdd_Call {
	return &NakamaModule_FriendsAdd_Call{Call: _e.mock.On("FriendsAdd", ctx, userID, username, ids, usernames)}
}

func (_c *NakamaModule_FriendsAdd_Call) Run(run func(ctx context.Context, userID string, username string, ids []string, usernames []string)) *NakamaModule_FriendsAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string), args[4].([]string))
	})
	return _c
}

func (_c *NakamaModule_FriendsAdd_Call) Return(_a0 error) *NakamaModule_FriendsAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_FriendsAdd_Call) RunAndReturn(run func(context.Context, string, string, []string, []string) error) *NakamaModule_FriendsAdd_Call {
	_c.Call.Return(run)
	return _c
}

// FriendsBlock provides a mock function with given fields: ctx, userID, username, ids, usernames
func (_m *NakamaModule) FriendsBlock(ctx context.Context, userID string, username string, ids []string, usernames []string) error {
	ret := _m.Called(ctx, userID, username, ids, usernames)

	if len(ret) == 0 {
		panic("no return value specified for FriendsBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, []string) error); ok {
		r0 = rf(ctx, userID, username, ids, usernames)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_FriendsBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FriendsBlock'
type NakamaModule_FriendsBlock_Call struct {
	*mock.Call
}

// FriendsBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - ids []string
//   - usernames []string
func (_e *NakamaModule_Expecter) FriendsBlock(ctx interface{}, userID interface{}, username interface{}, ids interface{}, usernames interface{}) *NakamaModule_FriendsBlock_Call {
	return &NakamaModule_FriendsBlock_Call{Call: _e.mock.On("FriendsBlock", ctx, userID, username, ids, usernames)}
}

func (_c *NakamaModule_FriendsBlock_Call) Run(run func(ctx context.Context, userID string, username string, ids []string, usernames []string)) *NakamaModule_FriendsBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string), args[4].([]string))
	})
	return _c
}

func (_c *NakamaModule_FriendsBlock_Call) Return(_a0 error) *NakamaModule_FriendsBlock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_FriendsBlock_Call) RunAndReturn(run func(context.Context, string, string, []string, []string) error) *NakamaModule_FriendsBlock_Call {
	_c.Call.Return(run)
	return _c
}

// FriendsDelete provides a mock function with given fields: ctx, userID, username, ids, usernames
func (_m *NakamaModule) FriendsDelete(ctx context.Context, userID string, username string, ids []string, usernames []string) error {
	ret := _m.Called(ctx, userID, username, ids, usernames)

	if len(ret) == 0 {
		panic("no return value specified for FriendsDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, []string) error); ok {
		r0 = rf(ctx, userID, username, ids, usernames)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_FriendsDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FriendsDelete'
type NakamaModule_FriendsDelete_Call struct {
	*mock.Call
}

// FriendsDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - ids []string
//   - usernames []string
func (_e *NakamaModule_Expecter) FriendsDelete(ctx interface{}, userID interface{}, username interface{}, ids interface{}, usernames interface{}) *NakamaModule_FriendsDelete_Call {
	return &NakamaModule_FriendsDelete_Call{Call: _e.mock.On("FriendsDelete", ctx, userID, username, ids, usernames)}
}

func (_c *NakamaModule_FriendsDelete_Call) Run(run func(ctx context.Context, userID string, username string, ids []string, usernames []string)) *NakamaModule_FriendsDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string), args[4].([]string))
	})
	return _c
}

func (_c *NakamaModule_FriendsDelete_Call) Return(_a0 error) *NakamaModule_FriendsDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_FriendsDelete_Call) RunAndReturn(run func(context.Context, string, string, []string, []string) error) *NakamaModule_FriendsDelete_Call {
	_c.Call.Return(run)
	return _c
}

// FriendsList provides a mock function with given fields: ctx, userID, limit, state, cursor
func (_m *NakamaModule) FriendsList(ctx context.Context, userID string, limit int, state *int, cursor string) ([]*api.Friend, string, error) {
	ret := _m.Called(ctx, userID, limit, state, cursor)

	if len(ret) == 0 {
		panic("no return value specified for FriendsList")
	}

	var r0 []*api.Friend
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) ([]*api.Friend, string, error)); ok {
		return rf(ctx, userID, limit, state, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) []*api.Friend); ok {
		r0 = rf(ctx, userID, limit, state, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Friend)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *int, string) string); ok {
		r1 = rf(ctx, userID, limit, state, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, *int, string) error); ok {
		r2 = rf(ctx, userID, limit, state, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NakamaModule_FriendsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FriendsList'
type NakamaModule_FriendsList_Call struct {
	*mock.Call
}

// FriendsList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - state *int
//   - cursor string
func (_e *NakamaModule_Expecter) FriendsList(ctx interface{}, userID interface{}, limit interface{}, state interface{}, cursor interface{}) *NakamaModule_FriendsList_Call {
	return &NakamaModule_FriendsList_Call{Call: _e.mock.On("FriendsList", ctx, userID, limit, state, cursor)}
}

func (_c *NakamaModule_FriendsList_Call) Run(run func(ctx context.Context, userID string, limit int, state *int, cursor string)) *NakamaModule_FriendsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*int), args[4].(string))
	})
	return _c
}

func (_c *NakamaModule_FriendsList_Call) Return(_a0 []*api.Friend, _a1 string, _a2 error) *NakamaModule_FriendsList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NakamaModule_FriendsList_Call) RunAndReturn(run func(context.Context, string, int, *int, string) ([]*api.Friend, string, error)) *NakamaModule_FriendsList_Call {
	_c.Call.Return(run)
	return _c
}

// GetSatori provides a mock function with given fields:
func (_m *NakamaModule) GetSatori() runtime.Satori {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSatori")
	}

	var r0 runtime.Satori
	if rf, ok := ret.Get(0).(func() runtime.Satori); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.Satori)
		}
	}

	return r0
}

// NakamaModule_GetSatori_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSatori'
type NakamaModule_GetSatori_Call struct {
	*mock.Call
}

// GetSatori is a helper method to define mock.On call
func (_e *NakamaModule_Expecter) GetSatori() *NakamaModule_GetSatori_Call {
	return &NakamaModule_GetSatori_Call{Call: _e.mock.On("GetSatori")}
}

func (_c *NakamaModule_GetSatori_Call) Run(run func()) *NakamaModule_GetSatori_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *NakamaModule_GetSatori_Call) Return(_a0 runtime.Satori) *NakamaModule_GetSatori_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_GetSatori_Call) RunAndReturn(run func() runtime.Satori) *NakamaModule_GetSatori_Call {
	_c.Call.Return(run)
	return _c
}

// GroupCreate provides a mock function with given fields: ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount
func (_m *NakamaModule) GroupCreate(ctx context.Context, userID string, name string, creatorID string, langTag string, description string, avatarUrl string, open bool, metadata map[string]interface{}, maxCount int) (*api.Group, error) {
	ret := _m.Called(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)

	if len(ret) == 0 {
		panic("no return value specified for GroupCreate")
	}

	var r0 *api.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) (*api.Group, error)); ok {
		return rf(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) *api.Group); ok {
		r0 = rf(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) error); ok {
		r1 = rf(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_GroupCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupCreate'
type NakamaModule_GroupCreate_Call struct {
	*mock.Call
}

// GroupCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - name string
//   - creatorID string
//   - langTag string
//   - description string
//   - avatarUrl string
//   - open bool
//   - metadata map[string]interface{}
//   - maxCount int
func (_e *NakamaModule_Expecter) GroupCreate(ctx interface{}, userID interface{}, name interface{}, creatorID interface{}, langTag interface{}, description interface{}, avatarUrl interface{}, open interface{}, metadata interface{}, maxCount interface{}) *NakamaModule_GroupCreate_Call {
	return &NakamaModule_GroupCreate_Call{Call: _e.mock.On("GroupCreate", ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)}
}

func (_c *NakamaModule_GroupCreate_Call) Run(run func(ctx context.Context, userID string, name string, creatorID string, langTag string, description string, avatarUrl string, open bool, metadata map[string]interface{}, maxCount int)) *NakamaModule_GroupCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string), args[6].(string), args[7].(bool), args[8].(map[string]interface{}), args[9].(int))
	})
	return _c
}

func (_c *NakamaModule_GroupCreate_Call) Return(_a0 *api.Group, _a1 error) *NakamaModule_GroupCreate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_GroupCreate_Call) RunAndReturn(run func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) (*api.Group, error)) *NakamaModule_GroupCreate_Call {
	_c.Call.Return(run)
	return _c
}

// GroupDelete provides a mock function with given fields: ctx, id
func (_m *NakamaModule) GroupDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GroupDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_GroupDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupDelete'
type NakamaModule_GroupDelete_Call struct {
	*mock.Call
}

// GroupDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *NakamaModule_Expecter) GroupDelete(ctx interface{}, id interface{}) *NakamaModule_GroupDelete_Call {
	return &NakamaModule_GroupDelete_Call{Call: _e.mock.On("GroupDelete", ctx, id)}
}

func (_c *NakamaModule_GroupDelete_Call) Run(run func(ctx context.Context, id string)) *NakamaModule_GroupDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *NakamaModule_GroupDelete_Call) Return(_a0 error) *NakamaModule_GroupDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_GroupDelete_Call) RunAndReturn(run func(context.Context, string) error) *NakamaModule_GroupDelete_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUpdate provides a mock function with given fields: ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount
func (_m *NakamaModule) GroupUpdate(ctx context.Context, id string, userID string, name string, creatorID string, langTag string, description string, avatarUrl string, open bool, metadata map[string]interface{}, maxCount int) error {
	ret := _m.Called(ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)

	if len(ret) == 0 {
		panic("no return value specified for GroupUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, string, bool, map[string]interface{}, int) error); ok {
		r0 = rf(ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_GroupUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUpdate'
type NakamaModule_GroupUpdate_Call struct {
	*mock.Call
}

// GroupUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - userID string
//   - name string
//   - creatorID string
//   - langTag string
//   - description string
//   - avatarUrl string
//   - open bool
//   - metadata map[string]interface{}
//   - maxCount int
func (_e *NakamaModule_Expecter) GroupUpdate(ctx interface{}, id interface{}, userID interface{}, name interface{}, creatorID interface{}, langTag interface{}, description interface{}, avatarUrl interface{}, open interface{}, metadata interface{}, maxCount interface{}) *NakamaModule_GroupUpdate_Call {
	return &NakamaModule_GroupUpdate_Call{Call: _e.mock.On("GroupUpdate", ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)}
}

func (_c *NakamaModule_GroupUpdate_Call) Run(run func(ctx context.Context, id string, userID string, name string, creatorID string, langTag string, description string, avatarUrl string, open bool, metadata map[string]interface{}, maxCount int)) *NakamaModule_GroupUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string), args[6].(string), args[7].(string), args[8].(bool), args[9].(map[string]interface{}), args[10].(int))
	})
	return _c
}

func (_c *NakamaModule_GroupUpdate_Call) Return(_a0 error) *NakamaModule_GroupUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_GroupUpdate_Call) RunAndReturn(run func(context.Context, string, string, string, string, string, string, string, bool, map[string]interface{}, int) error) *NakamaModule_GroupUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUserJoin provides a mock function with given fields: ctx, groupID, userID, username
func (_m *NakamaModule) GroupUserJoin(ctx context.Context, groupID string, userID string, username string) error {
	ret := _m.Called(ctx, groupID, userID, username)

	if len(ret) == 0 {
		panic("no return value specified for GroupUserJoin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, groupID, userID, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_GroupUserJoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUserJoin'
type NakamaModule_GroupUserJoin_Call struct {
	*mock.Call
}

// GroupUserJoin is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
//   - userID string
//   - username string
func (_e *NakamaModule_Expecter) GroupUserJoin(ctx interface{}, groupID interface{}, userID interface{}, username interface{}) *NakamaModule_GroupUserJoin_Call {
	return &NakamaModule_GroupUserJoin_Call{Call: _e.mock.On("GroupUserJoin", ctx, groupID, userID, username)}
}

func (_c *NakamaModule_GroupUserJoin_Call) Run(run func(ctx context.Context, groupID string, userID string, username string)) *NakamaModule_GroupUserJoin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *NakamaModule_GroupUserJoin_Call) Return(_a0 error) *NakamaModule_GroupUserJoin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_GroupUserJoin_Call) RunAndReturn(run func(context.Context, string, string, string) error) *NakamaModule_GroupUserJoin_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUserLeave provides a mock function with given fields: ctx, groupID, userID, username
func (_m *NakamaModule) GroupUserLeave(ctx context.Context, groupID string, userID string, username string) error {
	ret := _m.Called(ctx, groupID, userID, username)

	if len(ret) == 0 {
		panic("no return value specified for GroupUserLeave")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, groupID, userID, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_GroupUserLeave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUserLeave'
type NakamaModule_GroupUserLeave_Call struct {
	*mock.Call
}

// GroupUserLeave is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
//   - userID string
//   - username string
func (_e *NakamaModule_Expecter) GroupUserLeave(ctx interface{}, groupID interface{}, userID interface{}, username interface{}) *NakamaModule_GroupUserLeave_Call {
	return &NakamaModule_GroupUserLeave_Call{Call: _e.mock.On("GroupUserLeave", ctx, groupID, userID, username)}
}

func (_c *NakamaModule_GroupUserLeave_Call) Run(run func(ctx context.Context, groupID string, userID string, username string)) *NakamaModule_GroupUserLeave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *NakamaModule_GroupUserLeave_Call) Return(_a0 error) *NakamaModule_GroupUserLeave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_GroupUserLeave_Call) RunAndReturn(run func(context.Context, string, string, string) error) *NakamaModule_GroupUserLeave_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersAdd provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *NakamaModule) GroupUsersAdd(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_GroupUsersAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersAdd'
type NakamaModule_GroupUsersAdd_Call struct {
	*mock.Call
}

// GroupUsersAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - groupID string
//   - userIDs []string
func (_e *NakamaModule_Expecter) GroupUsersAdd(ctx interface{}, callerID interface{}, groupID interface{}, userIDs interface{}) *NakamaModule_GroupUsersAdd_Call {
	return &NakamaModule_GroupUsersAdd_Call{Call: _e.mock.On("GroupUsersAdd", ctx, callerID, groupID, userIDs)}
}

func (_c *NakamaModule_GroupUsersAdd_Call) Run(run func(ctx context.Context, callerID string, groupID string, userIDs []string)) *NakamaModule_GroupUsersAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *NakamaModule_GroupUsersAdd_Call) Return(_a0 error) *NakamaModule_GroupUsersAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_GroupUsersAdd_Call) RunAndReturn(run func(context.Context, string, string, []string) error) *NakamaModule_GroupUsersAdd_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersBan provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *NakamaModule) GroupUsersBan(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersBan")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_GroupUsersBan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersBan'
type NakamaModule_GroupUsersBan_Call struct {
	*mock.Call
}

// GroupUsersBan is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - groupID string
//   - userIDs []string
func (_e *NakamaModule_Expecter) GroupUsersBan(ctx interface{}, callerID interface{}, groupID interface{}, userIDs interface{}) *NakamaModule_GroupUsersBan_Call {
	return &NakamaModule_GroupUsersBan_Call{Call: _e.mock.On("GroupUsersBan", ctx, callerID, groupID, userIDs)}
}

func (_c *NakamaModule_GroupUsersBan_Call) Run(run func(ctx context.Context, callerID string, groupID string, userIDs []string)) *NakamaModule_GroupUsersBan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *NakamaModule_GroupUsersBan_Call) Return(_a0 error) *NakamaModule_GroupUsersBan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_GroupUsersBan_Call) RunAndReturn(run func(context.Context, string, string, []string) error) *NakamaModule_GroupUsersBan_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersDemote provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *NakamaModule) GroupUsersDemote(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersDemote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_GroupUsersDemote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersDemote'
type NakamaModule_GroupUsersDemote_Call struct {
	*mock.Call
}

// GroupUsersDemote is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - groupID string
//   - userIDs []string
func (_e *NakamaModule_Expecter) GroupUsersDemote(ctx interface{}, callerID interface{}, groupID interface{}, userIDs interface{}) *NakamaModule_GroupUsersDemote_Call {
	return &NakamaModule_GroupUsersDemote_Call{Call: _e.mock.On("GroupUsersDemote", ctx, callerID, groupID, userIDs)}
}

func (_c *NakamaModule_GroupUsersDemote_Call) Run(run func(ctx context.Context, callerID string, groupID string, userIDs []string)) *NakamaModule_GroupUsersDemote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *NakamaModule_GroupUsersDemote_Call) Return(_a0 error) *NakamaModule_GroupUsersDemote_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_GroupUsersDemote_Call) RunAndReturn(run func(context.Context, string, string, []string) error) *NakamaModule_GroupUsersDemote_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersKick provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *NakamaModule) GroupUsersKick(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersKick")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_GroupUsersKick_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersKick'
type NakamaModule_GroupUsersKick_Call struct {
	*mock.Call
}

// GroupUsersKick is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - groupID string
//   - userIDs []string
func (_e *NakamaModule_Expecter) GroupUsersKick(ctx interface{}, callerID interface{}, groupID interface{}, userIDs interface{}) *NakamaModule_GroupUsersKick_Call {
	return &NakamaModule_GroupUsersKick_Call{Call: _e.mock.On("GroupUsersKick", ctx, callerID, groupID, userIDs)}
}

func (_c *NakamaModule_GroupUsersKick_Call) Run(run func(ctx context.Context, callerID string, groupID string, userIDs []string)) *NakamaModule_GroupUsersKick_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *NakamaModule_GroupUsersKick_Call) Return(_a0 error) *NakamaModule_GroupUsersKick_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_GroupUsersKick_Call) RunAndReturn(run func(context.Context, string, string, []string) error) *NakamaModule_GroupUsersKick_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersList provides a mock function with given fields: ctx, id, limit, state, cursor
func (_m *NakamaModule) GroupUsersList(ctx context.Context, id string, limit int, state *int, cursor string) ([]*api.GroupUserList_GroupUser, string, error) {
	ret := _m.Called(ctx, id, limit, state, cursor)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersList")
	}

	var r0 []*api.GroupUserList_GroupUser
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) ([]*api.GroupUserList_GroupUser, string, error)); ok {
		return rf(ctx, id, limit, state, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) []*api.GroupUserList_GroupUser); ok {
		r0 = rf(ctx, id, limit, state, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.GroupUserList_GroupUser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *int, string) string); ok {
		r1 = rf(ctx, id, limit, state, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, *int, string) error); ok {
		r2 = rf(ctx, id, limit, state, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NakamaModule_GroupUsersList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersList'
type NakamaModule_GroupUsersList_Call struct {
	*mock.Call
}

// GroupUsersList is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - limit int
//   - state *int
//   - cursor string
func (_e *NakamaModule_Expecter) GroupUsersList(ctx interface{}, id interface{}, limit interface{}, state interface{}, cursor interface{}) *NakamaModule_GroupUsersList_Call {
	return &NakamaModule_GroupUsersList_Call{Call: _e.mock.On("GroupUsersList", ctx, id, limit, state, cursor)}
}

func (_c *NakamaModule_GroupUsersList_Call) Run(run func(ctx context.Context, id string, limit int, state *int, cursor string)) *NakamaModule_GroupUsersList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*int), args[4].(string))
	})
	return _c
}

func (_c *NakamaModule_GroupUsersList_Call) Return(_a0 []*api.GroupUserList_GroupUser, _a1 string, _a2 error) *NakamaModule_GroupUsersList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NakamaModule_GroupUsersList_Call) RunAndReturn(run func(context.Context, string, int, *int, string) ([]*api.GroupUserList_GroupUser, string, error)) *NakamaModule_GroupUsersList_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersPromote provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *NakamaModule) GroupUsersPromote(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersPromote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_GroupUsersPromote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersPromote'
type NakamaModule_GroupUsersPromote_Call struct {
	*mock.Call
}

// GroupUsersPromote is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - groupID string
//   - userIDs []string
func (_e *NakamaModule_Expecter) GroupUsersPromote(ctx interface{}, callerID interface{}, groupID interface{}, userIDs interface{}) *NakamaModule_GroupUsersPromote_Call {
	return &NakamaModule_GroupUsersPromote_Call{Call: _e.mock.On("GroupUsersPromote", ctx, callerID, groupID, userIDs)}
}

func (_c *NakamaModule_GroupUsersPromote_Call) Run(run func(ctx context.Context, callerID string, groupID string, userIDs []string)) *NakamaModule_GroupUsersPromote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *NakamaModule_GroupUsersPromote_Call) Return(_a0 error) *NakamaModule_GroupUsersPromote_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_GroupUsersPromote_Call) RunAndReturn(run func(context.Context, string, string, []string) error) *NakamaModule_GroupUsersPromote_Call {
	_c.Call.Return(run)
	return _c
}

// GroupsGetId provides a mock function with given fields: ctx, groupIDs
func (_m *NakamaModule) GroupsGetId(ctx context.Context, groupIDs []string) ([]*api.Group, error) {
	ret := _m.Called(ctx, groupIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupsGetId")
	}

	var r0 []*api.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Group, error)); ok {
		return rf(ctx, groupIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Group); ok {
		r0 = rf(ctx, groupIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, groupIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_GroupsGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupsGetId'
type NakamaModule_GroupsGetId_Call struct {
	*mock.Call
}

// GroupsGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - groupIDs []string
func (_e *NakamaModule_Expecter) GroupsGetId(ctx interface{}, groupIDs interface{}) *NakamaModule_GroupsGetId_Call {
	return &NakamaModule_GroupsGetId_Call{Call: _e.mock.On("GroupsGetId", ctx, groupIDs)}
}

func (_c *NakamaModule_GroupsGetId_Call) Run(run func(ctx context.Context, groupIDs []string)) *NakamaModule_GroupsGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *NakamaModule_GroupsGetId_Call) Return(_a0 []*api.Group, _a1 error) *NakamaModule_GroupsGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_GroupsGetId_Call) RunAndReturn(run func(context.Context, []string) ([]*api.Group, error)) *NakamaModule_GroupsGetId_Call {
	_c.Call.Return(run)
	return _c
}

// GroupsGetRandom provides a mock function with given fields: ctx, count
func (_m *NakamaModule) GroupsGetRandom(ctx context.Context, count int) ([]*api.Group, error) {
	ret := _m.Called(ctx, count)

	if len(ret) == 0 {
		panic("no return value specified for GroupsGetRandom")
	}

	var r0 []*api.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*api.Group, error)); ok {
		return rf(ctx, count)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*api.Group); ok {
		r0 = rf(ctx, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_GroupsGetRandom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupsGetRandom'
type NakamaModule_GroupsGetRandom_Call struct {
	*mock.Call
}

// GroupsGetRandom is a helper method to define mock.On call
//   - ctx context.Context
//   - count int
func (_e *NakamaModule_Expecter) GroupsGetRandom(ctx interface{}, count interface{}) *NakamaModule_GroupsGetRandom_Call {
	return &NakamaModule_GroupsGetRandom_Call{Call: _e.mock.On("GroupsGetRandom", ctx, count)}
}

func (_c *NakamaModule_GroupsGetRandom_Call) Run(run func(ctx context.Context, count int)) *NakamaModule_GroupsGetRandom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *NakamaModule_GroupsGetRandom_Call) Return(_a0 []*api.Group, _a1 error) *NakamaModule_GroupsGetRandom_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_GroupsGetRandom_Call) RunAndReturn(run func(context.Context, int) ([]*api.Group, error)) *NakamaModule_GroupsGetRandom_Call {
	_c.Call.Return(run)
	return _c
}

// GroupsList provides a mock function with given fields: ctx, name, langTag, members, open, limit, cursor
func (_m *NakamaModule) GroupsList(ctx context.Context, name string, langTag string, members *int, open *bool, limit int, cursor string) ([]*api.Group, string, error) {
	ret := _m.Called(ctx, name, langTag, members, open, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for GroupsList")
	}

	var r0 []*api.Group
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *int, *bool, int, string) ([]*api.Group, string, error)); ok {
		return rf(ctx, name, langTag, members, open, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *int, *bool, int, string) []*api.Group); ok {
		r0 = rf(ctx, name, langTag, members, open, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *int, *bool, int, string) string); ok {
		r1 = rf(ctx, name, langTag, members, open, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, *int, *bool, int, string) error); ok {
		r2 = rf(ctx, name, langTag, members, open, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NakamaModule_GroupsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupsList'
type NakamaModule_GroupsList_Call struct {
	*mock.Call
}

// GroupsList is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - langTag string
//   - members *int
//   - open *bool
//   - limit int
//   - cursor string
func (_e *NakamaModule_Expecter) GroupsList(ctx interface{}, name interface{}, langTag interface{}, members interface{}, open interface{}, limit interface{}, cursor interface{}) *NakamaModule_GroupsList_Call {
	return &NakamaModule_GroupsList_Call{Call: _e.mock.On("GroupsList", ctx, name, langTag, members, open, limit, cursor)}
}

func (_c *NakamaModule_GroupsList_Call) Run(run func(ctx context.Context, name string, langTag string, members *int, open *bool, limit int, cursor string)) *NakamaModule_GroupsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*int), args[4].(*bool), args[5].(int), args[6].(string))
	})
	return _c
}

func (_c *NakamaModule_GroupsList_Call) Return(_a0 []*api.Group, _a1 string, _a2 error) *NakamaModule_GroupsList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NakamaModule_GroupsList_Call) RunAndReturn(run func(context.Context, string, string, *int, *bool, int, string) ([]*api.Group, string, error)) *NakamaModule_GroupsList_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardCreate provides a mock function with given fields: ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata
func (_m *NakamaModule) LeaderboardCreate(ctx context.Context, id string, authoritative bool, sortOrder string, operator string, resetSchedule string, metadata map[string]interface{}) error {
	ret := _m.Called(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, string, string, map[string]interface{}) error); ok {
		r0 = rf(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LeaderboardCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardCreate'
type NakamaModule_LeaderboardCreate_Call struct {
	*mock.Call
}

// LeaderboardCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - authoritative bool
//   - sortOrder string
//   - operator string
//   - resetSchedule string
//   - metadata map[string]interface{}
func (_e *NakamaModule_Expecter) LeaderboardCreate(ctx interface{}, id interface{}, authoritative interface{}, sortOrder interface{}, operator interface{}, resetSchedule interface{}, metadata interface{}) *NakamaModule_LeaderboardCreate_Call {
	return &NakamaModule_LeaderboardCreate_Call{Call: _e.mock.On("LeaderboardCreate", ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata)}
}

func (_c *NakamaModule_LeaderboardCreate_Call) Run(run func(ctx context.Context, id string, authoritative bool, sortOrder string, operator string, resetSchedule string, metadata map[string]interface{})) *NakamaModule_LeaderboardCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool), args[3].(string), args[4].(string), args[5].(string), args[6].(map[string]interface{}))
	})
	return _c
}

func (_c *NakamaModule_LeaderboardCreate_Call) Return(_a0 error) *NakamaModule_LeaderboardCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LeaderboardCreate_Call) RunAndReturn(run func(context.Context, string, bool, string, string, string, map[string]interface{}) error) *NakamaModule_LeaderboardCreate_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardDelete provides a mock function with given fields: ctx, id
func (_m *NakamaModule) LeaderboardDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LeaderboardDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardDelete'
type NakamaModule_LeaderboardDelete_Call struct {
	*mock.Call
}

// LeaderboardDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *NakamaModule_Expecter) LeaderboardDelete(ctx interface{}, id interface{}) *NakamaModule_LeaderboardDelete_Call {
	return &NakamaModule_LeaderboardDelete_Call{Call: _e.mock.On("LeaderboardDelete", ctx, id)}
}

func (_c *NakamaModule_LeaderboardDelete_Call) Run(run func(ctx context.Context, id string)) *NakamaModule_LeaderboardDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *NakamaModule_LeaderboardDelete_Call) Return(_a0 error) *NakamaModule_LeaderboardDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LeaderboardDelete_Call) RunAndReturn(run func(context.Context, string) error) *NakamaModule_LeaderboardDelete_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardList provides a mock function with given fields: limit, cursor
func (_m *NakamaModule) LeaderboardList(limit int, cursor string) (*api.LeaderboardList, error) {
	ret := _m.Called(limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardList")
	}

	var r0 *api.LeaderboardList
	var r1 error
	if rf, ok := ret.Get(0).(func(int, string) (*api.LeaderboardList, error)); ok {
		return rf(limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(int, string) *api.LeaderboardList); ok {
		r0 = rf(limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardList)
		}
	}

	if rf, ok := ret.Get(1).(func(int, string) error); ok {
		r1 = rf(limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_LeaderboardList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardList'
type NakamaModule_LeaderboardList_Call struct {
	*mock.Call
}

// LeaderboardList is a helper method to define mock.On call
//   - limit int
//   - cursor string
func (_e *NakamaModule_Expecter) LeaderboardList(limit interface{}, cursor interface{}) *NakamaModule_LeaderboardList_Call {
	return &NakamaModule_LeaderboardList_Call{Call: _e.mock.On("LeaderboardList", limit, cursor)}
}

func (_c *NakamaModule_LeaderboardList_Call) Run(run func(limit int, cursor string)) *NakamaModule_LeaderboardList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(string))
	})
	return _c
}

func (_c *NakamaModule_LeaderboardList_Call) Return(_a0 *api.LeaderboardList, _a1 error) *NakamaModule_LeaderboardList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_LeaderboardList_Call) RunAndReturn(run func(int, string) (*api.LeaderboardList, error)) *NakamaModule_LeaderboardList_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRecordDelete provides a mock function with given fields: ctx, id, ownerID
func (_m *NakamaModule) LeaderboardRecordDelete(ctx context.Context, id string, ownerID string) error {
	ret := _m.Called(ctx, id, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRecordDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, id, ownerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LeaderboardRecordDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRecordDelete'
type NakamaModule_LeaderboardRecordDelete_Call struct {
	*mock.Call
}

// LeaderboardRecordDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
func (_e *NakamaModule_Expecter) LeaderboardRecordDelete(ctx interface{}, id interface{}, ownerID interface{}) *NakamaModule_LeaderboardRecordDelete_Call {
	return &NakamaModule_LeaderboardRecordDelete_Call{Call: _e.mock.On("LeaderboardRecordDelete", ctx, id, ownerID)}
}

func (_c *NakamaModule_LeaderboardRecordDelete_Call) Run(run func(ctx context.Context, id string, ownerID string)) *NakamaModule_LeaderboardRecordDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_LeaderboardRecordDelete_Call) Return(_a0 error) *NakamaModule_LeaderboardRecordDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LeaderboardRecordDelete_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_LeaderboardRecordDelete_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRecordWrite provides a mock function with given fields: ctx, id, ownerID, username, score, subscore, metadata, overrideOperator
func (_m *NakamaModule) LeaderboardRecordWrite(ctx context.Context, id string, ownerID string, username string, score int64, subscore int64, metadata map[string]interface{}, overrideOperator *int) (*api.LeaderboardRecord, error) {
	ret := _m.Called(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRecordWrite")
	}

	var r0 *api.LeaderboardRecord
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) (*api.LeaderboardRecord, error)); ok {
		return rf(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) *api.LeaderboardRecord); ok {
		r0 = rf(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) error); ok {
		r1 = rf(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_LeaderboardRecordWrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRecordWrite'
type NakamaModule_LeaderboardRecordWrite_Call struct {
	*mock.Call
}

// LeaderboardRecordWrite is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - username string
//   - score int64
//   - subscore int64
//   - metadata map[string]interface{}
//   - overrideOperator *int
func (_e *NakamaModule_Expecter) LeaderboardRecordWrite(ctx interface{}, id interface{}, ownerID interface{}, username interface{}, score interface{}, subscore interface{}, metadata interface{}, overrideOperator interface{}) *NakamaModule_LeaderboardRecordWrite_Call {
	return &NakamaModule_LeaderboardRecordWrite_Call{Call: _e.mock.On("LeaderboardRecordWrite", ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)}
}

func (_c *NakamaModule_LeaderboardRecordWrite_Call) Run(run func(ctx context.Context, id string, ownerID string, username string, score int64, subscore int64, metadata map[string]interface{}, overrideOperator *int)) *NakamaModule_LeaderboardRecordWrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64), args[5].(int64), args[6].(map[string]interface{}), args[7].(*int))
	})
	return _c
}

func (_c *NakamaModule_LeaderboardRecordWrite_Call) Return(_a0 *api.LeaderboardRecord, _a1 error) *NakamaModule_LeaderboardRecordWrite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_LeaderboardRecordWrite_Call) RunAndReturn(run func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) (*api.LeaderboardRecord, error)) *NakamaModule_LeaderboardRecordWrite_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRecordsHaystack provides a mock function with given fields: ctx, id, ownerID, limit, cursor, expiry
func (_m *NakamaModule) LeaderboardRecordsHaystack(ctx context.Context, id string, ownerID string, limit int, cursor string, expiry int64) (*api.LeaderboardRecordList, error) {
	ret := _m.Called(ctx, id, ownerID, limit, cursor, expiry)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRecordsHaystack")
	}

	var r0 *api.LeaderboardRecordList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) (*api.LeaderboardRecordList, error)); ok {
		return rf(ctx, id, ownerID, limit, cursor, expiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) *api.LeaderboardRecordList); ok {
		r0 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardRecordList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int, string, int64) error); ok {
		r1 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_LeaderboardRecordsHaystack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRecordsHaystack'
type NakamaModule_LeaderboardRecordsHaystack_Call struct {
	*mock.Call
}

// LeaderboardRecordsHaystack is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - limit int
//   - cursor string
//   - expiry int64
func (_e *NakamaModule_Expecter) LeaderboardRecordsHaystack(ctx interface{}, id interface{}, ownerID interface{}, limit interface{}, cursor interface{}, expiry interface{}) *NakamaModule_LeaderboardRecordsHaystack_Call {
	return &NakamaModule_LeaderboardRecordsHaystack_Call{Call: _e.mock.On("LeaderboardRecordsHaystack", ctx, id, ownerID, limit, cursor, expiry)}
}

func (_c *NakamaModule_LeaderboardRecordsHaystack_Call) Run(run func(ctx context.Context, id string, ownerID string, limit int, cursor string, expiry int64)) *NakamaModule_LeaderboardRecordsHaystack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(string), args[5].(int64))
	})
	return _c
}

func (_c *NakamaModule_LeaderboardRecordsHaystack_Call) Return(_a0 *api.LeaderboardRecordList, _a1 error) *NakamaModule_LeaderboardRecordsHaystack_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_LeaderboardRecordsHaystack_Call) RunAndReturn(run func(context.Context, string, string, int, string, int64) (*api.LeaderboardRecordList, error)) *NakamaModule_LeaderboardRecordsHaystack_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRecordsList provides a mock function with given fields: ctx, id, ownerIDs, limit, cursor, expiry
func (_m *NakamaModule) LeaderboardRecordsList(ctx context.Context, id string, ownerIDs []string, limit int, cursor string, expiry int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error) {
	ret := _m.Called(ctx, id, ownerIDs, limit, cursor, expiry)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRecordsList")
	}

	var r0 []*api.LeaderboardRecord
	var r1 []*api.LeaderboardRecord
	var r2 string
	var r3 string
	var r4 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error)); ok {
		return rf(ctx, id, ownerIDs, limit, cursor, expiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r0 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r1 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, []string, int, string, int64) string); ok {
		r2 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, []string, int, string, int64) string); ok {
		r3 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		r3 = ret.Get(3).(string)
	}

	if rf, ok := ret.Get(4).(func(context.Context, string, []string, int, string, int64) error); ok {
		r4 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// NakamaModule_LeaderboardRecordsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRecordsList'
type NakamaModule_LeaderboardRecordsList_Call struct {
	*mock.Call
}

// LeaderboardRecordsList is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerIDs []string
//   - limit int
//   - cursor string
//   - expiry int64
func (_e *NakamaModule_Expecter) LeaderboardRecordsList(ctx interface{}, id interface{}, ownerIDs interface{}, limit interface{}, cursor interface{}, expiry interface{}) *NakamaModule_LeaderboardRecordsList_Call {
	return &NakamaModule_LeaderboardRecordsList_Call{Call: _e.mock.On("LeaderboardRecordsList", ctx, id, ownerIDs, limit, cursor, expiry)}
}

func (_c *NakamaModule_LeaderboardRecordsList_Call) Run(run func(ctx context.Context, id string, ownerIDs []string, limit int, cursor string, expiry int64)) *NakamaModule_LeaderboardRecordsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(int), args[4].(string), args[5].(int64))
	})
	return _c
}

func (_c *NakamaModule_LeaderboardRecordsList_Call) Return(records []*api.LeaderboardRecord, ownerRecords []*api.LeaderboardRecord, nextCursor string, prevCursor string, err error) *NakamaModule_LeaderboardRecordsList_Call {
	_c.Call.Return(records, ownerRecords, nextCursor, prevCursor, err)
	return _c
}

func (_c *NakamaModule_LeaderboardRecordsList_Call) RunAndReturn(run func(context.Context, string, []string, int, string, int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error)) *NakamaModule_LeaderboardRecordsList_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRecordsListCursorFromRank provides a mock function with given fields: id, rank, overrideExpiry
func (_m *NakamaModule) LeaderboardRecordsListCursorFromRank(id string, rank int64, overrideExpiry int64) (string, error) {
	ret := _m.Called(id, rank, overrideExpiry)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRecordsListCursorFromRank")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int64, int64) (string, error)); ok {
		return rf(id, rank, overrideExpiry)
	}
	if rf, ok := ret.Get(0).(func(string, int64, int64) string); ok {
		r0 = rf(id, rank, overrideExpiry)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, int64, int64) error); ok {
		r1 = rf(id, rank, overrideExpiry)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_LeaderboardRecordsListCursorFromRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRecordsListCursorFromRank'
type NakamaModule_LeaderboardRecordsListCursorFromRank_Call struct {
	*mock.Call
}

// LeaderboardRecordsListCursorFromRank is a helper method to define mock.On call
//   - id string
//   - rank int64
//   - overrideExpiry int64
func (_e *NakamaModule_Expecter) LeaderboardRecordsListCursorFromRank(id interface{}, rank interface{}, overrideExpiry interface{}) *NakamaModule_LeaderboardRecordsListCursorFromRank_Call {
	return &NakamaModule_LeaderboardRecordsListCursorFromRank_Call{Call: _e.mock.On("LeaderboardRecordsListCursorFromRank", id, rank, overrideExpiry)}
}

func (_c *NakamaModule_LeaderboardRecordsListCursorFromRank_Call) Run(run func(id string, rank int64, overrideExpiry int64)) *NakamaModule_LeaderboardRecordsListCursorFromRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *NakamaModule_LeaderboardRecordsListCursorFromRank_Call) Return(_a0 string, _a1 error) *NakamaModule_LeaderboardRecordsListCursorFromRank_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_LeaderboardRecordsListCursorFromRank_Call) RunAndReturn(run func(string, int64, int64) (string, error)) *NakamaModule_LeaderboardRecordsListCursorFromRank_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardsGetId provides a mock function with given fields: ctx, ids
func (_m *NakamaModule) LeaderboardsGetId(ctx context.Context, ids []string) ([]*api.Leaderboard, error) {
	ret := _m.Called(ctx, ids)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardsGetId")
	}

	var r0 []*api.Leaderboard
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Leaderboard, error)); ok {
		return rf(ctx, ids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Leaderboard); ok {
		r0 = rf(ctx, ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Leaderboard)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_LeaderboardsGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardsGetId'
type NakamaModule_LeaderboardsGetId_Call struct {
	*mock.Call
}

// LeaderboardsGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - ids []string
func (_e *NakamaModule_Expecter) LeaderboardsGetId(ctx interface{}, ids interface{}) *NakamaModule_LeaderboardsGetId_Call {
	return &NakamaModule_LeaderboardsGetId_Call{Call: _e.mock.On("LeaderboardsGetId", ctx, ids)}
}

func (_c *NakamaModule_LeaderboardsGetId_Call) Run(run func(ctx context.Context, ids []string)) *NakamaModule_LeaderboardsGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *NakamaModule_LeaderboardsGetId_Call) Return(_a0 []*api.Leaderboard, _a1 error) *NakamaModule_LeaderboardsGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_LeaderboardsGetId_Call) RunAndReturn(run func(context.Context, []string) ([]*api.Leaderboard, error)) *NakamaModule_LeaderboardsGetId_Call {
	_c.Call.Return(run)
	return _c
}

// LinkApple provides a mock function with given fields: ctx, userID, token
func (_m *NakamaModule) LinkApple(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for LinkApple")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LinkApple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkApple'
type NakamaModule_LinkApple_Call struct {
	*mock.Call
}

// LinkApple is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *NakamaModule_Expecter) LinkApple(ctx interface{}, userID interface{}, token interface{}) *NakamaModule_LinkApple_Call {
	return &NakamaModule_LinkApple_Call{Call: _e.mock.On("LinkApple", ctx, userID, token)}
}

func (_c *NakamaModule_LinkApple_Call) Run(run func(ctx context.Context, userID string, token string)) *NakamaModule_LinkApple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_LinkApple_Call) Return(_a0 error) *NakamaModule_LinkApple_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LinkApple_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_LinkApple_Call {
	_c.Call.Return(run)
	return _c
}

// LinkCustom provides a mock function with given fields: ctx, userID, customID
func (_m *NakamaModule) LinkCustom(ctx context.Context, userID string, customID string) error {
	ret := _m.Called(ctx, userID, customID)

	if len(ret) == 0 {
		panic("no return value specified for LinkCustom")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, customID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LinkCustom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkCustom'
type NakamaModule_LinkCustom_Call struct {
	*mock.Call
}

// LinkCustom is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - customID string
func (_e *NakamaModule_Expecter) LinkCustom(ctx interface{}, userID interface{}, customID interface{}) *NakamaModule_LinkCustom_Call {
	return &NakamaModule_LinkCustom_Call{Call: _e.mock.On("LinkCustom", ctx, userID, customID)}
}

func (_c *NakamaModule_LinkCustom_Call) Run(run func(ctx context.Context, userID string, customID string)) *NakamaModule_LinkCustom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_LinkCustom_Call) Return(_a0 error) *NakamaModule_LinkCustom_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LinkCustom_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_LinkCustom_Call {
	_c.Call.Return(run)
	return _c
}

// LinkDevice provides a mock function with given fields: ctx, userID, deviceID
func (_m *NakamaModule) LinkDevice(ctx context.Context, userID string, deviceID string) error {
	ret := _m.Called(ctx, userID, deviceID)

	if len(ret) == 0 {
		panic("no return value specified for LinkDevice")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, deviceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LinkDevice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkDevice'
type NakamaModule_LinkDevice_Call struct {
	*mock.Call
}

// LinkDevice is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - deviceID string
func (_e *NakamaModule_Expecter) LinkDevice(ctx interface{}, userID interface{}, deviceID interface{}) *NakamaModule_LinkDevice_Call {
	return &NakamaModule_LinkDevice_Call{Call: _e.mock.On("LinkDevice", ctx, userID, deviceID)}
}

func (_c *NakamaModule_LinkDevice_Call) Run(run func(ctx context.Context, userID string, deviceID string)) *NakamaModule_LinkDevice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_LinkDevice_Call) Return(_a0 error) *NakamaModule_LinkDevice_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LinkDevice_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_LinkDevice_Call {
	_c.Call.Return(run)
	return _c
}

// LinkEmail provides a mock function with given fields: ctx, userID, email, password
func (_m *NakamaModule) LinkEmail(ctx context.Context, userID string, email string, password string) error {
	ret := _m.Called(ctx, userID, email, password)

	if len(ret) == 0 {
		panic("no return value specified for LinkEmail")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, userID, email, password)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LinkEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkEmail'
type NakamaModule_LinkEmail_Call struct {
	*mock.Call
}

// LinkEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - email string
//   - password string
func (_e *NakamaModule_Expecter) LinkEmail(ctx interface{}, userID interface{}, email interface{}, password interface{}) *NakamaModule_LinkEmail_Call {
	return &NakamaModule_LinkEmail_Call{Call: _e.mock.On("LinkEmail", ctx, userID, email, password)}
}

func (_c *NakamaModule_LinkEmail_Call) Run(run func(ctx context.Context, userID string, email string, password string)) *NakamaModule_LinkEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *NakamaModule_LinkEmail_Call) Return(_a0 error) *NakamaModule_LinkEmail_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LinkEmail_Call) RunAndReturn(run func(context.Context, string, string, string) error) *NakamaModule_LinkEmail_Call {
	_c.Call.Return(run)
	return _c
}

// LinkFacebook provides a mock function with given fields: ctx, userID, username, token, importFriends
func (_m *NakamaModule) LinkFacebook(ctx context.Context, userID string, username string, token string, importFriends bool) error {
	ret := _m.Called(ctx, userID, username, token, importFriends)

	if len(ret) == 0 {
		panic("no return value specified for LinkFacebook")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) error); ok {
		r0 = rf(ctx, userID, username, token, importFriends)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LinkFacebook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkFacebook'
type NakamaModule_LinkFacebook_Call struct {
	*mock.Call
}

// LinkFacebook is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - token string
//   - importFriends bool
func (_e *NakamaModule_Expecter) LinkFacebook(ctx interface{}, userID interface{}, username interface{}, token interface{}, importFriends interface{}) *NakamaModule_LinkFacebook_Call {
	return &NakamaModule_LinkFacebook_Call{Call: _e.mock.On("LinkFacebook", ctx, userID, username, token, importFriends)}
}

func (_c *NakamaModule_LinkFacebook_Call) Run(run func(ctx context.Context, userID string, username string, token string, importFriends bool)) *NakamaModule_LinkFacebook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(bool))
	})
	return _c
}

func (_c *NakamaModule_LinkFacebook_Call) Return(_a0 error) *NakamaModule_LinkFacebook_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LinkFacebook_Call) RunAndReturn(run func(context.Context, string, string, string, bool) error) *NakamaModule_LinkFacebook_Call {
	_c.Call.Return(run)
	return _c
}

// LinkFacebookInstantGame provides a mock function with given fields: ctx, userID, signedPlayerInfo
func (_m *NakamaModule) LinkFacebookInstantGame(ctx context.Context, userID string, signedPlayerInfo string) error {
	ret := _m.Called(ctx, userID, signedPlayerInfo)

	if len(ret) == 0 {
		panic("no return value specified for LinkFacebookInstantGame")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, signedPlayerInfo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LinkFacebookInstantGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkFacebookInstantGame'
type NakamaModule_LinkFacebookInstantGame_Call struct {
	*mock.Call
}

// LinkFacebookInstantGame is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - signedPlayerInfo string
func (_e *NakamaModule_Expecter) LinkFacebookInstantGame(ctx interface{}, userID interface{}, signedPlayerInfo interface{}) *NakamaModule_LinkFacebookInstantGame_Call {
	return &NakamaModule_LinkFacebookInstantGame_Call{Call: _e.mock.On("LinkFacebookInstantGame", ctx, userID, signedPlayerInfo)}
}

func (_c *NakamaModule_LinkFacebookInstantGame_Call) Run(run func(ctx context.Context, userID string, signedPlayerInfo string)) *NakamaModule_LinkFacebookInstantGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_LinkFacebookInstantGame_Call) Return(_a0 error) *NakamaModule_LinkFacebookInstantGame_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LinkFacebookInstantGame_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_LinkFacebookInstantGame_Call {
	_c.Call.Return(run)
	return _c
}

// LinkGameCenter provides a mock function with given fields: ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl
func (_m *NakamaModule) LinkGameCenter(ctx context.Context, userID string, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string) error {
	ret := _m.Called(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)

	if len(ret) == 0 {
		panic("no return value specified for LinkGameCenter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, string, string, string) error); ok {
		r0 = rf(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LinkGameCenter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkGameCenter'
type NakamaModule_LinkGameCenter_Call struct {
	*mock.Call
}

// LinkGameCenter is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - playerID string
//   - bundleID string
//   - timestamp int64
//   - salt string
//   - signature string
//   - publicKeyUrl string
func (_e *NakamaModule_Expecter) LinkGameCenter(ctx interface{}, userID interface{}, playerID interface{}, bundleID interface{}, timestamp interface{}, salt interface{}, signature interface{}, publicKeyUrl interface{}) *NakamaModule_LinkGameCenter_Call {
	return &NakamaModule_LinkGameCenter_Call{Call: _e.mock.On("LinkGameCenter", ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)}
}

func (_c *NakamaModule_LinkGameCenter_Call) Run(run func(ctx context.Context, userID string, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string)) *NakamaModule_LinkGameCenter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64), args[5].(string), args[6].(string), args[7].(string))
	})
	return _c
}

func (_c *NakamaModule_LinkGameCenter_Call) Return(_a0 error) *NakamaModule_LinkGameCenter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LinkGameCenter_Call) RunAndReturn(run func(context.Context, string, string, string, int64, string, string, string) error) *NakamaModule_LinkGameCenter_Call {
	_c.Call.Return(run)
	return _c
}

// LinkGoogle provides a mock function with given fields: ctx, userID, token
func (_m *NakamaModule) LinkGoogle(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for LinkGoogle")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LinkGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkGoogle'
type NakamaModule_LinkGoogle_Call struct {
	*mock.Call
}

// LinkGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *NakamaModule_Expecter) LinkGoogle(ctx interface{}, userID interface{}, token interface{}) *NakamaModule_LinkGoogle_Call {
	return &NakamaModule_LinkGoogle_Call{Call: _e.mock.On("LinkGoogle", ctx, userID, token)}
}

func (_c *NakamaModule_LinkGoogle_Call) Run(run func(ctx context.Context, userID string, token string)) *NakamaModule_LinkGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_LinkGoogle_Call) Return(_a0 error) *NakamaModule_LinkGoogle_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LinkGoogle_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_LinkGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSteam provides a mock function with given fields: ctx, userID, username, token, importFriends
func (_m *NakamaModule) LinkSteam(ctx context.Context, userID string, username string, token string, importFriends bool) error {
	ret := _m.Called(ctx, userID, username, token, importFriends)

	if len(ret) == 0 {
		panic("no return value specified for LinkSteam")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) error); ok {
		r0 = rf(ctx, userID, username, token, importFriends)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_LinkSteam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSteam'
type NakamaModule_LinkSteam_Call struct {
	*mock.Call
}

// LinkSteam is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - token string
//   - importFriends bool
func (_e *NakamaModule_Expecter) LinkSteam(ctx interface{}, userID interface{}, username interface{}, token interface{}, importFriends interface{}) *NakamaModule_LinkSteam_Call {
	return &NakamaModule_LinkSteam_Call{Call: _e.mock.On("LinkSteam", ctx, userID, username, token, importFriends)}
}

func (_c *NakamaModule_LinkSteam_Call) Run(run func(ctx context.Context, userID string, username string, token string, importFriends bool)) *NakamaModule_LinkSteam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(bool))
	})
	return _c
}

func (_c *NakamaModule_LinkSteam_Call) Return(_a0 error) *NakamaModule_LinkSteam_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_LinkSteam_Call) RunAndReturn(run func(context.Context, string, string, string, bool) error) *NakamaModule_LinkSteam_Call {
	_c.Call.Return(run)
	return _c
}

// MatchCreate provides a mock function with given fields: ctx, module, params
func (_m *NakamaModule) MatchCreate(ctx context.Context, module string, params map[string]interface{}) (string, error) {
	ret := _m.Called(ctx, module, params)

	if len(ret) == 0 {
		panic("no return value specified for MatchCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) (string, error)); ok {
		return rf(ctx, module, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) string); ok {
		r0 = rf(ctx, module, params)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]interface{}) error); ok {
		r1 = rf(ctx, module, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_MatchCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchCreate'
type NakamaModule_MatchCreate_Call struct {
	*mock.Call
}

// MatchCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - module string
//   - params map[string]interface{}
func (_e *NakamaModule_Expecter) MatchCreate(ctx interface{}, module interface{}, params interface{}) *NakamaModule_MatchCreate_Call {
	return &NakamaModule_MatchCreate_Call{Call: _e.mock.On("MatchCreate", ctx, module, params)}
}

func (_c *NakamaModule_MatchCreate_Call) Run(run func(ctx context.Context, module string, params map[string]interface{})) *NakamaModule_MatchCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]interface{}))
	})
	return _c
}

func (_c *NakamaModule_MatchCreate_Call) Return(_a0 string, _a1 error) *NakamaModule_MatchCreate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_MatchCreate_Call) RunAndReturn(run func(context.Context, string, map[string]interface{}) (string, error)) *NakamaModule_MatchCreate_Call {
	_c.Call.Return(run)
	return _c
}

// MatchGet provides a mock function with given fields: ctx, id
func (_m *NakamaModule) MatchGet(ctx context.Context, id string) (*api.Match, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for MatchGet")
	}

	var r0 *api.Match
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*api.Match, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.Match); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Match)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_MatchGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchGet'
type NakamaModule_MatchGet_Call struct {
	*mock.Call
}

// MatchGet is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *NakamaModule_Expecter) MatchGet(ctx interface{}, id interface{}) *NakamaModule_MatchGet_Call {
	return &NakamaModule_MatchGet_Call{Call: _e.mock.On("MatchGet", ctx, id)}
}

func (_c *NakamaModule_MatchGet_Call) Run(run func(ctx context.Context, id string)) *NakamaModule_MatchGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *NakamaModule_MatchGet_Call) Return(_a0 *api.Match, _a1 error) *NakamaModule_MatchGet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_MatchGet_Call) RunAndReturn(run func(context.Context, string) (*api.Match, error)) *NakamaModule_MatchGet_Call {
	_c.Call.Return(run)
	return _c
}

// MatchList provides a mock function with given fields: ctx, limit, authoritative, label, minSize, maxSize, query
func (_m *NakamaModule) MatchList(ctx context.Context, limit int, authoritative bool, label string, minSize *int, maxSize *int, query string) ([]*api.Match, error) {
	ret := _m.Called(ctx, limit, authoritative, label, minSize, maxSize, query)

	if len(ret) == 0 {
		panic("no return value specified for MatchList")
	}

	var r0 []*api.Match
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, bool, string, *int, *int, string) ([]*api.Match, error)); ok {
		return rf(ctx, limit, authoritative, label, minSize, maxSize, query)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, bool, string, *int, *int, string) []*api.Match); ok {
		r0 = rf(ctx, limit, authoritative, label, minSize, maxSize, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Match)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, bool, string, *int, *int, string) error); ok {
		r1 = rf(ctx, limit, authoritative, label, minSize, maxSize, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_MatchList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchList'
type NakamaModule_MatchList_Call struct {
	*mock.Call
}

// MatchList is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - authoritative bool
//   - label string
//   - minSize *int
//   - maxSize *int
//   - query string
func (_e *NakamaModule_Expecter) MatchList(ctx interface{}, limit interface{}, authoritative interface{}, label interface{}, minSize interface{}, maxSize interface{}, query interface{}) *NakamaModule_MatchList_Call {
	return &NakamaModule_MatchList_Call{Call: _e.mock.On("MatchList", ctx, limit, authoritative, label, minSize, maxSize, query)}
}

func (_c *NakamaModule_MatchList_Call) Run(run func(ctx context.Context, limit int, authoritative bool, label string, minSize *int, maxSize *int, query string)) *NakamaModule_MatchList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(bool), args[3].(string), args[4].(*int), args[5].(*int), args[6].(string))
	})
	return _c
}

func (_c *NakamaModule_MatchList_Call) Return(_a0 []*api.Match, _a1 error) *NakamaModule_MatchList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_MatchList_Call) RunAndReturn(run func(context.Context, int, bool, string, *int, *int, string) ([]*api.Match, error)) *NakamaModule_MatchList_Call {
	_c.Call.Return(run)
	return _c
}

// MatchSignal provides a mock function with given fields: ctx, id, data
func (_m *NakamaModule) MatchSignal(ctx context.Context, id string, data string) (string, error) {
	ret := _m.Called(ctx, id, data)

	if len(ret) == 0 {
		panic("no return value specified for MatchSignal")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, id, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, id, data)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, id, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_MatchSignal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchSignal'
type NakamaModule_MatchSignal_Call struct {
	*mock.Call
}

// MatchSignal is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - data string
func (_e *NakamaModule_Expecter) MatchSignal(ctx interface{}, id interface{}, data interface{}) *NakamaModule_MatchSignal_Call {
	return &NakamaModule_MatchSignal_Call{Call: _e.mock.On("MatchSignal", ctx, id, data)}
}

func (_c *NakamaModule_MatchSignal_Call) Run(run func(ctx context.Context, id string, data string)) *NakamaModule_MatchSignal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_MatchSignal_Call) Return(_a0 string, _a1 error) *NakamaModule_MatchSignal_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_MatchSignal_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *NakamaModule_MatchSignal_Call {
	_c.Call.Return(run)
	return _c
}

// MetricsCounterAdd provides a mock function with given fields: name, tags, delta
func (_m *NakamaModule) MetricsCounterAdd(name string, tags map[string]string, delta int64) {
	_m.Called(name, tags, delta)
}

// NakamaModule_MetricsCounterAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MetricsCounterAdd'
type NakamaModule_MetricsCounterAdd_Call struct {
	*mock.Call
}

// MetricsCounterAdd is a helper method to define mock.On call
//   - name string
//   - tags map[string]string
//   - delta int64
func (_e *NakamaModule_Expecter) MetricsCounterAdd(name interface{}, tags interface{}, delta interface{}) *NakamaModule_MetricsCounterAdd_Call {
	return &NakamaModule_MetricsCounterAdd_Call{Call: _e.mock.On("MetricsCounterAdd", name, tags, delta)}
}

func (_c *NakamaModule_MetricsCounterAdd_Call) Run(run func(name string, tags map[string]string, delta int64)) *NakamaModule_MetricsCounterAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]string), args[2].(int64))
	})
	return _c
}

func (_c *NakamaModule_MetricsCounterAdd_Call) Return() *NakamaModule_MetricsCounterAdd_Call {
	_c.Call.Return()
	return _c
}

func (_c *NakamaModule_MetricsCounterAdd_Call) RunAndReturn(run func(string, map[string]string, int64)) *NakamaModule_MetricsCounterAdd_Call {
	_c.Call.Return(run)
	return _c
}

// MetricsGaugeSet provides a mock function with given fields: name, tags, value
func (_m *NakamaModule) MetricsGaugeSet(name string, tags map[string]string, value float64) {
	_m.Called(name, tags, value)
}

// NakamaModule_MetricsGaugeSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MetricsGaugeSet'
type NakamaModule_MetricsGaugeSet_Call struct {
	*mock.Call
}

// MetricsGaugeSet is a helper method to define mock.On call
//   - name string
//   - tags map[string]string
//   - value float64
func (_e *NakamaModule_Expecter) MetricsGaugeSet(name interface{}, tags interface{}, value interface{}) *NakamaModule_MetricsGaugeSet_Call {
	return &NakamaModule_MetricsGaugeSet_Call{Call: _e.mock.On("MetricsGaugeSet", name, tags, value)}
}

func (_c *NakamaModule_MetricsGaugeSet_Call) Run(run func(name string, tags map[string]string, value float64)) *NakamaModule_MetricsGaugeSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]string), args[2].(float64))
	})
	return _c
}

func (_c *NakamaModule_MetricsGaugeSet_Call) Return() *NakamaModule_MetricsGaugeSet_Call {
	_c.Call.Return()
	return _c
}

func (_c *NakamaModule_MetricsGaugeSet_Call) RunAndReturn(run func(string, map[string]string, float64)) *NakamaModule_MetricsGaugeSet_Call {
	_c.Call.Return(run)
	return _c
}

// MetricsTimerRecord provides a mock function with given fields: name, tags, value
func (_m *NakamaModule) MetricsTimerRecord(name string, tags map[string]string, value time.Duration) {
	_m.Called(name, tags, value)
}

// NakamaModule_MetricsTimerRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MetricsTimerRecord'
type NakamaModule_MetricsTimerRecord_Call struct {
	*mock.Call
}

// MetricsTimerRecord is a helper method to define mock.On call
//   - name string
//   - tags map[string]string
//   - value time.Duration
func (_e *NakamaModule_Expecter) MetricsTimerRecord(name interface{}, tags interface{}, value interface{}) *NakamaModule_MetricsTimerRecord_Call {
	return &NakamaModule_MetricsTimerRecord_Call{Call: _e.mock.On("MetricsTimerRecord", name, tags, value)}
}

func (_c *NakamaModule_MetricsTimerRecord_Call) Run(run func(name string, tags map[string]string, value time.Duration)) *NakamaModule_MetricsTimerRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]string), args[2].(time.Duration))
	})
	return _c
}

func (_c *NakamaModule_MetricsTimerRecord_Call) Return() *NakamaModule_MetricsTimerRecord_Call {
	_c.Call.Return()
	return _c
}

func (_c *NakamaModule_MetricsTimerRecord_Call) RunAndReturn(run func(string, map[string]string, time.Duration)) *NakamaModule_MetricsTimerRecord_Call {
	_c.Call.Return(run)
	return _c
}

// MultiUpdate provides a mock function with given fields: ctx, accountUpdates, storageWrites, walletUpdates, updateLedger
func (_m *NakamaModule) MultiUpdate(ctx context.Context, accountUpdates []*runtime.AccountUpdate, storageWrites []*runtime.StorageWrite, walletUpdates []*runtime.WalletUpdate, updateLedger bool) ([]*api.StorageObjectAck, []*runtime.WalletUpdateResult, error) {
	ret := _m.Called(ctx, accountUpdates, storageWrites, walletUpdates, updateLedger)

	if len(ret) == 0 {
		panic("no return value specified for MultiUpdate")
	}

	var r0 []*api.StorageObjectAck
	var r1 []*runtime.WalletUpdateResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.WalletUpdate, bool) ([]*api.StorageObjectAck, []*runtime.WalletUpdateResult, error)); ok {
		return rf(ctx, accountUpdates, storageWrites, walletUpdates, updateLedger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.WalletUpdate, bool) []*api.StorageObjectAck); ok {
		r0 = rf(ctx, accountUpdates, storageWrites, walletUpdates, updateLedger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObjectAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.WalletUpdate, bool) []*runtime.WalletUpdateResult); ok {
		r1 = rf(ctx, accountUpdates, storageWrites, walletUpdates, updateLedger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*runtime.WalletUpdateResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.WalletUpdate, bool) error); ok {
		r2 = rf(ctx, accountUpdates, storageWrites, walletUpdates, updateLedger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NakamaModule_MultiUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MultiUpdate'
type NakamaModule_MultiUpdate_Call struct {
	*mock.Call
}

// MultiUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - accountUpdates []*runtime.AccountUpdate
//   - storageWrites []*runtime.StorageWrite
//   - walletUpdates []*runtime.WalletUpdate
//   - updateLedger bool
func (_e *NakamaModule_Expecter) MultiUpdate(ctx interface{}, accountUpdates interface{}, storageWrites interface{}, walletUpdates interface{}, updateLedger interface{}) *NakamaModule_MultiUpdate_Call {
	return &NakamaModule_MultiUpdate_Call{Call: _e.mock.On("MultiUpdate", ctx, accountUpdates, storageWrites, walletUpdates, updateLedger)}
}

func (_c *NakamaModule_MultiUpdate_Call) Run(run func(ctx context.Context, accountUpdates []*runtime.AccountUpdate, storageWrites []*runtime.StorageWrite, walletUpdates []*runtime.WalletUpdate, updateLedger bool)) *NakamaModule_MultiUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.AccountUpdate), args[2].([]*runtime.StorageWrite), args[3].([]*runtime.WalletUpdate), args[4].(bool))
	})
	return _c
}

func (_c *NakamaModule_MultiUpdate_Call) Return(_a0 []*api.StorageObjectAck, _a1 []*runtime.WalletUpdateResult, _a2 error) *NakamaModule_MultiUpdate_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NakamaModule_MultiUpdate_Call) RunAndReturn(run func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.WalletUpdate, bool) ([]*api.StorageObjectAck, []*runtime.WalletUpdateResult, error)) *NakamaModule_MultiUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationSend provides a mock function with given fields: ctx, userID, subject, content, code, sender, persistent
func (_m *NakamaModule) NotificationSend(ctx context.Context, userID string, subject string, content map[string]interface{}, code int, sender string, persistent bool) error {
	ret := _m.Called(ctx, userID, subject, content, code, sender, persistent)

	if len(ret) == 0 {
		panic("no return value specified for NotificationSend")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, int, string, bool) error); ok {
		r0 = rf(ctx, userID, subject, content, code, sender, persistent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_NotificationSend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationSend'
type NakamaModule_NotificationSend_Call struct {
	*mock.Call
}

// NotificationSend is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - subject string
//   - content map[string]interface{}
//   - code int
//   - sender string
//   - persistent bool
func (_e *NakamaModule_Expecter) NotificationSend(ctx interface{}, userID interface{}, subject interface{}, content interface{}, code interface{}, sender interface{}, persistent interface{}) *NakamaModule_NotificationSend_Call {
	return &NakamaModule_NotificationSend_Call{Call: _e.mock.On("NotificationSend", ctx, userID, subject, content, code, sender, persistent)}
}

func (_c *NakamaModule_NotificationSend_Call) Run(run func(ctx context.Context, userID string, subject string, content map[string]interface{}, code int, sender string, persistent bool)) *NakamaModule_NotificationSend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string]interface{}), args[4].(int), args[5].(string), args[6].(bool))
	})
	return _c
}

func (_c *NakamaModule_NotificationSend_Call) Return(_a0 error) *NakamaModule_NotificationSend_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_NotificationSend_Call) RunAndReturn(run func(context.Context, string, string, map[string]interface{}, int, string, bool) error) *NakamaModule_NotificationSend_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationSendAll provides a mock function with given fields: ctx, subject, content, code, persistent
func (_m *NakamaModule) NotificationSendAll(ctx context.Context, subject string, content map[string]interface{}, code int, persistent bool) error {
	ret := _m.Called(ctx, subject, content, code, persistent)

	if len(ret) == 0 {
		panic("no return value specified for NotificationSendAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, int, bool) error); ok {
		r0 = rf(ctx, subject, content, code, persistent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_NotificationSendAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationSendAll'
type NakamaModule_NotificationSendAll_Call struct {
	*mock.Call
}

// NotificationSendAll is a helper method to define mock.On call
//   - ctx context.Context
//   - subject string
//   - content map[string]interface{}
//   - code int
//   - persistent bool
func (_e *NakamaModule_Expecter) NotificationSendAll(ctx interface{}, subject interface{}, content interface{}, code interface{}, persistent interface{}) *NakamaModule_NotificationSendAll_Call {
	return &NakamaModule_NotificationSendAll_Call{Call: _e.mock.On("NotificationSendAll", ctx, subject, content, code, persistent)}
}

func (_c *NakamaModule_NotificationSendAll_Call) Run(run func(ctx context.Context, subject string, content map[string]interface{}, code int, persistent bool)) *NakamaModule_NotificationSendAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]interface{}), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *NakamaModule_NotificationSendAll_Call) Return(_a0 error) *NakamaModule_NotificationSendAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_NotificationSendAll_Call) RunAndReturn(run func(context.Context, string, map[string]interface{}, int, bool) error) *NakamaModule_NotificationSendAll_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationsDelete provides a mock function with given fields: ctx, notifications
func (_m *NakamaModule) NotificationsDelete(ctx context.Context, notifications []*runtime.NotificationDelete) error {
	ret := _m.Called(ctx, notifications)

	if len(ret) == 0 {
		panic("no return value specified for NotificationsDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.NotificationDelete) error); ok {
		r0 = rf(ctx, notifications)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_NotificationsDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationsDelete'
type NakamaModule_NotificationsDelete_Call struct {
	*mock.Call
}

// NotificationsDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - notifications []*runtime.NotificationDelete
func (_e *NakamaModule_Expecter) NotificationsDelete(ctx interface{}, notifications interface{}) *NakamaModule_NotificationsDelete_Call {
	return &NakamaModule_NotificationsDelete_Call{Call: _e.mock.On("NotificationsDelete", ctx, notifications)}
}

func (_c *NakamaModule_NotificationsDelete_Call) Run(run func(ctx context.Context, notifications []*runtime.NotificationDelete)) *NakamaModule_NotificationsDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.NotificationDelete))
	})
	return _c
}

func (_c *NakamaModule_NotificationsDelete_Call) Return(_a0 error) *NakamaModule_NotificationsDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_NotificationsDelete_Call) RunAndReturn(run func(context.Context, []*runtime.NotificationDelete) error) *NakamaModule_NotificationsDelete_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationsSend provides a mock function with given fields: ctx, notifications
func (_m *NakamaModule) NotificationsSend(ctx context.Context, notifications []*runtime.NotificationSend) error {
	ret := _m.Called(ctx, notifications)

	if len(ret) == 0 {
		panic("no return value specified for NotificationsSend")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.NotificationSend) error); ok {
		r0 = rf(ctx, notifications)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_NotificationsSend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationsSend'
type NakamaModule_NotificationsSend_Call struct {
	*mock.Call
}

// NotificationsSend is a helper method to define mock.On call
//   - ctx context.Context
//   - notifications []*runtime.NotificationSend
func (_e *NakamaModule_Expecter) NotificationsSend(ctx interface{}, notifications interface{}) *NakamaModule_NotificationsSend_Call {
	return &NakamaModule_NotificationsSend_Call{Call: _e.mock.On("NotificationsSend", ctx, notifications)}
}

func (_c *NakamaModule_NotificationsSend_Call) Run(run func(ctx context.Context, notifications []*runtime.NotificationSend)) *NakamaModule_NotificationsSend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.NotificationSend))
	})
	return _c
}

func (_c *NakamaModule_NotificationsSend_Call) Return(_a0 error) *NakamaModule_NotificationsSend_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_NotificationsSend_Call) RunAndReturn(run func(context.Context, []*runtime.NotificationSend) error) *NakamaModule_NotificationsSend_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseGetByTransactionId provides a mock function with given fields: ctx, transactionID
func (_m *NakamaModule) PurchaseGetByTransactionId(ctx context.Context, transactionID string) (*api.ValidatedPurchase, error) {
	ret := _m.Called(ctx, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseGetByTransactionId")
	}

	var r0 *api.ValidatedPurchase
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*api.ValidatedPurchase, error)); ok {
		return rf(ctx, transactionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.ValidatedPurchase); ok {
		r0 = rf(ctx, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatedPurchase)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, transactionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_PurchaseGetByTransactionId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseGetByTransactionId'
type NakamaModule_PurchaseGetByTransactionId_Call struct {
	*mock.Call
}

// PurchaseGetByTransactionId is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionID string
func (_e *NakamaModule_Expecter) PurchaseGetByTransactionId(ctx interface{}, transactionID interface{}) *NakamaModule_PurchaseGetByTransactionId_Call {
	return &NakamaModule_PurchaseGetByTransactionId_Call{Call: _e.mock.On("PurchaseGetByTransactionId", ctx, transactionID)}
}

func (_c *NakamaModule_PurchaseGetByTransactionId_Call) Run(run func(ctx context.Context, transactionID string)) *NakamaModule_PurchaseGetByTransactionId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *NakamaModule_PurchaseGetByTransactionId_Call) Return(_a0 *api.ValidatedPurchase, _a1 error) *NakamaModule_PurchaseGetByTransactionId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_PurchaseGetByTransactionId_Call) RunAndReturn(run func(context.Context, string) (*api.ValidatedPurchase, error)) *NakamaModule_PurchaseGetByTransactionId_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseValidateApple provides a mock function with given fields: ctx, userID, receipt, persist, passwordOverride
func (_m *NakamaModule) PurchaseValidateApple(ctx context.Context, userID string, receipt string, persist bool, passwordOverride ...string) (*api.ValidatePurchaseResponse, error) {
	_va := make([]interface{}, len(passwordOverride))
	for _i := range passwordOverride {
		_va[_i] = passwordOverride[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseValidateApple")
	}

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, passwordOverride...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...string) error); ok {
		r1 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_PurchaseValidateApple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseValidateApple'
type NakamaModule_PurchaseValidateApple_Call struct {
	*mock.Call
}

// PurchaseValidateApple is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - receipt string
//   - persist bool
//   - passwordOverride ...string
func (_e *NakamaModule_Expecter) PurchaseValidateApple(ctx interface{}, userID interface{}, receipt interface{}, persist interface{}, passwordOverride ...interface{}) *NakamaModule_PurchaseValidateApple_Call {
	return &NakamaModule_PurchaseValidateApple_Call{Call: _e.mock.On("PurchaseValidateApple",
		append([]interface{}{ctx, userID, receipt, persist}, passwordOverride...)...)}
}

func (_c *NakamaModule_PurchaseValidateApple_Call) Run(run func(ctx context.Context, userID string, receipt string, persist bool, passwordOverride ...string)) *NakamaModule_PurchaseValidateApple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool), variadicArgs...)
	})
	return _c
}

func (_c *NakamaModule_PurchaseValidateApple_Call) Return(_a0 *api.ValidatePurchaseResponse, _a1 error) *NakamaModule_PurchaseValidateApple_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_PurchaseValidateApple_Call) RunAndReturn(run func(context.Context, string, string, bool, ...string) (*api.ValidatePurchaseResponse, error)) *NakamaModule_PurchaseValidateApple_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseValidateFacebookInstant provides a mock function with given fields: ctx, userID, signedRequest, persist
func (_m *NakamaModule) PurchaseValidateFacebookInstant(ctx context.Context, userID string, signedRequest string, persist bool) (*api.ValidatePurchaseResponse, error) {
	ret := _m.Called(ctx, userID, signedRequest, persist)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseValidateFacebookInstant")
	}

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, signedRequest, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, signedRequest, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) error); ok {
		r1 = rf(ctx, userID, signedRequest, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_PurchaseValidateFacebookInstant_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseValidateFacebookInstant'
type NakamaModule_PurchaseValidateFacebookInstant_Call struct {
	*mock.Call
}

// PurchaseValidateFacebookInstant is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - signedRequest string
//   - persist bool
func (_e *NakamaModule_Expecter) PurchaseValidateFacebookInstant(ctx interface{}, userID interface{}, signedRequest interface{}, persist interface{}) *NakamaModule_PurchaseValidateFacebookInstant_Call {
	return &NakamaModule_PurchaseValidateFacebookInstant_Call{Call: _e.mock.On("PurchaseValidateFacebookInstant", ctx, userID, signedRequest, persist)}
}

func (_c *NakamaModule_PurchaseValidateFacebookInstant_Call) Run(run func(ctx context.Context, userID string, signedRequest string, persist bool)) *NakamaModule_PurchaseValidateFacebookInstant_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *NakamaModule_PurchaseValidateFacebookInstant_Call) Return(_a0 *api.ValidatePurchaseResponse, _a1 error) *NakamaModule_PurchaseValidateFacebookInstant_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_PurchaseValidateFacebookInstant_Call) RunAndReturn(run func(context.Context, string, string, bool) (*api.ValidatePurchaseResponse, error)) *NakamaModule_PurchaseValidateFacebookInstant_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseValidateGoogle provides a mock function with given fields: ctx, userID, receipt, persist, overrides
func (_m *NakamaModule) PurchaseValidateGoogle(ctx context.Context, userID string, receipt string, persist bool, overrides ...struct {
	ClientEmail string
	PrivateKey  string
}) (*api.ValidatePurchaseResponse, error) {
	_va := make([]interface{}, len(overrides))
	for _i := range overrides {
		_va[_i] = overrides[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseValidateGoogle")
	}

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, overrides...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) error); ok {
		r1 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_PurchaseValidateGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseValidateGoogle'
type NakamaModule_PurchaseValidateGoogle_Call struct {
	*mock.Call
}

// PurchaseValidateGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - receipt string
//   - persist bool
//   - overrides ...struct{ClientEmail string;PrivateKey string}
func (_e *NakamaModule_Expecter) PurchaseValidateGoogle(ctx interface{}, userID interface{}, receipt interface{}, persist interface{}, overrides ...interface{}) *NakamaModule_PurchaseValidateGoogle_Call {
	return &NakamaModule_PurchaseValidateGoogle_Call{Call: _e.mock.On("PurchaseValidateGoogle",
		append([]interface{}{ctx, userID, receipt, persist}, overrides...)...)}
}

func (_c *NakamaModule_PurchaseValidateGoogle_Call) Run(run func(ctx context.Context, userID string, receipt string, persist bool, overrides ...struct {
	ClientEmail string
	PrivateKey  string
})) *NakamaModule_PurchaseValidateGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]struct {
			ClientEmail string
			PrivateKey  string
		}, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(struct {
					ClientEmail string
					PrivateKey  string
				})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool), variadicArgs...)
	})
	return _c
}

func (_c *NakamaModule_PurchaseValidateGoogle_Call) Return(_a0 *api.ValidatePurchaseResponse, _a1 error) *NakamaModule_PurchaseValidateGoogle_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_PurchaseValidateGoogle_Call) RunAndReturn(run func(context.Context, string, string, bool, ...struct {
	ClientEmail string
	PrivateKey  string
}) (*api.ValidatePurchaseResponse, error)) *NakamaModule_PurchaseValidateGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseValidateHuawei provides a mock function with given fields: ctx, userID, signature, inAppPurchaseData, persist
func (_m *NakamaModule) PurchaseValidateHuawei(ctx context.Context, userID string, signature string, inAppPurchaseData string, persist bool) (*api.ValidatePurchaseResponse, error) {
	ret := _m.Called(ctx, userID, signature, inAppPurchaseData, persist)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseValidateHuawei")
	}

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, signature, inAppPurchaseData, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, signature, inAppPurchaseData, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, bool) error); ok {
		r1 = rf(ctx, userID, signature, inAppPurchaseData, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_PurchaseValidateHuawei_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseValidateHuawei'
type NakamaModule_PurchaseValidateHuawei_Call struct {
	*mock.Call
}

// PurchaseValidateHuawei is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - signature string
//   - inAppPurchaseData string
//   - persist bool
func (_e *NakamaModule_Expecter) PurchaseValidateHuawei(ctx interface{}, userID interface{}, signature interface{}, inAppPurchaseData interface{}, persist interface{}) *NakamaModule_PurchaseValidateHuawei_Call {
	return &NakamaModule_PurchaseValidateHuawei_Call{Call: _e.mock.On("PurchaseValidateHuawei", ctx, userID, signature, inAppPurchaseData, persist)}
}

func (_c *NakamaModule_PurchaseValidateHuawei_Call) Run(run func(ctx context.Context, userID string, signature string, inAppPurchaseData string, persist bool)) *NakamaModule_PurchaseValidateHuawei_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(bool))
	})
	return _c
}

func (_c *NakamaModule_PurchaseValidateHuawei_Call) Return(_a0 *api.ValidatePurchaseResponse, _a1 error) *NakamaModule_PurchaseValidateHuawei_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_PurchaseValidateHuawei_Call) RunAndReturn(run func(context.Context, string, string, string, bool) (*api.ValidatePurchaseResponse, error)) *NakamaModule_PurchaseValidateHuawei_Call {
	_c.Call.Return(run)
	return _c
}

// PurchasesList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *NakamaModule) PurchasesList(ctx context.Context, userID string, limit int, cursor string) (*api.PurchaseList, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for PurchasesList")
	}

	var r0 *api.PurchaseList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*api.PurchaseList, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *api.PurchaseList); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PurchaseList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_PurchasesList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchasesList'
type NakamaModule_PurchasesList_Call struct {
	*mock.Call
}

// PurchasesList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - cursor string
func (_e *NakamaModule_Expecter) PurchasesList(ctx interface{}, userID interface{}, limit interface{}, cursor interface{}) *NakamaModule_PurchasesList_Call {
	return &NakamaModule_PurchasesList_Call{Call: _e.mock.On("PurchasesList", ctx, userID, limit, cursor)}
}

func (_c *NakamaModule_PurchasesList_Call) Run(run func(ctx context.Context, userID string, limit int, cursor string)) *NakamaModule_PurchasesList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *NakamaModule_PurchasesList_Call) Return(_a0 *api.PurchaseList, _a1 error) *NakamaModule_PurchasesList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_PurchasesList_Call) RunAndReturn(run func(context.Context, string, int, string) (*api.PurchaseList, error)) *NakamaModule_PurchasesList_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFile provides a mock function with given fields: path
func (_m *NakamaModule) ReadFile(path string) (*os.File, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for ReadFile")
	}

	var r0 *os.File
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*os.File, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) *os.File); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*os.File)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_ReadFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFile'
type NakamaModule_ReadFile_Call struct {
	*mock.Call
}

// ReadFile is a helper method to define mock.On call
//   - path string
func (_e *NakamaModule_Expecter) ReadFile(path interface{}) *NakamaModule_ReadFile_Call {
	return &NakamaModule_ReadFile_Call{Call: _e.mock.On("ReadFile", path)}
}

func (_c *NakamaModule_ReadFile_Call) Run(run func(path string)) *NakamaModule_ReadFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *NakamaModule_ReadFile_Call) Return(_a0 *os.File, _a1 error) *NakamaModule_ReadFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_ReadFile_Call) RunAndReturn(run func(string) (*os.File, error)) *NakamaModule_ReadFile_Call {
	_c.Call.Return(run)
	return _c
}

// SessionDisconnect provides a mock function with given fields: ctx, sessionID, reason
func (_m *NakamaModule) SessionDisconnect(ctx context.Context, sessionID string, reason ...runtime.PresenceReason) error {
	_va := make([]interface{}, len(reason))
	for _i := range reason {
		_va[_i] = reason[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, sessionID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SessionDisconnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...runtime.PresenceReason) error); ok {
		r0 = rf(ctx, sessionID, reason...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_SessionDisconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SessionDisconnect'
type NakamaModule_SessionDisconnect_Call struct {
	*mock.Call
}

// SessionDisconnect is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID string
//   - reason ...runtime.PresenceReason
func (_e *NakamaModule_Expecter) SessionDisconnect(ctx interface{}, sessionID interface{}, reason ...interface{}) *NakamaModule_SessionDisconnect_Call {
	return &NakamaModule_SessionDisconnect_Call{Call: _e.mock.On("SessionDisconnect",
		append([]interface{}{ctx, sessionID}, reason...)...)}
}

func (_c *NakamaModule_SessionDisconnect_Call) Run(run func(ctx context.Context, sessionID string, reason ...runtime.PresenceReason)) *NakamaModule_SessionDisconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]runtime.PresenceReason, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(runtime.PresenceReason)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *NakamaModule_SessionDisconnect_Call) Return(_a0 error) *NakamaModule_SessionDisconnect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_SessionDisconnect_Call) RunAndReturn(run func(context.Context, string, ...runtime.PresenceReason) error) *NakamaModule_SessionDisconnect_Call {
	_c.Call.Return(run)
	return _c
}

// SessionLogout provides a mock function with given fields: userID, token, refreshToken
func (_m *NakamaModule) SessionLogout(userID string, token string, refreshToken string) error {
	ret := _m.Called(userID, token, refreshToken)

	if len(ret) == 0 {
		panic("no return value specified for SessionLogout")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(userID, token, refreshToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_SessionLogout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SessionLogout'
type NakamaModule_SessionLogout_Call struct {
	*mock.Call
}

// SessionLogout is a helper method to define mock.On call
//   - userID string
//   - token string
//   - refreshToken string
func (_e *NakamaModule_Expecter) SessionLogout(userID interface{}, token interface{}, refreshToken interface{}) *NakamaModule_SessionLogout_Call {
	return &NakamaModule_SessionLogout_Call{Call: _e.mock.On("SessionLogout", userID, token, refreshToken)}
}

func (_c *NakamaModule_SessionLogout_Call) Run(run func(userID string, token string, refreshToken string)) *NakamaModule_SessionLogout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_SessionLogout_Call) Return(_a0 error) *NakamaModule_SessionLogout_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_SessionLogout_Call) RunAndReturn(run func(string, string, string) error) *NakamaModule_SessionLogout_Call {
	_c.Call.Return(run)
	return _c
}

// StorageDelete provides a mock function with given fields: ctx, deletes
func (_m *NakamaModule) StorageDelete(ctx context.Context, deletes []*runtime.StorageDelete) error {
	ret := _m.Called(ctx, deletes)

	if len(ret) == 0 {
		panic("no return value specified for StorageDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageDelete) error); ok {
		r0 = rf(ctx, deletes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_StorageDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StorageDelete'
type NakamaModule_StorageDelete_Call struct {
	*mock.Call
}

// StorageDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - deletes []*runtime.StorageDelete
func (_e *NakamaModule_Expecter) StorageDelete(ctx interface{}, deletes interface{}) *NakamaModule_StorageDelete_Call {
	return &NakamaModule_StorageDelete_Call{Call: _e.mock.On("StorageDelete", ctx, deletes)}
}

func (_c *NakamaModule_StorageDelete_Call) Run(run func(ctx context.Context, deletes []*runtime.StorageDelete)) *NakamaModule_StorageDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.StorageDelete))
	})
	return _c
}

func (_c *NakamaModule_StorageDelete_Call) Return(_a0 error) *NakamaModule_StorageDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_StorageDelete_Call) RunAndReturn(run func(context.Context, []*runtime.StorageDelete) error) *NakamaModule_StorageDelete_Call {
	_c.Call.Return(run)
	return _c
}

// StorageIndexList provides a mock function with given fields: ctx, callerID, indexName, query, limit
func (_m *NakamaModule) StorageIndexList(ctx context.Context, callerID string, indexName string, query string, limit int) (*api.StorageObjects, error) {
	ret := _m.Called(ctx, callerID, indexName, query, limit)

	if len(ret) == 0 {
		panic("no return value specified for StorageIndexList")
	}

	var r0 *api.StorageObjects
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int) (*api.StorageObjects, error)); ok {
		return rf(ctx, callerID, indexName, query, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int) *api.StorageObjects); ok {
		r0 = rf(ctx, callerID, indexName, query, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.StorageObjects)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int) error); ok {
		r1 = rf(ctx, callerID, indexName, query, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_StorageIndexList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StorageIndexList'
type NakamaModule_StorageIndexList_Call struct {
	*mock.Call
}

// StorageIndexList is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - indexName string
//   - query string
//   - limit int
func (_e *NakamaModule_Expecter) StorageIndexList(ctx interface{}, callerID interface{}, indexName interface{}, query interface{}, limit interface{}) *NakamaModule_StorageIndexList_Call {
	return &NakamaModule_StorageIndexList_Call{Call: _e.mock.On("StorageIndexList", ctx, callerID, indexName, query, limit)}
}

func (_c *NakamaModule_StorageIndexList_Call) Run(run func(ctx context.Context, callerID string, indexName string, query string, limit int)) *NakamaModule_StorageIndexList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int))
	})
	return _c
}

func (_c *NakamaModule_StorageIndexList_Call) Return(_a0 *api.StorageObjects, _a1 error) *NakamaModule_StorageIndexList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_StorageIndexList_Call) RunAndReturn(run func(context.Context, string, string, string, int) (*api.StorageObjects, error)) *NakamaModule_StorageIndexList_Call {
	_c.Call.Return(run)
	return _c
}

// StorageList provides a mock function with given fields: ctx, callerID, userID, collection, limit, cursor
func (_m *NakamaModule) StorageList(ctx context.Context, callerID string, userID string, collection string, limit int, cursor string) ([]*api.StorageObject, string, error) {
	ret := _m.Called(ctx, callerID, userID, collection, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for StorageList")
	}

	var r0 []*api.StorageObject
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, string) ([]*api.StorageObject, string, error)); ok {
		return rf(ctx, callerID, userID, collection, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, string) []*api.StorageObject); ok {
		r0 = rf(ctx, callerID, userID, collection, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObject)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int, string) string); ok {
		r1 = rf(ctx, callerID, userID, collection, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, int, string) error); ok {
		r2 = rf(ctx, callerID, userID, collection, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NakamaModule_StorageList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StorageList'
type NakamaModule_StorageList_Call struct {
	*mock.Call
}

// StorageList is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - userID string
//   - collection string
//   - limit int
//   - cursor string
func (_e *NakamaModule_Expecter) StorageList(ctx interface{}, callerID interface{}, userID interface{}, collection interface{}, limit interface{}, cursor interface{}) *NakamaModule_StorageList_Call {
	return &NakamaModule_StorageList_Call{Call: _e.mock.On("StorageList", ctx, callerID, userID, collection, limit, cursor)}
}

func (_c *NakamaModule_StorageList_Call) Run(run func(ctx context.Context, callerID string, userID string, collection string, limit int, cursor string)) *NakamaModule_StorageList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int), args[5].(string))
	})
	return _c
}

func (_c *NakamaModule_StorageList_Call) Return(_a0 []*api.StorageObject, _a1 string, _a2 error) *NakamaModule_StorageList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NakamaModule_StorageList_Call) RunAndReturn(run func(context.Context, string, string, string, int, string) ([]*api.StorageObject, string, error)) *NakamaModule_StorageList_Call {
	_c.Call.Return(run)
	return _c
}

// StorageRead provides a mock function with given fields: ctx, reads
func (_m *NakamaModule) StorageRead(ctx context.Context, reads []*runtime.StorageRead) ([]*api.StorageObject, error) {
	ret := _m.Called(ctx, reads)

	if len(ret) == 0 {
		panic("no return value specified for StorageRead")
	}

	var r0 []*api.StorageObject
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageRead) ([]*api.StorageObject, error)); ok {
		return rf(ctx, reads)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageRead) []*api.StorageObject); ok {
		r0 = rf(ctx, reads)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObject)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.StorageRead) error); ok {
		r1 = rf(ctx, reads)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_StorageRead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StorageRead'
type NakamaModule_StorageRead_Call struct {
	*mock.Call
}

// StorageRead is a helper method to define mock.On call
//   - ctx context.Context
//   - reads []*runtime.StorageRead
func (_e *NakamaModule_Expecter) StorageRead(ctx interface{}, reads interface{}) *NakamaModule_StorageRead_Call {
	return &NakamaModule_StorageRead_Call{Call: _e.mock.On("StorageRead", ctx, reads)}
}

func (_c *NakamaModule_StorageRead_Call) Run(run func(ctx context.Context, reads []*runtime.StorageRead)) *NakamaModule_StorageRead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.StorageRead))
	})
	return _c
}

func (_c *NakamaModule_StorageRead_Call) Return(_a0 []*api.StorageObject, _a1 error) *NakamaModule_StorageRead_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_StorageRead_Call) RunAndReturn(run func(context.Context, []*runtime.StorageRead) ([]*api.StorageObject, error)) *NakamaModule_StorageRead_Call {
	_c.Call.Return(run)
	return _c
}

// StorageWrite provides a mock function with given fields: ctx, writes
func (_m *NakamaModule) StorageWrite(ctx context.Context, writes []*runtime.StorageWrite) ([]*api.StorageObjectAck, error) {
	ret := _m.Called(ctx, writes)

	if len(ret) == 0 {
		panic("no return value specified for StorageWrite")
	}

	var r0 []*api.StorageObjectAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageWrite) ([]*api.StorageObjectAck, error)); ok {
		return rf(ctx, writes)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageWrite) []*api.StorageObjectAck); ok {
		r0 = rf(ctx, writes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObjectAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.StorageWrite) error); ok {
		r1 = rf(ctx, writes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_StorageWrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StorageWrite'
type NakamaModule_StorageWrite_Call struct {
	*mock.Call
}

// StorageWrite is a helper method to define mock.On call
//   - ctx context.Context
//   - writes []*runtime.StorageWrite
func (_e *NakamaModule_Expecter) StorageWrite(ctx interface{}, writes interface{}) *NakamaModule_StorageWrite_Call {
	return &NakamaModule_StorageWrite_Call{Call: _e.mock.On("StorageWrite", ctx, writes)}
}

func (_c *NakamaModule_StorageWrite_Call) Run(run func(ctx context.Context, writes []*runtime.StorageWrite)) *NakamaModule_StorageWrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.StorageWrite))
	})
	return _c
}

func (_c *NakamaModule_StorageWrite_Call) Return(_a0 []*api.StorageObjectAck, _a1 error) *NakamaModule_StorageWrite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_StorageWrite_Call) RunAndReturn(run func(context.Context, []*runtime.StorageWrite) ([]*api.StorageObjectAck, error)) *NakamaModule_StorageWrite_Call {
	_c.Call.Return(run)
	return _c
}

// StreamClose provides a mock function with given fields: mode, subject, subcontext, label
func (_m *NakamaModule) StreamClose(mode uint8, subject string, subcontext string, label string) error {
	ret := _m.Called(mode, subject, subcontext, label)

	if len(ret) == 0 {
		panic("no return value specified for StreamClose")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string) error); ok {
		r0 = rf(mode, subject, subcontext, label)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_StreamClose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamClose'
type NakamaModule_StreamClose_Call struct {
	*mock.Call
}

// StreamClose is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
func (_e *NakamaModule_Expecter) StreamClose(mode interface{}, subject interface{}, subcontext interface{}, label interface{}) *NakamaModule_StreamClose_Call {
	return &NakamaModule_StreamClose_Call{Call: _e.mock.On("StreamClose", mode, subject, subcontext, label)}
}

func (_c *NakamaModule_StreamClose_Call) Run(run func(mode uint8, subject string, subcontext string, label string)) *NakamaModule_StreamClose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *NakamaModule_StreamClose_Call) Return(_a0 error) *NakamaModule_StreamClose_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_StreamClose_Call) RunAndReturn(run func(uint8, string, string, string) error) *NakamaModule_StreamClose_Call {
	_c.Call.Return(run)
	return _c
}

// StreamCount provides a mock function with given fields: mode, subject, subcontext, label
func (_m *NakamaModule) StreamCount(mode uint8, subject string, subcontext string, label string) (int, error) {
	ret := _m.Called(mode, subject, subcontext, label)

	if len(ret) == 0 {
		panic("no return value specified for StreamCount")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string) (int, error)); ok {
		return rf(mode, subject, subcontext, label)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string) int); ok {
		r0 = rf(mode, subject, subcontext, label)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string) error); ok {
		r1 = rf(mode, subject, subcontext, label)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_StreamCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamCount'
type NakamaModule_StreamCount_Call struct {
	*mock.Call
}

// StreamCount is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
func (_e *NakamaModule_Expecter) StreamCount(mode interface{}, subject interface{}, subcontext interface{}, label interface{}) *NakamaModule_StreamCount_Call {
	return &NakamaModule_StreamCount_Call{Call: _e.mock.On("StreamCount", mode, subject, subcontext, label)}
}

func (_c *NakamaModule_StreamCount_Call) Run(run func(mode uint8, subject string, subcontext string, label string)) *NakamaModule_StreamCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *NakamaModule_StreamCount_Call) Return(_a0 int, _a1 error) *NakamaModule_StreamCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_StreamCount_Call) RunAndReturn(run func(uint8, string, string, string) (int, error)) *NakamaModule_StreamCount_Call {
	_c.Call.Return(run)
	return _c
}

// StreamSend provides a mock function with given fields: mode, subject, subcontext, label, data, presences, reliable
func (_m *NakamaModule) StreamSend(mode uint8, subject string, subcontext string, label string, data string, presences []runtime.Presence, reliable bool) error {
	ret := _m.Called(mode, subject, subcontext, label, data, presences, reliable)

	if len(ret) == 0 {
		panic("no return value specified for StreamSend")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, []runtime.Presence, bool) error); ok {
		r0 = rf(mode, subject, subcontext, label, data, presences, reliable)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_StreamSend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamSend'
type NakamaModule_StreamSend_Call struct {
	*mock.Call
}

// StreamSend is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - data string
//   - presences []runtime.Presence
//   - reliable bool
func (_e *NakamaModule_Expecter) StreamSend(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, data interface{}, presences interface{}, reliable interface{}) *NakamaModule_StreamSend_Call {
	return &NakamaModule_StreamSend_Call{Call: _e.mock.On("StreamSend", mode, subject, subcontext, label, data, presences, reliable)}
}

func (_c *NakamaModule_StreamSend_Call) Run(run func(mode uint8, subject string, subcontext string, label string, data string, presences []runtime.Presence, reliable bool)) *NakamaModule_StreamSend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].([]runtime.Presence), args[6].(bool))
	})
	return _c
}

func (_c *NakamaModule_StreamSend_Call) Return(_a0 error) *NakamaModule_StreamSend_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_StreamSend_Call) RunAndReturn(run func(uint8, string, string, string, string, []runtime.Presence, bool) error) *NakamaModule_StreamSend_Call {
	_c.Call.Return(run)
	return _c
}

// StreamSendRaw provides a mock function with given fields: mode, subject, subcontext, label, msg, presences, reliable
func (_m *NakamaModule) StreamSendRaw(mode uint8, subject string, subcontext string, label string, msg *rtapi.Envelope, presences []runtime.Presence, reliable bool) error {
	ret := _m.Called(mode, subject, subcontext, label, msg, presences, reliable)

	if len(ret) == 0 {
		panic("no return value specified for StreamSendRaw")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, *rtapi.Envelope, []runtime.Presence, bool) error); ok {
		r0 = rf(mode, subject, subcontext, label, msg, presences, reliable)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_StreamSendRaw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamSendRaw'
type NakamaModule_StreamSendRaw_Call struct {
	*mock.Call
}

// StreamSendRaw is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - msg *rtapi.Envelope
//   - presences []runtime.Presence
//   - reliable bool
func (_e *NakamaModule_Expecter) StreamSendRaw(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, msg interface{}, presences interface{}, reliable interface{}) *NakamaModule_StreamSendRaw_Call {
	return &NakamaModule_StreamSendRaw_Call{Call: _e.mock.On("StreamSendRaw", mode, subject, subcontext, label, msg, presences, reliable)}
}

func (_c *NakamaModule_StreamSendRaw_Call) Run(run func(mode uint8, subject string, subcontext string, label string, msg *rtapi.Envelope, presences []runtime.Presence, reliable bool)) *NakamaModule_StreamSendRaw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(*rtapi.Envelope), args[5].([]runtime.Presence), args[6].(bool))
	})
	return _c
}

func (_c *NakamaModule_StreamSendRaw_Call) Return(_a0 error) *NakamaModule_StreamSendRaw_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_StreamSendRaw_Call) RunAndReturn(run func(uint8, string, string, string, *rtapi.Envelope, []runtime.Presence, bool) error) *NakamaModule_StreamSendRaw_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserGet provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID
func (_m *NakamaModule) StreamUserGet(mode uint8, subject string, subcontext string, label string, userID string, sessionID string) (runtime.PresenceMeta, error) {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserGet")
	}

	var r0 runtime.PresenceMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string) (runtime.PresenceMeta, error)); ok {
		return rf(mode, subject, subcontext, label, userID, sessionID)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string) runtime.PresenceMeta); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.PresenceMeta)
		}
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string, string, string) error); ok {
		r1 = rf(mode, subject, subcontext, label, userID, sessionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_StreamUserGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserGet'
type NakamaModule_StreamUserGet_Call struct {
	*mock.Call
}

// StreamUserGet is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - userID string
//   - sessionID string
func (_e *NakamaModule_Expecter) StreamUserGet(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, userID interface{}, sessionID interface{}) *NakamaModule_StreamUserGet_Call {
	return &NakamaModule_StreamUserGet_Call{Call: _e.mock.On("StreamUserGet", mode, subject, subcontext, label, userID, sessionID)}
}

func (_c *NakamaModule_StreamUserGet_Call) Run(run func(mode uint8, subject string, subcontext string, label string, userID string, sessionID string)) *NakamaModule_StreamUserGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string))
	})
	return _c
}

func (_c *NakamaModule_StreamUserGet_Call) Return(_a0 runtime.PresenceMeta, _a1 error) *NakamaModule_StreamUserGet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_StreamUserGet_Call) RunAndReturn(run func(uint8, string, string, string, string, string) (runtime.PresenceMeta, error)) *NakamaModule_StreamUserGet_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserJoin provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status
func (_m *NakamaModule) StreamUserJoin(mode uint8, subject string, subcontext string, label string, userID string, sessionID string, hidden bool, persistence bool, status string) (bool, error) {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserJoin")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string, bool, bool, string) (bool, error)); ok {
		return rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string, bool, bool, string) bool); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string, string, string, bool, bool, string) error); ok {
		r1 = rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_StreamUserJoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserJoin'
type NakamaModule_StreamUserJoin_Call struct {
	*mock.Call
}

// StreamUserJoin is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - userID string
//   - sessionID string
//   - hidden bool
//   - persistence bool
//   - status string
func (_e *NakamaModule_Expecter) StreamUserJoin(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, userID interface{}, sessionID interface{}, hidden interface{}, persistence interface{}, status interface{}) *NakamaModule_StreamUserJoin_Call {
	return &NakamaModule_StreamUserJoin_Call{Call: _e.mock.On("StreamUserJoin", mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)}
}

func (_c *NakamaModule_StreamUserJoin_Call) Run(run func(mode uint8, subject string, subcontext string, label string, userID string, sessionID string, hidden bool, persistence bool, status string)) *NakamaModule_StreamUserJoin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string), args[6].(bool), args[7].(bool), args[8].(string))
	})
	return _c
}

func (_c *NakamaModule_StreamUserJoin_Call) Return(_a0 bool, _a1 error) *NakamaModule_StreamUserJoin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_StreamUserJoin_Call) RunAndReturn(run func(uint8, string, string, string, string, string, bool, bool, string) (bool, error)) *NakamaModule_StreamUserJoin_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserKick provides a mock function with given fields: mode, subject, subcontext, label, presence
func (_m *NakamaModule) StreamUserKick(mode uint8, subject string, subcontext string, label string, presence runtime.Presence) error {
	ret := _m.Called(mode, subject, subcontext, label, presence)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserKick")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, runtime.Presence) error); ok {
		r0 = rf(mode, subject, subcontext, label, presence)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_StreamUserKick_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserKick'
type NakamaModule_StreamUserKick_Call struct {
	*mock.Call
}

// StreamUserKick is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - presence runtime.Presence
func (_e *NakamaModule_Expecter) StreamUserKick(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, presence interface{}) *NakamaModule_StreamUserKick_Call {
	return &NakamaModule_StreamUserKick_Call{Call: _e.mock.On("StreamUserKick", mode, subject, subcontext, label, presence)}
}

func (_c *NakamaModule_StreamUserKick_Call) Run(run func(mode uint8, subject string, subcontext string, label string, presence runtime.Presence)) *NakamaModule_StreamUserKick_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(runtime.Presence))
	})
	return _c
}

func (_c *NakamaModule_StreamUserKick_Call) Return(_a0 error) *NakamaModule_StreamUserKick_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_StreamUserKick_Call) RunAndReturn(run func(uint8, string, string, string, runtime.Presence) error) *NakamaModule_StreamUserKick_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserLeave provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID
func (_m *NakamaModule) StreamUserLeave(mode uint8, subject string, subcontext string, label string, userID string, sessionID string) error {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserLeave")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string) error); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_StreamUserLeave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserLeave'
type NakamaModule_StreamUserLeave_Call struct {
	*mock.Call
}

// StreamUserLeave is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - userID string
//   - sessionID string
func (_e *NakamaModule_Expecter) StreamUserLeave(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, userID interface{}, sessionID interface{}) *NakamaModule_StreamUserLeave_Call {
	return &NakamaModule_StreamUserLeave_Call{Call: _e.mock.On("StreamUserLeave", mode, subject, subcontext, label, userID, sessionID)}
}

func (_c *NakamaModule_StreamUserLeave_Call) Run(run func(mode uint8, subject string, subcontext string, label string, userID string, sessionID string)) *NakamaModule_StreamUserLeave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string))
	})
	return _c
}

func (_c *NakamaModule_StreamUserLeave_Call) Return(_a0 error) *NakamaModule_StreamUserLeave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_StreamUserLeave_Call) RunAndReturn(run func(uint8, string, string, string, string, string) error) *NakamaModule_StreamUserLeave_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserList provides a mock function with given fields: mode, subject, subcontext, label, includeHidden, includeNotHidden
func (_m *NakamaModule) StreamUserList(mode uint8, subject string, subcontext string, label string, includeHidden bool, includeNotHidden bool) ([]runtime.Presence, error) {
	ret := _m.Called(mode, subject, subcontext, label, includeHidden, includeNotHidden)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserList")
	}

	var r0 []runtime.Presence
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, bool, bool) ([]runtime.Presence, error)); ok {
		return rf(mode, subject, subcontext, label, includeHidden, includeNotHidden)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, bool, bool) []runtime.Presence); ok {
		r0 = rf(mode, subject, subcontext, label, includeHidden, includeNotHidden)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.Presence)
		}
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string, bool, bool) error); ok {
		r1 = rf(mode, subject, subcontext, label, includeHidden, includeNotHidden)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_StreamUserList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserList'
type NakamaModule_StreamUserList_Call struct {
	*mock.Call
}

// StreamUserList is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - includeHidden bool
//   - includeNotHidden bool
func (_e *NakamaModule_Expecter) StreamUserList(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, includeHidden interface{}, includeNotHidden interface{}) *NakamaModule_StreamUserList_Call {
	return &NakamaModule_StreamUserList_Call{Call: _e.mock.On("StreamUserList", mode, subject, subcontext, label, includeHidden, includeNotHidden)}
}

func (_c *NakamaModule_StreamUserList_Call) Run(run func(mode uint8, subject string, subcontext string, label string, includeHidden bool, includeNotHidden bool)) *NakamaModule_StreamUserList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(bool), args[5].(bool))
	})
	return _c
}

func (_c *NakamaModule_StreamUserList_Call) Return(_a0 []runtime.Presence, _a1 error) *NakamaModule_StreamUserList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_StreamUserList_Call) RunAndReturn(run func(uint8, string, string, string, bool, bool) ([]runtime.Presence, error)) *NakamaModule_StreamUserList_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserUpdate provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status
func (_m *NakamaModule) StreamUserUpdate(mode uint8, subject string, subcontext string, label string, userID string, sessionID string, hidden bool, persistence bool, status string) error {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string, bool, bool, string) error); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_StreamUserUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserUpdate'
type NakamaModule_StreamUserUpdate_Call struct {
	*mock.Call
}

// StreamUserUpdate is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - userID string
//   - sessionID string
//   - hidden bool
//   - persistence bool
//   - status string
func (_e *NakamaModule_Expecter) StreamUserUpdate(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, userID interface{}, sessionID interface{}, hidden interface{}, persistence interface{}, status interface{}) *NakamaModule_StreamUserUpdate_Call {
	return &NakamaModule_StreamUserUpdate_Call{Call: _e.mock.On("StreamUserUpdate", mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)}
}

func (_c *NakamaModule_StreamUserUpdate_Call) Run(run func(mode uint8, subject string, subcontext string, label string, userID string, sessionID string, hidden bool, persistence bool, status string)) *NakamaModule_StreamUserUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string), args[6].(bool), args[7].(bool), args[8].(string))
	})
	return _c
}

func (_c *NakamaModule_StreamUserUpdate_Call) Return(_a0 error) *NakamaModule_StreamUserUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_StreamUserUpdate_Call) RunAndReturn(run func(uint8, string, string, string, string, string, bool, bool, string) error) *NakamaModule_StreamUserUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// SubscriptionGetByProductId provides a mock function with given fields: ctx, userID, productID
func (_m *NakamaModule) SubscriptionGetByProductId(ctx context.Context, userID string, productID string) (*api.ValidatedSubscription, error) {
	ret := _m.Called(ctx, userID, productID)

	if len(ret) == 0 {
		panic("no return value specified for SubscriptionGetByProductId")
	}

	var r0 *api.ValidatedSubscription
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*api.ValidatedSubscription, error)); ok {
		return rf(ctx, userID, productID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *api.ValidatedSubscription); ok {
		r0 = rf(ctx, userID, productID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatedSubscription)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userID, productID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_SubscriptionGetByProductId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscriptionGetByProductId'
type NakamaModule_SubscriptionGetByProductId_Call struct {
	*mock.Call
}

// SubscriptionGetByProductId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - productID string
func (_e *NakamaModule_Expecter) SubscriptionGetByProductId(ctx interface{}, userID interface{}, productID interface{}) *NakamaModule_SubscriptionGetByProductId_Call {
	return &NakamaModule_SubscriptionGetByProductId_Call{Call: _e.mock.On("SubscriptionGetByProductId", ctx, userID, productID)}
}

func (_c *NakamaModule_SubscriptionGetByProductId_Call) Run(run func(ctx context.Context, userID string, productID string)) *NakamaModule_SubscriptionGetByProductId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_SubscriptionGetByProductId_Call) Return(_a0 *api.ValidatedSubscription, _a1 error) *NakamaModule_SubscriptionGetByProductId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_SubscriptionGetByProductId_Call) RunAndReturn(run func(context.Context, string, string) (*api.ValidatedSubscription, error)) *NakamaModule_SubscriptionGetByProductId_Call {
	_c.Call.Return(run)
	return _c
}

// SubscriptionValidateApple provides a mock function with given fields: ctx, userID, receipt, persist, passwordOverride
func (_m *NakamaModule) SubscriptionValidateApple(ctx context.Context, userID string, receipt string, persist bool, passwordOverride ...string) (*api.ValidateSubscriptionResponse, error) {
	_va := make([]interface{}, len(passwordOverride))
	for _i := range passwordOverride {
		_va[_i] = passwordOverride[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubscriptionValidateApple")
	}

	var r0 *api.ValidateSubscriptionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) (*api.ValidateSubscriptionResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, passwordOverride...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) *api.ValidateSubscriptionResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidateSubscriptionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...string) error); ok {
		r1 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_SubscriptionValidateApple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscriptionValidateApple'
type NakamaModule_SubscriptionValidateApple_Call struct {
	*mock.Call
}

// SubscriptionValidateApple is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - receipt string
//   - persist bool
//   - passwordOverride ...string
func (_e *NakamaModule_Expecter) SubscriptionValidateApple(ctx interface{}, userID interface{}, receipt interface{}, persist interface{}, passwordOverride ...interface{}) *NakamaModule_SubscriptionValidateApple_Call {
	return &NakamaModule_SubscriptionValidateApple_Call{Call: _e.mock.On("SubscriptionValidateApple",
		append([]interface{}{ctx, userID, receipt, persist}, passwordOverride...)...)}
}

func (_c *NakamaModule_SubscriptionValidateApple_Call) Run(run func(ctx context.Context, userID string, receipt string, persist bool, passwordOverride ...string)) *NakamaModule_SubscriptionValidateApple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool), variadicArgs...)
	})
	return _c
}

func (_c *NakamaModule_SubscriptionValidateApple_Call) Return(_a0 *api.ValidateSubscriptionResponse, _a1 error) *NakamaModule_SubscriptionValidateApple_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_SubscriptionValidateApple_Call) RunAndReturn(run func(context.Context, string, string, bool, ...string) (*api.ValidateSubscriptionResponse, error)) *NakamaModule_SubscriptionValidateApple_Call {
	_c.Call.Return(run)
	return _c
}

// SubscriptionValidateGoogle provides a mock function with given fields: ctx, userID, receipt, persist, overrides
func (_m *NakamaModule) SubscriptionValidateGoogle(ctx context.Context, userID string, receipt string, persist bool, overrides ...struct {
	ClientEmail string
	PrivateKey  string
}) (*api.ValidateSubscriptionResponse, error) {
	_va := make([]interface{}, len(overrides))
	for _i := range overrides {
		_va[_i] = overrides[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubscriptionValidateGoogle")
	}

	var r0 *api.ValidateSubscriptionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) (*api.ValidateSubscriptionResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, overrides...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) *api.ValidateSubscriptionResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidateSubscriptionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) error); ok {
		r1 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_SubscriptionValidateGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscriptionValidateGoogle'
type NakamaModule_SubscriptionValidateGoogle_Call struct {
	*mock.Call
}

// SubscriptionValidateGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - receipt string
//   - persist bool
//   - overrides ...struct{ClientEmail string;PrivateKey string}
func (_e *NakamaModule_Expecter) SubscriptionValidateGoogle(ctx interface{}, userID interface{}, receipt interface{}, persist interface{}, overrides ...interface{}) *NakamaModule_SubscriptionValidateGoogle_Call {
	return &NakamaModule_SubscriptionValidateGoogle_Call{Call: _e.mock.On("SubscriptionValidateGoogle",
		append([]interface{}{ctx, userID, receipt, persist}, overrides...)...)}
}

func (_c *NakamaModule_SubscriptionValidateGoogle_Call) Run(run func(ctx context.Context, userID string, receipt string, persist bool, overrides ...struct {
	ClientEmail string
	PrivateKey  string
})) *NakamaModule_SubscriptionValidateGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]struct {
			ClientEmail string
			PrivateKey  string
		}, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(struct {
					ClientEmail string
					PrivateKey  string
				})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool), variadicArgs...)
	})
	return _c
}

func (_c *NakamaModule_SubscriptionValidateGoogle_Call) Return(_a0 *api.ValidateSubscriptionResponse, _a1 error) *NakamaModule_SubscriptionValidateGoogle_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_SubscriptionValidateGoogle_Call) RunAndReturn(run func(context.Context, string, string, bool, ...struct {
	ClientEmail string
	PrivateKey  string
}) (*api.ValidateSubscriptionResponse, error)) *NakamaModule_SubscriptionValidateGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// SubscriptionsList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *NakamaModule) SubscriptionsList(ctx context.Context, userID string, limit int, cursor string) (*api.SubscriptionList, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for SubscriptionsList")
	}

	var r0 *api.SubscriptionList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*api.SubscriptionList, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *api.SubscriptionList); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.SubscriptionList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_SubscriptionsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscriptionsList'
type NakamaModule_SubscriptionsList_Call struct {
	*mock.Call
}

// SubscriptionsList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - cursor string
func (_e *NakamaModule_Expecter) SubscriptionsList(ctx interface{}, userID interface{}, limit interface{}, cursor interface{}) *NakamaModule_SubscriptionsList_Call {
	return &NakamaModule_SubscriptionsList_Call{Call: _e.mock.On("SubscriptionsList", ctx, userID, limit, cursor)}
}

func (_c *NakamaModule_SubscriptionsList_Call) Run(run func(ctx context.Context, userID string, limit int, cursor string)) *NakamaModule_SubscriptionsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *NakamaModule_SubscriptionsList_Call) Return(_a0 *api.SubscriptionList, _a1 error) *NakamaModule_SubscriptionsList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_SubscriptionsList_Call) RunAndReturn(run func(context.Context, string, int, string) (*api.SubscriptionList, error)) *NakamaModule_SubscriptionsList_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentAddAttempt provides a mock function with given fields: ctx, id, ownerID, count
func (_m *NakamaModule) TournamentAddAttempt(ctx context.Context, id string, ownerID string, count int) error {
	ret := _m.Called(ctx, id, ownerID, count)

	if len(ret) == 0 {
		panic("no return value specified for TournamentAddAttempt")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) error); ok {
		r0 = rf(ctx, id, ownerID, count)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_TournamentAddAttempt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentAddAttempt'
type NakamaModule_TournamentAddAttempt_Call struct {
	*mock.Call
}

// TournamentAddAttempt is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - count int
func (_e *NakamaModule_Expecter) TournamentAddAttempt(ctx interface{}, id interface{}, ownerID interface{}, count interface{}) *NakamaModule_TournamentAddAttempt_Call {
	return &NakamaModule_TournamentAddAttempt_Call{Call: _e.mock.On("TournamentAddAttempt", ctx, id, ownerID, count)}
}

func (_c *NakamaModule_TournamentAddAttempt_Call) Run(run func(ctx context.Context, id string, ownerID string, count int)) *NakamaModule_TournamentAddAttempt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *NakamaModule_TournamentAddAttempt_Call) Return(_a0 error) *NakamaModule_TournamentAddAttempt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_TournamentAddAttempt_Call) RunAndReturn(run func(context.Context, string, string, int) error) *NakamaModule_TournamentAddAttempt_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentCreate provides a mock function with given fields: ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired
func (_m *NakamaModule) TournamentCreate(ctx context.Context, id string, authoritative bool, sortOrder string, operator string, resetSchedule string, metadata map[string]interface{}, title string, description string, category int, startTime int, endTime int, duration int, maxSize int, maxNumScore int, joinRequired bool) error {
	ret := _m.Called(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired)

	if len(ret) == 0 {
		panic("no return value specified for TournamentCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, string, string, map[string]interface{}, string, string, int, int, int, int, int, int, bool) error); ok {
		r0 = rf(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_TournamentCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentCreate'
type NakamaModule_TournamentCreate_Call struct {
	*mock.Call
}

// TournamentCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - authoritative bool
//   - sortOrder string
//   - operator string
//   - resetSchedule string
//   - metadata map[string]interface{}
//   - title string
//   - description string
//   - category int
//   - startTime int
//   - endTime int
//   - duration int
//   - maxSize int
//   - maxNumScore int
//   - joinRequired bool
func (_e *NakamaModule_Expecter) TournamentCreate(ctx interface{}, id interface{}, authoritative interface{}, sortOrder interface{}, operator interface{}, resetSchedule interface{}, metadata interface{}, title interface{}, description interface{}, category interface{}, startTime interface{}, endTime interface{}, duration interface{}, maxSize interface{}, maxNumScore interface{}, joinRequired interface{}) *NakamaModule_TournamentCreate_Call {
	return &NakamaModule_TournamentCreate_Call{Call: _e.mock.On("TournamentCreate", ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired)}
}

func (_c *NakamaModule_TournamentCreate_Call) Run(run func(ctx context.Context, id string, authoritative bool, sortOrder string, operator string, resetSchedule string, metadata map[string]interface{}, title string, description string, category int, startTime int, endTime int, duration int, maxSize int, maxNumScore int, joinRequired bool)) *NakamaModule_TournamentCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool), args[3].(string), args[4].(string), args[5].(string), args[6].(map[string]interface{}), args[7].(string), args[8].(string), args[9].(int), args[10].(int), args[11].(int), args[12].(int), args[13].(int), args[14].(int), args[15].(bool))
	})
	return _c
}

func (_c *NakamaModule_TournamentCreate_Call) Return(_a0 error) *NakamaModule_TournamentCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_TournamentCreate_Call) RunAndReturn(run func(context.Context, string, bool, string, string, string, map[string]interface{}, string, string, int, int, int, int, int, int, bool) error) *NakamaModule_TournamentCreate_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentDelete provides a mock function with given fields: ctx, id
func (_m *NakamaModule) TournamentDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for TournamentDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_TournamentDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentDelete'
type NakamaModule_TournamentDelete_Call struct {
	*mock.Call
}

// TournamentDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *NakamaModule_Expecter) TournamentDelete(ctx interface{}, id interface{}) *NakamaModule_TournamentDelete_Call {
	return &NakamaModule_TournamentDelete_Call{Call: _e.mock.On("TournamentDelete", ctx, id)}
}

func (_c *NakamaModule_TournamentDelete_Call) Run(run func(ctx context.Context, id string)) *NakamaModule_TournamentDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *NakamaModule_TournamentDelete_Call) Return(_a0 error) *NakamaModule_TournamentDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_TournamentDelete_Call) RunAndReturn(run func(context.Context, string) error) *NakamaModule_TournamentDelete_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentJoin provides a mock function with given fields: ctx, id, ownerID, username
func (_m *NakamaModule) TournamentJoin(ctx context.Context, id string, ownerID string, username string) error {
	ret := _m.Called(ctx, id, ownerID, username)

	if len(ret) == 0 {
		panic("no return value specified for TournamentJoin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, id, ownerID, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_TournamentJoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentJoin'
type NakamaModule_TournamentJoin_Call struct {
	*mock.Call
}

// TournamentJoin is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - username string
func (_e *NakamaModule_Expecter) TournamentJoin(ctx interface{}, id interface{}, ownerID interface{}, username interface{}) *NakamaModule_TournamentJoin_Call {
	return &NakamaModule_TournamentJoin_Call{Call: _e.mock.On("TournamentJoin", ctx, id, ownerID, username)}
}

func (_c *NakamaModule_TournamentJoin_Call) Run(run func(ctx context.Context, id string, ownerID string, username string)) *NakamaModule_TournamentJoin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *NakamaModule_TournamentJoin_Call) Return(_a0 error) *NakamaModule_TournamentJoin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_TournamentJoin_Call) RunAndReturn(run func(context.Context, string, string, string) error) *NakamaModule_TournamentJoin_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentList provides a mock function with given fields: ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor
func (_m *NakamaModule) TournamentList(ctx context.Context, categoryStart int, categoryEnd int, startTime int, endTime int, limit int, cursor string) (*api.TournamentList, error) {
	ret := _m.Called(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for TournamentList")
	}

	var r0 *api.TournamentList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, int, int, string) (*api.TournamentList, error)); ok {
		return rf(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, int, int, string) *api.TournamentList); ok {
		r0 = rf(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.TournamentList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int, int, int, string) error); ok {
		r1 = rf(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_TournamentList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentList'
type NakamaModule_TournamentList_Call struct {
	*mock.Call
}

// TournamentList is a helper method to define mock.On call
//   - ctx context.Context
//   - categoryStart int
//   - categoryEnd int
//   - startTime int
//   - endTime int
//   - limit int
//   - cursor string
func (_e *NakamaModule_Expecter) TournamentList(ctx interface{}, categoryStart interface{}, categoryEnd interface{}, startTime interface{}, endTime interface{}, limit interface{}, cursor interface{}) *NakamaModule_TournamentList_Call {
	return &NakamaModule_TournamentList_Call{Call: _e.mock.On("TournamentList", ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)}
}

func (_c *NakamaModule_TournamentList_Call) Run(run func(ctx context.Context, categoryStart int, categoryEnd int, startTime int, endTime int, limit int, cursor string)) *NakamaModule_TournamentList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int), args[4].(int), args[5].(int), args[6].(string))
	})
	return _c
}

func (_c *NakamaModule_TournamentList_Call) Return(_a0 *api.TournamentList, _a1 error) *NakamaModule_TournamentList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_TournamentList_Call) RunAndReturn(run func(context.Context, int, int, int, int, int, string) (*api.TournamentList, error)) *NakamaModule_TournamentList_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentRecordDelete provides a mock function with given fields: ctx, id, ownerID
func (_m *NakamaModule) TournamentRecordDelete(ctx context.Context, id string, ownerID string) error {
	ret := _m.Called(ctx, id, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for TournamentRecordDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, id, ownerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_TournamentRecordDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentRecordDelete'
type NakamaModule_TournamentRecordDelete_Call struct {
	*mock.Call
}

// TournamentRecordDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
func (_e *NakamaModule_Expecter) TournamentRecordDelete(ctx interface{}, id interface{}, ownerID interface{}) *NakamaModule_TournamentRecordDelete_Call {
	return &NakamaModule_TournamentRecordDelete_Call{Call: _e.mock.On("TournamentRecordDelete", ctx, id, ownerID)}
}

func (_c *NakamaModule_TournamentRecordDelete_Call) Run(run func(ctx context.Context, id string, ownerID string)) *NakamaModule_TournamentRecordDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_TournamentRecordDelete_Call) Return(_a0 error) *NakamaModule_TournamentRecordDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_TournamentRecordDelete_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_TournamentRecordDelete_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentRecordWrite provides a mock function with given fields: ctx, id, ownerID, username, score, subscore, metadata, operatorOverride
func (_m *NakamaModule) TournamentRecordWrite(ctx context.Context, id string, ownerID string, username string, score int64, subscore int64, metadata map[string]interface{}, operatorOverride *int) (*api.LeaderboardRecord, error) {
	ret := _m.Called(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)

	if len(ret) == 0 {
		panic("no return value specified for TournamentRecordWrite")
	}

	var r0 *api.LeaderboardRecord
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) (*api.LeaderboardRecord, error)); ok {
		return rf(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) *api.LeaderboardRecord); ok {
		r0 = rf(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) error); ok {
		r1 = rf(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_TournamentRecordWrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentRecordWrite'
type NakamaModule_TournamentRecordWrite_Call struct {
	*mock.Call
}

// TournamentRecordWrite is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - username string
//   - score int64
//   - subscore int64
//   - metadata map[string]interface{}
//   - operatorOverride *int
func (_e *NakamaModule_Expecter) TournamentRecordWrite(ctx interface{}, id interface{}, ownerID interface{}, username interface{}, score interface{}, subscore interface{}, metadata interface{}, operatorOverride interface{}) *NakamaModule_TournamentRecordWrite_Call {
	return &NakamaModule_TournamentRecordWrite_Call{Call: _e.mock.On("TournamentRecordWrite", ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)}
}

func (_c *NakamaModule_TournamentRecordWrite_Call) Run(run func(ctx context.Context, id string, ownerID string, username string, score int64, subscore int64, metadata map[string]interface{}, operatorOverride *int)) *NakamaModule_TournamentRecordWrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64), args[5].(int64), args[6].(map[string]interface{}), args[7].(*int))
	})
	return _c
}

func (_c *NakamaModule_TournamentRecordWrite_Call) Return(_a0 *api.LeaderboardRecord, _a1 error) *NakamaModule_TournamentRecordWrite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_TournamentRecordWrite_Call) RunAndReturn(run func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) (*api.LeaderboardRecord, error)) *NakamaModule_TournamentRecordWrite_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentRecordsHaystack provides a mock function with given fields: ctx, id, ownerID, limit, cursor, expiry
func (_m *NakamaModule) TournamentRecordsHaystack(ctx context.Context, id string, ownerID string, limit int, cursor string, expiry int64) (*api.TournamentRecordList, error) {
	ret := _m.Called(ctx, id, ownerID, limit, cursor, expiry)

	if len(ret) == 0 {
		panic("no return value specified for TournamentRecordsHaystack")
	}

	var r0 *api.TournamentRecordList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) (*api.TournamentRecordList, error)); ok {
		return rf(ctx, id, ownerID, limit, cursor, expiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) *api.TournamentRecordList); ok {
		r0 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.TournamentRecordList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int, string, int64) error); ok {
		r1 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_TournamentRecordsHaystack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentRecordsHaystack'
type NakamaModule_TournamentRecordsHaystack_Call struct {
	*mock.Call
}

// TournamentRecordsHaystack is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - limit int
//   - cursor string
//   - expiry int64
func (_e *NakamaModule_Expecter) TournamentRecordsHaystack(ctx interface{}, id interface{}, ownerID interface{}, limit interface{}, cursor interface{}, expiry interface{}) *NakamaModule_TournamentRecordsHaystack_Call {
	return &NakamaModule_TournamentRecordsHaystack_Call{Call: _e.mock.On("TournamentRecordsHaystack", ctx, id, ownerID, limit, cursor, expiry)}
}

func (_c *NakamaModule_TournamentRecordsHaystack_Call) Run(run func(ctx context.Context, id string, ownerID string, limit int, cursor string, expiry int64)) *NakamaModule_TournamentRecordsHaystack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(string), args[5].(int64))
	})
	return _c
}

func (_c *NakamaModule_TournamentRecordsHaystack_Call) Return(_a0 *api.TournamentRecordList, _a1 error) *NakamaModule_TournamentRecordsHaystack_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_TournamentRecordsHaystack_Call) RunAndReturn(run func(context.Context, string, string, int, string, int64) (*api.TournamentRecordList, error)) *NakamaModule_TournamentRecordsHaystack_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentRecordsList provides a mock function with given fields: ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry
func (_m *NakamaModule) TournamentRecordsList(ctx context.Context, tournamentId string, ownerIDs []string, limit int, cursor string, overrideExpiry int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error) {
	ret := _m.Called(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)

	if len(ret) == 0 {
		panic("no return value specified for TournamentRecordsList")
	}

	var r0 []*api.LeaderboardRecord
	var r1 []*api.LeaderboardRecord
	var r2 string
	var r3 string
	var r4 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error)); ok {
		return rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r0 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r1 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, []string, int, string, int64) string); ok {
		r2 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, []string, int, string, int64) string); ok {
		r3 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		r3 = ret.Get(3).(string)
	}

	if rf, ok := ret.Get(4).(func(context.Context, string, []string, int, string, int64) error); ok {
		r4 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// NakamaModule_TournamentRecordsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentRecordsList'
type NakamaModule_TournamentRecordsList_Call struct {
	*mock.Call
}

// TournamentRecordsList is a helper method to define mock.On call
//   - ctx context.Context
//   - tournamentId string
//   - ownerIDs []string
//   - limit int
//   - cursor string
//   - overrideExpiry int64
func (_e *NakamaModule_Expecter) TournamentRecordsList(ctx interface{}, tournamentId interface{}, ownerIDs interface{}, limit interface{}, cursor interface{}, overrideExpiry interface{}) *NakamaModule_TournamentRecordsList_Call {
	return &NakamaModule_TournamentRecordsList_Call{Call: _e.mock.On("TournamentRecordsList", ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)}
}

func (_c *NakamaModule_TournamentRecordsList_Call) Run(run func(ctx context.Context, tournamentId string, ownerIDs []string, limit int, cursor string, overrideExpiry int64)) *NakamaModule_TournamentRecordsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(int), args[4].(string), args[5].(int64))
	})
	return _c
}

func (_c *NakamaModule_TournamentRecordsList_Call) Return(records []*api.LeaderboardRecord, ownerRecords []*api.LeaderboardRecord, prevCursor string, nextCursor string, err error) *NakamaModule_TournamentRecordsList_Call {
	_c.Call.Return(records, ownerRecords, prevCursor, nextCursor, err)
	return _c
}

func (_c *NakamaModule_TournamentRecordsList_Call) RunAndReturn(run func(context.Context, string, []string, int, string, int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error)) *NakamaModule_TournamentRecordsList_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentsGetId provides a mock function with given fields: ctx, tournamentIDs
func (_m *NakamaModule) TournamentsGetId(ctx context.Context, tournamentIDs []string) ([]*api.Tournament, error) {
	ret := _m.Called(ctx, tournamentIDs)

	if len(ret) == 0 {
		panic("no return value specified for TournamentsGetId")
	}

	var r0 []*api.Tournament
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Tournament, error)); ok {
		return rf(ctx, tournamentIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Tournament); ok {
		r0 = rf(ctx, tournamentIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Tournament)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, tournamentIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_TournamentsGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentsGetId'
type NakamaModule_TournamentsGetId_Call struct {
	*mock.Call
}

// TournamentsGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - tournamentIDs []string
func (_e *NakamaModule_Expecter) TournamentsGetId(ctx interface{}, tournamentIDs interface{}) *NakamaModule_TournamentsGetId_Call {
	return &NakamaModule_TournamentsGetId_Call{Call: _e.mock.On("TournamentsGetId", ctx, tournamentIDs)}
}

func (_c *NakamaModule_TournamentsGetId_Call) Run(run func(ctx context.Context, tournamentIDs []string)) *NakamaModule_TournamentsGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *NakamaModule_TournamentsGetId_Call) Return(_a0 []*api.Tournament, _a1 error) *NakamaModule_TournamentsGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_TournamentsGetId_Call) RunAndReturn(run func(context.Context, []string) ([]*api.Tournament, error)) *NakamaModule_TournamentsGetId_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkApple provides a mock function with given fields: ctx, userID, token
func (_m *NakamaModule) UnlinkApple(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkApple")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UnlinkApple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkApple'
type NakamaModule_UnlinkApple_Call struct {
	*mock.Call
}

// UnlinkApple is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *NakamaModule_Expecter) UnlinkApple(ctx interface{}, userID interface{}, token interface{}) *NakamaModule_UnlinkApple_Call {
	return &NakamaModule_UnlinkApple_Call{Call: _e.mock.On("UnlinkApple", ctx, userID, token)}
}

func (_c *NakamaModule_UnlinkApple_Call) Run(run func(ctx context.Context, userID string, token string)) *NakamaModule_UnlinkApple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_UnlinkApple_Call) Return(_a0 error) *NakamaModule_UnlinkApple_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UnlinkApple_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_UnlinkApple_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkCustom provides a mock function with given fields: ctx, userID, customID
func (_m *NakamaModule) UnlinkCustom(ctx context.Context, userID string, customID string) error {
	ret := _m.Called(ctx, userID, customID)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkCustom")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, customID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UnlinkCustom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkCustom'
type NakamaModule_UnlinkCustom_Call struct {
	*mock.Call
}

// UnlinkCustom is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - customID string
func (_e *NakamaModule_Expecter) UnlinkCustom(ctx interface{}, userID interface{}, customID interface{}) *NakamaModule_UnlinkCustom_Call {
	return &NakamaModule_UnlinkCustom_Call{Call: _e.mock.On("UnlinkCustom", ctx, userID, customID)}
}

func (_c *NakamaModule_UnlinkCustom_Call) Run(run func(ctx context.Context, userID string, customID string)) *NakamaModule_UnlinkCustom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_UnlinkCustom_Call) Return(_a0 error) *NakamaModule_UnlinkCustom_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UnlinkCustom_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_UnlinkCustom_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkDevice provides a mock function with given fields: ctx, userID, deviceID
func (_m *NakamaModule) UnlinkDevice(ctx context.Context, userID string, deviceID string) error {
	ret := _m.Called(ctx, userID, deviceID)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkDevice")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, deviceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UnlinkDevice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkDevice'
type NakamaModule_UnlinkDevice_Call struct {
	*mock.Call
}

// UnlinkDevice is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - deviceID string
func (_e *NakamaModule_Expecter) UnlinkDevice(ctx interface{}, userID interface{}, deviceID interface{}) *NakamaModule_UnlinkDevice_Call {
	return &NakamaModule_UnlinkDevice_Call{Call: _e.mock.On("UnlinkDevice", ctx, userID, deviceID)}
}

func (_c *NakamaModule_UnlinkDevice_Call) Run(run func(ctx context.Context, userID string, deviceID string)) *NakamaModule_UnlinkDevice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_UnlinkDevice_Call) Return(_a0 error) *NakamaModule_UnlinkDevice_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UnlinkDevice_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_UnlinkDevice_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkEmail provides a mock function with given fields: ctx, userID, email
func (_m *NakamaModule) UnlinkEmail(ctx context.Context, userID string, email string) error {
	ret := _m.Called(ctx, userID, email)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkEmail")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, email)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UnlinkEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkEmail'
type NakamaModule_UnlinkEmail_Call struct {
	*mock.Call
}

// UnlinkEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - email string
func (_e *NakamaModule_Expecter) UnlinkEmail(ctx interface{}, userID interface{}, email interface{}) *NakamaModule_UnlinkEmail_Call {
	return &NakamaModule_UnlinkEmail_Call{Call: _e.mock.On("UnlinkEmail", ctx, userID, email)}
}

func (_c *NakamaModule_UnlinkEmail_Call) Run(run func(ctx context.Context, userID string, email string)) *NakamaModule_UnlinkEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_UnlinkEmail_Call) Return(_a0 error) *NakamaModule_UnlinkEmail_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UnlinkEmail_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_UnlinkEmail_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkFacebook provides a mock function with given fields: ctx, userID, token
func (_m *NakamaModule) UnlinkFacebook(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkFacebook")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UnlinkFacebook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkFacebook'
type NakamaModule_UnlinkFacebook_Call struct {
	*mock.Call
}

// UnlinkFacebook is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *NakamaModule_Expecter) UnlinkFacebook(ctx interface{}, userID interface{}, token interface{}) *NakamaModule_UnlinkFacebook_Call {
	return &NakamaModule_UnlinkFacebook_Call{Call: _e.mock.On("UnlinkFacebook", ctx, userID, token)}
}

func (_c *NakamaModule_UnlinkFacebook_Call) Run(run func(ctx context.Context, userID string, token string)) *NakamaModule_UnlinkFacebook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_UnlinkFacebook_Call) Return(_a0 error) *NakamaModule_UnlinkFacebook_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UnlinkFacebook_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_UnlinkFacebook_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkFacebookInstantGame provides a mock function with given fields: ctx, userID, signedPlayerInfo
func (_m *NakamaModule) UnlinkFacebookInstantGame(ctx context.Context, userID string, signedPlayerInfo string) error {
	ret := _m.Called(ctx, userID, signedPlayerInfo)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkFacebookInstantGame")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, signedPlayerInfo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UnlinkFacebookInstantGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkFacebookInstantGame'
type NakamaModule_UnlinkFacebookInstantGame_Call struct {
	*mock.Call
}

// UnlinkFacebookInstantGame is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - signedPlayerInfo string
func (_e *NakamaModule_Expecter) UnlinkFacebookInstantGame(ctx interface{}, userID interface{}, signedPlayerInfo interface{}) *NakamaModule_UnlinkFacebookInstantGame_Call {
	return &NakamaModule_UnlinkFacebookInstantGame_Call{Call: _e.mock.On("UnlinkFacebookInstantGame", ctx, userID, signedPlayerInfo)}
}

func (_c *NakamaModule_UnlinkFacebookInstantGame_Call) Run(run func(ctx context.Context, userID string, signedPlayerInfo string)) *NakamaModule_UnlinkFacebookInstantGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_UnlinkFacebookInstantGame_Call) Return(_a0 error) *NakamaModule_UnlinkFacebookInstantGame_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UnlinkFacebookInstantGame_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_UnlinkFacebookInstantGame_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkGameCenter provides a mock function with given fields: ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl
func (_m *NakamaModule) UnlinkGameCenter(ctx context.Context, userID string, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string) error {
	ret := _m.Called(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkGameCenter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, string, string, string) error); ok {
		r0 = rf(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UnlinkGameCenter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkGameCenter'
type NakamaModule_UnlinkGameCenter_Call struct {
	*mock.Call
}

// UnlinkGameCenter is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - playerID string
//   - bundleID string
//   - timestamp int64
//   - salt string
//   - signature string
//   - publicKeyUrl string
func (_e *NakamaModule_Expecter) UnlinkGameCenter(ctx interface{}, userID interface{}, playerID interface{}, bundleID interface{}, timestamp interface{}, salt interface{}, signature interface{}, publicKeyUrl interface{}) *NakamaModule_UnlinkGameCenter_Call {
	return &NakamaModule_UnlinkGameCenter_Call{Call: _e.mock.On("UnlinkGameCenter", ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)}
}

func (_c *NakamaModule_UnlinkGameCenter_Call) Run(run func(ctx context.Context, userID string, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string)) *NakamaModule_UnlinkGameCenter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64), args[5].(string), args[6].(string), args[7].(string))
	})
	return _c
}

func (_c *NakamaModule_UnlinkGameCenter_Call) Return(_a0 error) *NakamaModule_UnlinkGameCenter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UnlinkGameCenter_Call) RunAndReturn(run func(context.Context, string, string, string, int64, string, string, string) error) *NakamaModule_UnlinkGameCenter_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkGoogle provides a mock function with given fields: ctx, userID, token
func (_m *NakamaModule) UnlinkGoogle(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkGoogle")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UnlinkGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkGoogle'
type NakamaModule_UnlinkGoogle_Call struct {
	*mock.Call
}

// UnlinkGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *NakamaModule_Expecter) UnlinkGoogle(ctx interface{}, userID interface{}, token interface{}) *NakamaModule_UnlinkGoogle_Call {
	return &NakamaModule_UnlinkGoogle_Call{Call: _e.mock.On("UnlinkGoogle", ctx, userID, token)}
}

func (_c *NakamaModule_UnlinkGoogle_Call) Run(run func(ctx context.Context, userID string, token string)) *NakamaModule_UnlinkGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_UnlinkGoogle_Call) Return(_a0 error) *NakamaModule_UnlinkGoogle_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UnlinkGoogle_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_UnlinkGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkSteam provides a mock function with given fields: ctx, userID, token
func (_m *NakamaModule) UnlinkSteam(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkSteam")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UnlinkSteam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkSteam'
type NakamaModule_UnlinkSteam_Call struct {
	*mock.Call
}

// UnlinkSteam is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *NakamaModule_Expecter) UnlinkSteam(ctx interface{}, userID interface{}, token interface{}) *NakamaModule_UnlinkSteam_Call {
	return &NakamaModule_UnlinkSteam_Call{Call: _e.mock.On("UnlinkSteam", ctx, userID, token)}
}

func (_c *NakamaModule_UnlinkSteam_Call) Run(run func(ctx context.Context, userID string, token string)) *NakamaModule_UnlinkSteam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *NakamaModule_UnlinkSteam_Call) Return(_a0 error) *NakamaModule_UnlinkSteam_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UnlinkSteam_Call) RunAndReturn(run func(context.Context, string, string) error) *NakamaModule_UnlinkSteam_Call {
	_c.Call.Return(run)
	return _c
}

// UserGroupsList provides a mock function with given fields: ctx, userID, limit, state, cursor
func (_m *NakamaModule) UserGroupsList(ctx context.Context, userID string, limit int, state *int, cursor string) ([]*api.UserGroupList_UserGroup, string, error) {
	ret := _m.Called(ctx, userID, limit, state, cursor)

	if len(ret) == 0 {
		panic("no return value specified for UserGroupsList")
	}

	var r0 []*api.UserGroupList_UserGroup
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) ([]*api.UserGroupList_UserGroup, string, error)); ok {
		return rf(ctx, userID, limit, state, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) []*api.UserGroupList_UserGroup); ok {
		r0 = rf(ctx, userID, limit, state, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.UserGroupList_UserGroup)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *int, string) string); ok {
		r1 = rf(ctx, userID, limit, state, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, *int, string) error); ok {
		r2 = rf(ctx, userID, limit, state, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NakamaModule_UserGroupsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserGroupsList'
type NakamaModule_UserGroupsList_Call struct {
	*mock.Call
}

// UserGroupsList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - state *int
//   - cursor string
func (_e *NakamaModule_Expecter) UserGroupsList(ctx interface{}, userID interface{}, limit interface{}, state interface{}, cursor interface{}) *NakamaModule_UserGroupsList_Call {
	return &NakamaModule_UserGroupsList_Call{Call: _e.mock.On("UserGroupsList", ctx, userID, limit, state, cursor)}
}

func (_c *NakamaModule_UserGroupsList_Call) Run(run func(ctx context.Context, userID string, limit int, state *int, cursor string)) *NakamaModule_UserGroupsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*int), args[4].(string))
	})
	return _c
}

func (_c *NakamaModule_UserGroupsList_Call) Return(_a0 []*api.UserGroupList_UserGroup, _a1 string, _a2 error) *NakamaModule_UserGroupsList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NakamaModule_UserGroupsList_Call) RunAndReturn(run func(context.Context, string, int, *int, string) ([]*api.UserGroupList_UserGroup, string, error)) *NakamaModule_UserGroupsList_Call {
	_c.Call.Return(run)
	return _c
}

// UsersBanId provides a mock function with given fields: ctx, userIDs
func (_m *NakamaModule) UsersBanId(ctx context.Context, userIDs []string) error {
	ret := _m.Called(ctx, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for UsersBanId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UsersBanId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersBanId'
type NakamaModule_UsersBanId_Call struct {
	*mock.Call
}

// UsersBanId is a helper method to define mock.On call
//   - ctx context.Context
//   - userIDs []string
func (_e *NakamaModule_Expecter) UsersBanId(ctx interface{}, userIDs interface{}) *NakamaModule_UsersBanId_Call {
	return &NakamaModule_UsersBanId_Call{Call: _e.mock.On("UsersBanId", ctx, userIDs)}
}

func (_c *NakamaModule_UsersBanId_Call) Run(run func(ctx context.Context, userIDs []string)) *NakamaModule_UsersBanId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *NakamaModule_UsersBanId_Call) Return(_a0 error) *NakamaModule_UsersBanId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UsersBanId_Call) RunAndReturn(run func(context.Context, []string) error) *NakamaModule_UsersBanId_Call {
	_c.Call.Return(run)
	return _c
}

// UsersGetId provides a mock function with given fields: ctx, userIDs, facebookIDs
func (_m *NakamaModule) UsersGetId(ctx context.Context, userIDs []string, facebookIDs []string) ([]*api.User, error) {
	ret := _m.Called(ctx, userIDs, facebookIDs)

	if len(ret) == 0 {
		panic("no return value specified for UsersGetId")
	}

	var r0 []*api.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, []string) ([]*api.User, error)); ok {
		return rf(ctx, userIDs, facebookIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, []string) []*api.User); ok {
		r0 = rf(ctx, userIDs, facebookIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, []string) error); ok {
		r1 = rf(ctx, userIDs, facebookIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_UsersGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersGetId'
type NakamaModule_UsersGetId_Call struct {
	*mock.Call
}

// UsersGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - userIDs []string
//   - facebookIDs []string
func (_e *NakamaModule_Expecter) UsersGetId(ctx interface{}, userIDs interface{}, facebookIDs interface{}) *NakamaModule_UsersGetId_Call {
	return &NakamaModule_UsersGetId_Call{Call: _e.mock.On("UsersGetId", ctx, userIDs, facebookIDs)}
}

func (_c *NakamaModule_UsersGetId_Call) Run(run func(ctx context.Context, userIDs []string, facebookIDs []string)) *NakamaModule_UsersGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].([]string))
	})
	return _c
}

func (_c *NakamaModule_UsersGetId_Call) Return(_a0 []*api.User, _a1 error) *NakamaModule_UsersGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_UsersGetId_Call) RunAndReturn(run func(context.Context, []string, []string) ([]*api.User, error)) *NakamaModule_UsersGetId_Call {
	_c.Call.Return(run)
	return _c
}

// UsersGetRandom provides a mock function with given fields: ctx, count
func (_m *NakamaModule) UsersGetRandom(ctx context.Context, count int) ([]*api.User, error) {
	ret := _m.Called(ctx, count)

	if len(ret) == 0 {
		panic("no return value specified for UsersGetRandom")
	}

	var r0 []*api.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*api.User, error)); ok {
		return rf(ctx, count)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*api.User); ok {
		r0 = rf(ctx, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_UsersGetRandom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersGetRandom'
type NakamaModule_UsersGetRandom_Call struct {
	*mock.Call
}

// UsersGetRandom is a helper method to define mock.On call
//   - ctx context.Context
//   - count int
func (_e *NakamaModule_Expecter) UsersGetRandom(ctx interface{}, count interface{}) *NakamaModule_UsersGetRandom_Call {
	return &NakamaModule_UsersGetRandom_Call{Call: _e.mock.On("UsersGetRandom", ctx, count)}
}

func (_c *NakamaModule_UsersGetRandom_Call) Run(run func(ctx context.Context, count int)) *NakamaModule_UsersGetRandom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *NakamaModule_UsersGetRandom_Call) Return(_a0 []*api.User, _a1 error) *NakamaModule_UsersGetRandom_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_UsersGetRandom_Call) RunAndReturn(run func(context.Context, int) ([]*api.User, error)) *NakamaModule_UsersGetRandom_Call {
	_c.Call.Return(run)
	return _c
}

// UsersGetUsername provides a mock function with given fields: ctx, usernames
func (_m *NakamaModule) UsersGetUsername(ctx context.Context, usernames []string) ([]*api.User, error) {
	ret := _m.Called(ctx, usernames)

	if len(ret) == 0 {
		panic("no return value specified for UsersGetUsername")
	}

	var r0 []*api.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.User, error)); ok {
		return rf(ctx, usernames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.User); ok {
		r0 = rf(ctx, usernames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, usernames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_UsersGetUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersGetUsername'
type NakamaModule_UsersGetUsername_Call struct {
	*mock.Call
}

// UsersGetUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - usernames []string
func (_e *NakamaModule_Expecter) UsersGetUsername(ctx interface{}, usernames interface{}) *NakamaModule_UsersGetUsername_Call {
	return &NakamaModule_UsersGetUsername_Call{Call: _e.mock.On("UsersGetUsername", ctx, usernames)}
}

func (_c *NakamaModule_UsersGetUsername_Call) Run(run func(ctx context.Context, usernames []string)) *NakamaModule_UsersGetUsername_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *NakamaModule_UsersGetUsername_Call) Return(_a0 []*api.User, _a1 error) *NakamaModule_UsersGetUsername_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_UsersGetUsername_Call) RunAndReturn(run func(context.Context, []string) ([]*api.User, error)) *NakamaModule_UsersGetUsername_Call {
	_c.Call.Return(run)
	return _c
}

// UsersUnbanId provides a mock function with given fields: ctx, userIDs
func (_m *NakamaModule) UsersUnbanId(ctx context.Context, userIDs []string) error {
	ret := _m.Called(ctx, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for UsersUnbanId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NakamaModule_UsersUnbanId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersUnbanId'
type NakamaModule_UsersUnbanId_Call struct {
	*mock.Call
}

// UsersUnbanId is a helper method to define mock.On call
//   - ctx context.Context
//   - userIDs []string
func (_e *NakamaModule_Expecter) UsersUnbanId(ctx interface{}, userIDs interface{}) *NakamaModule_UsersUnbanId_Call {
	return &NakamaModule_UsersUnbanId_Call{Call: _e.mock.On("UsersUnbanId", ctx, userIDs)}
}

func (_c *NakamaModule_UsersUnbanId_Call) Run(run func(ctx context.Context, userIDs []string)) *NakamaModule_UsersUnbanId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *NakamaModule_UsersUnbanId_Call) Return(_a0 error) *NakamaModule_UsersUnbanId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *NakamaModule_UsersUnbanId_Call) RunAndReturn(run func(context.Context, []string) error) *NakamaModule_UsersUnbanId_Call {
	_c.Call.Return(run)
	return _c
}

// WalletLedgerList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *NakamaModule) WalletLedgerList(ctx context.Context, userID string, limit int, cursor string) ([]runtime.WalletLedgerItem, string, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for WalletLedgerList")
	}

	var r0 []runtime.WalletLedgerItem
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) ([]runtime.WalletLedgerItem, string, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) []runtime.WalletLedgerItem); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.WalletLedgerItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) string); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, string) error); ok {
		r2 = rf(ctx, userID, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NakamaModule_WalletLedgerList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletLedgerList'
type NakamaModule_WalletLedgerList_Call struct {
	*mock.Call
}

// WalletLedgerList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - cursor string
func (_e *NakamaModule_Expecter) WalletLedgerList(ctx interface{}, userID interface{}, limit interface{}, cursor interface{}) *NakamaModule_WalletLedgerList_Call {
	return &NakamaModule_WalletLedgerList_Call{Call: _e.mock.On("WalletLedgerList", ctx, userID, limit, cursor)}
}

func (_c *NakamaModule_WalletLedgerList_Call) Run(run func(ctx context.Context, userID string, limit int, cursor string)) *NakamaModule_WalletLedgerList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *NakamaModule_WalletLedgerList_Call) Return(_a0 []runtime.WalletLedgerItem, _a1 string, _a2 error) *NakamaModule_WalletLedgerList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NakamaModule_WalletLedgerList_Call) RunAndReturn(run func(context.Context, string, int, string) ([]runtime.WalletLedgerItem, string, error)) *NakamaModule_WalletLedgerList_Call {
	_c.Call.Return(run)
	return _c
}

// WalletLedgerUpdate provides a mock function with given fields: ctx, itemID, metadata
func (_m *NakamaModule) WalletLedgerUpdate(ctx context.Context, itemID string, metadata map[string]interface{}) (runtime.WalletLedgerItem, error) {
	ret := _m.Called(ctx, itemID, metadata)

	if len(ret) == 0 {
		panic("no return value specified for WalletLedgerUpdate")
	}

	var r0 runtime.WalletLedgerItem
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) (runtime.WalletLedgerItem, error)); ok {
		return rf(ctx, itemID, metadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) runtime.WalletLedgerItem); ok {
		r0 = rf(ctx, itemID, metadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.WalletLedgerItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]interface{}) error); ok {
		r1 = rf(ctx, itemID, metadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_WalletLedgerUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletLedgerUpdate'
type NakamaModule_WalletLedgerUpdate_Call struct {
	*mock.Call
}

// WalletLedgerUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - itemID string
//   - metadata map[string]interface{}
func (_e *NakamaModule_Expecter) WalletLedgerUpdate(ctx interface{}, itemID interface{}, metadata interface{}) *NakamaModule_WalletLedgerUpdate_Call {
	return &NakamaModule_WalletLedgerUpdate_Call{Call: _e.mock.On("WalletLedgerUpdate", ctx, itemID, metadata)}
}

func (_c *NakamaModule_WalletLedgerUpdate_Call) Run(run func(ctx context.Context, itemID string, metadata map[string]interface{})) *NakamaModule_WalletLedgerUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]interface{}))
	})
	return _c
}

func (_c *NakamaModule_WalletLedgerUpdate_Call) Return(_a0 runtime.WalletLedgerItem, _a1 error) *NakamaModule_WalletLedgerUpdate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_WalletLedgerUpdate_Call) RunAndReturn(run func(context.Context, string, map[string]interface{}) (runtime.WalletLedgerItem, error)) *NakamaModule_WalletLedgerUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// WalletUpdate provides a mock function with given fields: ctx, userID, changeset, metadata, updateLedger
func (_m *NakamaModule) WalletUpdate(ctx context.Context, userID string, changeset map[string]int64, metadata map[string]interface{}, updateLedger bool) (map[string]int64, map[string]int64, error) {
	ret := _m.Called(ctx, userID, changeset, metadata, updateLedger)

	if len(ret) == 0 {
		panic("no return value specified for WalletUpdate")
	}

	var r0 map[string]int64
	var r1 map[string]int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) (map[string]int64, map[string]int64, error)); ok {
		return rf(ctx, userID, changeset, metadata, updateLedger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) map[string]int64); ok {
		r0 = rf(ctx, userID, changeset, metadata, updateLedger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) map[string]int64); ok {
		r1 = rf(ctx, userID, changeset, metadata, updateLedger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[string]int64)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) error); ok {
		r2 = rf(ctx, userID, changeset, metadata, updateLedger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NakamaModule_WalletUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletUpdate'
type NakamaModule_WalletUpdate_Call struct {
	*mock.Call
}

// WalletUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - changeset map[string]int64
//   - metadata map[string]interface{}
//   - updateLedger bool
func (_e *NakamaModule_Expecter) WalletUpdate(ctx interface{}, userID interface{}, changeset interface{}, metadata interface{}, updateLedger interface{}) *NakamaModule_WalletUpdate_Call {
	return &NakamaModule_WalletUpdate_Call{Call: _e.mock.On("WalletUpdate", ctx, userID, changeset, metadata, updateLedger)}
}

func (_c *NakamaModule_WalletUpdate_Call) Run(run func(ctx context.Context, userID string, changeset map[string]int64, metadata map[string]interface{}, updateLedger bool)) *NakamaModule_WalletUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]int64), args[3].(map[string]interface{}), args[4].(bool))
	})
	return _c
}

func (_c *NakamaModule_WalletUpdate_Call) Return(updated map[string]int64, previous map[string]int64, err error) *NakamaModule_WalletUpdate_Call {
	_c.Call.Return(updated, previous, err)
	return _c
}

func (_c *NakamaModule_WalletUpdate_Call) RunAndReturn(run func(context.Context, string, map[string]int64, map[string]interface{}, bool) (map[string]int64, map[string]int64, error)) *NakamaModule_WalletUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// WalletsUpdate provides a mock function with given fields: ctx, updates, updateLedger
func (_m *NakamaModule) WalletsUpdate(ctx context.Context, updates []*runtime.WalletUpdate, updateLedger bool) ([]*runtime.WalletUpdateResult, error) {
	ret := _m.Called(ctx, updates, updateLedger)

	if len(ret) == 0 {
		panic("no return value specified for WalletsUpdate")
	}

	var r0 []*runtime.WalletUpdateResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.WalletUpdate, bool) ([]*runtime.WalletUpdateResult, error)); ok {
		return rf(ctx, updates, updateLedger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.WalletUpdate, bool) []*runtime.WalletUpdateResult); ok {
		r0 = rf(ctx, updates, updateLedger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*runtime.WalletUpdateResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.WalletUpdate, bool) error); ok {
		r1 = rf(ctx, updates, updateLedger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NakamaModule_WalletsUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletsUpdate'
type NakamaModule_WalletsUpdate_Call struct {
	*mock.Call
}

// WalletsUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - updates []*runtime.WalletUpdate
//   - updateLedger bool
func (_e *NakamaModule_Expecter) WalletsUpdate(ctx interface{}, updates interface{}, updateLedger interface{}) *NakamaModule_WalletsUpdate_Call {
	return &NakamaModule_WalletsUpdate_Call{Call: _e.mock.On("WalletsUpdate", ctx, updates, updateLedger)}
}

func (_c *NakamaModule_WalletsUpdate_Call) Run(run func(ctx context.Context, updates []*runtime.WalletUpdate, updateLedger bool)) *NakamaModule_WalletsUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.WalletUpdate), args[2].(bool))
	})
	return _c
}

func (_c *NakamaModule_WalletsUpdate_Call) Return(_a0 []*runtime.WalletUpdateResult, _a1 error) *NakamaModule_WalletsUpdate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NakamaModule_WalletsUpdate_Call) RunAndReturn(run func(context.Context, []*runtime.WalletUpdate, bool) ([]*runtime.WalletUpdateResult, error)) *NakamaModule_WalletsUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// NewNakamaModule creates a new instance of NakamaModule. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNakamaModule(t interface {
	mock.TestingT
	Cleanup(func())
}) *NakamaModule {
	mock := &NakamaModule{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
