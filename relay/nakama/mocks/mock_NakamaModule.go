// Code generated by mockery v2.23.1. DO NOT EDIT.

package mocks

import (
	context "context"

	api "github.com/heroiclabs/nakama-common/api"

	mock "github.com/stretchr/testify/mock"

	os "os"

	rtapi "github.com/heroiclabs/nakama-common/rtapi"

	runtime "github.com/heroiclabs/nakama-common/runtime"

	time "time"
)

// MockNakamaModule is an autogenerated mock type for the NakamaModule type
type MockNakamaModule struct {
	mock.Mock
}

// AccountDeleteId provides a mock function with given fields: ctx, userID, recorded
func (_m *MockNakamaModule) AccountDeleteId(ctx context.Context, userID string, recorded bool) error {
	ret := _m.Called(ctx, userID, recorded)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = rf(ctx, userID, recorded)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AccountExportId provides a mock function with given fields: ctx, userID
func (_m *MockNakamaModule) AccountExportId(ctx context.Context, userID string) (string, error) {
	ret := _m.Called(ctx, userID)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountGetId provides a mock function with given fields: ctx, userID
func (_m *MockNakamaModule) AccountGetId(ctx context.Context, userID string) (*api.Account, error) {
	ret := _m.Called(ctx, userID)

	var r0 *api.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*api.Account, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.Account); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountUpdateId provides a mock function with given fields: ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl
func (_m *MockNakamaModule) AccountUpdateId(ctx context.Context, userID string, username string, metadata map[string]interface{}, displayName string, timezone string, location string, langTag string, avatarUrl string) error {
	ret := _m.Called(ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, string, string, string, string, string) error); ok {
		r0 = rf(ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AccountsGetId provides a mock function with given fields: ctx, userIDs
func (_m *MockNakamaModule) AccountsGetId(ctx context.Context, userIDs []string) ([]*api.Account, error) {
	ret := _m.Called(ctx, userIDs)

	var r0 []*api.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Account, error)); ok {
		return rf(ctx, userIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Account); ok {
		r0 = rf(ctx, userIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, userIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthenticateApple provides a mock function with given fields: ctx, token, username, create
func (_m *MockNakamaModule) AuthenticateApple(ctx context.Context, token string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, username, create)

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, token, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, token, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, token, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, token, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// AuthenticateCustom provides a mock function with given fields: ctx, id, username, create
func (_m *MockNakamaModule) AuthenticateCustom(ctx context.Context, id string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, id, username, create)

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, id, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, id, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, id, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, id, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, id, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// AuthenticateDevice provides a mock function with given fields: ctx, id, username, create
func (_m *MockNakamaModule) AuthenticateDevice(ctx context.Context, id string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, id, username, create)

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, id, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, id, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, id, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, id, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, id, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// AuthenticateEmail provides a mock function with given fields: ctx, email, password, username, create
func (_m *MockNakamaModule) AuthenticateEmail(ctx context.Context, email string, password string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, email, password, username, create)

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, email, password, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) string); ok {
		r0 = rf(ctx, email, password, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, bool) string); ok {
		r1 = rf(ctx, email, password, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, bool) bool); ok {
		r2 = rf(ctx, email, password, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, string, bool) error); ok {
		r3 = rf(ctx, email, password, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// AuthenticateFacebook provides a mock function with given fields: ctx, token, importFriends, username, create
func (_m *MockNakamaModule) AuthenticateFacebook(ctx context.Context, token string, importFriends bool, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, importFriends, username, create)

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, importFriends, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, bool) string); ok {
		r0 = rf(ctx, token, importFriends, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool, string, bool) string); ok {
		r1 = rf(ctx, token, importFriends, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, bool, string, bool) bool); ok {
		r2 = rf(ctx, token, importFriends, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, bool, string, bool) error); ok {
		r3 = rf(ctx, token, importFriends, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// AuthenticateFacebookInstantGame provides a mock function with given fields: ctx, signedPlayerInfo, username, create
func (_m *MockNakamaModule) AuthenticateFacebookInstantGame(ctx context.Context, signedPlayerInfo string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, signedPlayerInfo, username, create)

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, signedPlayerInfo, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// AuthenticateGameCenter provides a mock function with given fields: ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create
func (_m *MockNakamaModule) AuthenticateGameCenter(ctx context.Context, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, string, string, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, string, string, string, string, bool) string); ok {
		r0 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int64, string, string, string, string, bool) string); ok {
		r1 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, int64, string, string, string, string, bool) bool); ok {
		r2 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, int64, string, string, string, string, bool) error); ok {
		r3 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// AuthenticateGoogle provides a mock function with given fields: ctx, token, username, create
func (_m *MockNakamaModule) AuthenticateGoogle(ctx context.Context, token string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, username, create)

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, token, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, token, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, token, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, token, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// AuthenticateSteam provides a mock function with given fields: ctx, token, username, create
func (_m *MockNakamaModule) AuthenticateSteam(ctx context.Context, token string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, username, create)

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, token, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, token, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, token, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, token, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// AuthenticateTokenGenerate provides a mock function with given fields: userID, username, exp, vars
func (_m *MockNakamaModule) AuthenticateTokenGenerate(userID string, username string, exp int64, vars map[string]string) (string, int64, error) {
	ret := _m.Called(userID, username, exp, vars)

	var r0 string
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, int64, map[string]string) (string, int64, error)); ok {
		return rf(userID, username, exp, vars)
	}
	if rf, ok := ret.Get(0).(func(string, string, int64, map[string]string) string); ok {
		r0 = rf(userID, username, exp, vars)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string, int64, map[string]string) int64); ok {
		r1 = rf(userID, username, exp, vars)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(string, string, int64, map[string]string) error); ok {
		r2 = rf(userID, username, exp, vars)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ChannelIdBuild provides a mock function with given fields: ctx, sender, target, chanType
func (_m *MockNakamaModule) ChannelIdBuild(ctx context.Context, sender string, target string, chanType runtime.ChannelType) (string, error) {
	ret := _m.Called(ctx, sender, target, chanType)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, runtime.ChannelType) (string, error)); ok {
		return rf(ctx, sender, target, chanType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, runtime.ChannelType) string); ok {
		r0 = rf(ctx, sender, target, chanType)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, runtime.ChannelType) error); ok {
		r1 = rf(ctx, sender, target, chanType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageRemove provides a mock function with given fields: ctx, channelId, messageId, senderId, senderUsername, persist
func (_m *MockNakamaModule) ChannelMessageRemove(ctx context.Context, channelId string, messageId string, senderId string, senderUsername string, persist bool) (*rtapi.ChannelMessageAck, error) {
	ret := _m.Called(ctx, channelId, messageId, senderId, senderUsername, persist)

	var r0 *rtapi.ChannelMessageAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, bool) (*rtapi.ChannelMessageAck, error)); ok {
		return rf(ctx, channelId, messageId, senderId, senderUsername, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, bool) *rtapi.ChannelMessageAck); ok {
		r0 = rf(ctx, channelId, messageId, senderId, senderUsername, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtapi.ChannelMessageAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, bool) error); ok {
		r1 = rf(ctx, channelId, messageId, senderId, senderUsername, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageSend provides a mock function with given fields: ctx, channelID, content, senderId, senderUsername, persist
func (_m *MockNakamaModule) ChannelMessageSend(ctx context.Context, channelID string, content map[string]interface{}, senderId string, senderUsername string, persist bool) (*rtapi.ChannelMessageAck, error) {
	ret := _m.Called(ctx, channelID, content, senderId, senderUsername, persist)

	var r0 *rtapi.ChannelMessageAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, string, string, bool) (*rtapi.ChannelMessageAck, error)); ok {
		return rf(ctx, channelID, content, senderId, senderUsername, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, string, string, bool) *rtapi.ChannelMessageAck); ok {
		r0 = rf(ctx, channelID, content, senderId, senderUsername, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtapi.ChannelMessageAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]interface{}, string, string, bool) error); ok {
		r1 = rf(ctx, channelID, content, senderId, senderUsername, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageUpdate provides a mock function with given fields: ctx, channelID, messageID, content, senderId, senderUsername, persist
func (_m *MockNakamaModule) ChannelMessageUpdate(ctx context.Context, channelID string, messageID string, content map[string]interface{}, senderId string, senderUsername string, persist bool) (*rtapi.ChannelMessageAck, error) {
	ret := _m.Called(ctx, channelID, messageID, content, senderId, senderUsername, persist)

	var r0 *rtapi.ChannelMessageAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, string, string, bool) (*rtapi.ChannelMessageAck, error)); ok {
		return rf(ctx, channelID, messageID, content, senderId, senderUsername, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, string, string, bool) *rtapi.ChannelMessageAck); ok {
		r0 = rf(ctx, channelID, messageID, content, senderId, senderUsername, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtapi.ChannelMessageAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, map[string]interface{}, string, string, bool) error); ok {
		r1 = rf(ctx, channelID, messageID, content, senderId, senderUsername, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessagesList provides a mock function with given fields: ctx, channelId, limit, forward, cursor
func (_m *MockNakamaModule) ChannelMessagesList(ctx context.Context, channelId string, limit int, forward bool, cursor string) ([]*api.ChannelMessage, string, string, error) {
	ret := _m.Called(ctx, channelId, limit, forward, cursor)

	var r0 []*api.ChannelMessage
	var r1 string
	var r2 string
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, bool, string) ([]*api.ChannelMessage, string, string, error)); ok {
		return rf(ctx, channelId, limit, forward, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, bool, string) []*api.ChannelMessage); ok {
		r0 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.ChannelMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, bool, string) string); ok {
		r1 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, bool, string) string); ok {
		r2 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, int, bool, string) error); ok {
		r3 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// CronNext provides a mock function with given fields: expression, timestamp
func (_m *MockNakamaModule) CronNext(expression string, timestamp int64) (int64, error) {
	ret := _m.Called(expression, timestamp)

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int64) (int64, error)); ok {
		return rf(expression, timestamp)
	}
	if rf, ok := ret.Get(0).(func(string, int64) int64); ok {
		r0 = rf(expression, timestamp)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string, int64) error); ok {
		r1 = rf(expression, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CronPrev provides a mock function with given fields: expression, timestamp
func (_m *MockNakamaModule) CronPrev(expression string, timestamp int64) (int64, error) {
	ret := _m.Called(expression, timestamp)

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int64) (int64, error)); ok {
		return rf(expression, timestamp)
	}
	if rf, ok := ret.Get(0).(func(string, int64) int64); ok {
		r0 = rf(expression, timestamp)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string, int64) error); ok {
		r1 = rf(expression, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Event provides a mock function with given fields: ctx, evt
func (_m *MockNakamaModule) Event(ctx context.Context, evt *api.Event) error {
	ret := _m.Called(ctx, evt)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.Event) error); ok {
		r0 = rf(ctx, evt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FriendsAdd provides a mock function with given fields: ctx, userID, username, ids, usernames
func (_m *MockNakamaModule) FriendsAdd(ctx context.Context, userID string, username string, ids []string, usernames []string) error {
	ret := _m.Called(ctx, userID, username, ids, usernames)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, []string) error); ok {
		r0 = rf(ctx, userID, username, ids, usernames)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FriendsBlock provides a mock function with given fields: ctx, userID, username, ids, usernames
func (_m *MockNakamaModule) FriendsBlock(ctx context.Context, userID string, username string, ids []string, usernames []string) error {
	ret := _m.Called(ctx, userID, username, ids, usernames)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, []string) error); ok {
		r0 = rf(ctx, userID, username, ids, usernames)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FriendsDelete provides a mock function with given fields: ctx, userID, username, ids, usernames
func (_m *MockNakamaModule) FriendsDelete(ctx context.Context, userID string, username string, ids []string, usernames []string) error {
	ret := _m.Called(ctx, userID, username, ids, usernames)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, []string) error); ok {
		r0 = rf(ctx, userID, username, ids, usernames)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FriendsList provides a mock function with given fields: ctx, userID, limit, state, cursor
func (_m *MockNakamaModule) FriendsList(ctx context.Context, userID string, limit int, state *int, cursor string) ([]*api.Friend, string, error) {
	ret := _m.Called(ctx, userID, limit, state, cursor)

	var r0 []*api.Friend
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) ([]*api.Friend, string, error)); ok {
		return rf(ctx, userID, limit, state, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) []*api.Friend); ok {
		r0 = rf(ctx, userID, limit, state, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Friend)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *int, string) string); ok {
		r1 = rf(ctx, userID, limit, state, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, *int, string) error); ok {
		r2 = rf(ctx, userID, limit, state, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FriendsOfFriendsList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *MockNakamaModule) FriendsOfFriendsList(ctx context.Context, userID string, limit int, cursor string) ([]*api.FriendsOfFriendsList_FriendOfFriend, string, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	var r0 []*api.FriendsOfFriendsList_FriendOfFriend
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) ([]*api.FriendsOfFriendsList_FriendOfFriend, string, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) []*api.FriendsOfFriendsList_FriendOfFriend); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.FriendsOfFriendsList_FriendOfFriend)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) string); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, string) error); ok {
		r2 = rf(ctx, userID, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFleetManager provides a mock function with given fields:
func (_m *MockNakamaModule) GetFleetManager() runtime.FleetManager {
	ret := _m.Called()

	var r0 runtime.FleetManager
	if rf, ok := ret.Get(0).(func() runtime.FleetManager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.FleetManager)
		}
	}

	return r0
}

// GetSatori provides a mock function with given fields:
func (_m *MockNakamaModule) GetSatori() runtime.Satori {
	ret := _m.Called()

	var r0 runtime.Satori
	if rf, ok := ret.Get(0).(func() runtime.Satori); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.Satori)
		}
	}

	return r0
}

// GroupCreate provides a mock function with given fields: ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount
func (_m *MockNakamaModule) GroupCreate(ctx context.Context, userID string, name string, creatorID string, langTag string, description string, avatarUrl string, open bool, metadata map[string]interface{}, maxCount int) (*api.Group, error) {
	ret := _m.Called(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)

	var r0 *api.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) (*api.Group, error)); ok {
		return rf(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) *api.Group); ok {
		r0 = rf(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) error); ok {
		r1 = rf(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupDelete provides a mock function with given fields: ctx, id
func (_m *MockNakamaModule) GroupDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupUpdate provides a mock function with given fields: ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount
func (_m *MockNakamaModule) GroupUpdate(ctx context.Context, id string, userID string, name string, creatorID string, langTag string, description string, avatarUrl string, open bool, metadata map[string]interface{}, maxCount int) error {
	ret := _m.Called(ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, string, bool, map[string]interface{}, int) error); ok {
		r0 = rf(ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupUserJoin provides a mock function with given fields: ctx, groupID, userID, username
func (_m *MockNakamaModule) GroupUserJoin(ctx context.Context, groupID string, userID string, username string) error {
	ret := _m.Called(ctx, groupID, userID, username)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, groupID, userID, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupUserLeave provides a mock function with given fields: ctx, groupID, userID, username
func (_m *MockNakamaModule) GroupUserLeave(ctx context.Context, groupID string, userID string, username string) error {
	ret := _m.Called(ctx, groupID, userID, username)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, groupID, userID, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupUsersAdd provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *MockNakamaModule) GroupUsersAdd(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupUsersBan provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *MockNakamaModule) GroupUsersBan(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupUsersDemote provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *MockNakamaModule) GroupUsersDemote(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupUsersKick provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *MockNakamaModule) GroupUsersKick(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupUsersList provides a mock function with given fields: ctx, id, limit, state, cursor
func (_m *MockNakamaModule) GroupUsersList(ctx context.Context, id string, limit int, state *int, cursor string) ([]*api.GroupUserList_GroupUser, string, error) {
	ret := _m.Called(ctx, id, limit, state, cursor)

	var r0 []*api.GroupUserList_GroupUser
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) ([]*api.GroupUserList_GroupUser, string, error)); ok {
		return rf(ctx, id, limit, state, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) []*api.GroupUserList_GroupUser); ok {
		r0 = rf(ctx, id, limit, state, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.GroupUserList_GroupUser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *int, string) string); ok {
		r1 = rf(ctx, id, limit, state, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, *int, string) error); ok {
		r2 = rf(ctx, id, limit, state, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupUsersPromote provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *MockNakamaModule) GroupUsersPromote(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupsGetId provides a mock function with given fields: ctx, groupIDs
func (_m *MockNakamaModule) GroupsGetId(ctx context.Context, groupIDs []string) ([]*api.Group, error) {
	ret := _m.Called(ctx, groupIDs)

	var r0 []*api.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Group, error)); ok {
		return rf(ctx, groupIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Group); ok {
		r0 = rf(ctx, groupIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, groupIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsGetRandom provides a mock function with given fields: ctx, count
func (_m *MockNakamaModule) GroupsGetRandom(ctx context.Context, count int) ([]*api.Group, error) {
	ret := _m.Called(ctx, count)

	var r0 []*api.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*api.Group, error)); ok {
		return rf(ctx, count)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*api.Group); ok {
		r0 = rf(ctx, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsList provides a mock function with given fields: ctx, name, langTag, members, open, limit, cursor
func (_m *MockNakamaModule) GroupsList(ctx context.Context, name string, langTag string, members *int, open *bool, limit int, cursor string) ([]*api.Group, string, error) {
	ret := _m.Called(ctx, name, langTag, members, open, limit, cursor)

	var r0 []*api.Group
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *int, *bool, int, string) ([]*api.Group, string, error)); ok {
		return rf(ctx, name, langTag, members, open, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *int, *bool, int, string) []*api.Group); ok {
		r0 = rf(ctx, name, langTag, members, open, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *int, *bool, int, string) string); ok {
		r1 = rf(ctx, name, langTag, members, open, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, *int, *bool, int, string) error); ok {
		r2 = rf(ctx, name, langTag, members, open, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// LeaderboardCreate provides a mock function with given fields: ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata
func (_m *MockNakamaModule) LeaderboardCreate(ctx context.Context, id string, authoritative bool, sortOrder string, operator string, resetSchedule string, metadata map[string]interface{}) error {
	ret := _m.Called(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, string, string, map[string]interface{}) error); ok {
		r0 = rf(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LeaderboardDelete provides a mock function with given fields: ctx, id
func (_m *MockNakamaModule) LeaderboardDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LeaderboardList provides a mock function with given fields: limit, cursor
func (_m *MockNakamaModule) LeaderboardList(limit int, cursor string) (*api.LeaderboardList, error) {
	ret := _m.Called(limit, cursor)

	var r0 *api.LeaderboardList
	var r1 error
	if rf, ok := ret.Get(0).(func(int, string) (*api.LeaderboardList, error)); ok {
		return rf(limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(int, string) *api.LeaderboardList); ok {
		r0 = rf(limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardList)
		}
	}

	if rf, ok := ret.Get(1).(func(int, string) error); ok {
		r1 = rf(limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LeaderboardRecordDelete provides a mock function with given fields: ctx, id, ownerID
func (_m *MockNakamaModule) LeaderboardRecordDelete(ctx context.Context, id string, ownerID string) error {
	ret := _m.Called(ctx, id, ownerID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, id, ownerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LeaderboardRecordWrite provides a mock function with given fields: ctx, id, ownerID, username, score, subscore, metadata, overrideOperator
func (_m *MockNakamaModule) LeaderboardRecordWrite(ctx context.Context, id string, ownerID string, username string, score int64, subscore int64, metadata map[string]interface{}, overrideOperator *int) (*api.LeaderboardRecord, error) {
	ret := _m.Called(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)

	var r0 *api.LeaderboardRecord
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) (*api.LeaderboardRecord, error)); ok {
		return rf(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) *api.LeaderboardRecord); ok {
		r0 = rf(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) error); ok {
		r1 = rf(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LeaderboardRecordsHaystack provides a mock function with given fields: ctx, id, ownerID, limit, cursor, expiry
func (_m *MockNakamaModule) LeaderboardRecordsHaystack(ctx context.Context, id string, ownerID string, limit int, cursor string, expiry int64) (*api.LeaderboardRecordList, error) {
	ret := _m.Called(ctx, id, ownerID, limit, cursor, expiry)

	var r0 *api.LeaderboardRecordList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) (*api.LeaderboardRecordList, error)); ok {
		return rf(ctx, id, ownerID, limit, cursor, expiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) *api.LeaderboardRecordList); ok {
		r0 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardRecordList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int, string, int64) error); ok {
		r1 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LeaderboardRecordsList provides a mock function with given fields: ctx, id, ownerIDs, limit, cursor, expiry
func (_m *MockNakamaModule) LeaderboardRecordsList(ctx context.Context, id string, ownerIDs []string, limit int, cursor string, expiry int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error) {
	ret := _m.Called(ctx, id, ownerIDs, limit, cursor, expiry)

	var r0 []*api.LeaderboardRecord
	var r1 []*api.LeaderboardRecord
	var r2 string
	var r3 string
	var r4 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error)); ok {
		return rf(ctx, id, ownerIDs, limit, cursor, expiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r0 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r1 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, []string, int, string, int64) string); ok {
		r2 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, []string, int, string, int64) string); ok {
		r3 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		r3 = ret.Get(3).(string)
	}

	if rf, ok := ret.Get(4).(func(context.Context, string, []string, int, string, int64) error); ok {
		r4 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// LeaderboardRecordsListCursorFromRank provides a mock function with given fields: id, rank, overrideExpiry
func (_m *MockNakamaModule) LeaderboardRecordsListCursorFromRank(id string, rank int64, overrideExpiry int64) (string, error) {
	ret := _m.Called(id, rank, overrideExpiry)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int64, int64) (string, error)); ok {
		return rf(id, rank, overrideExpiry)
	}
	if rf, ok := ret.Get(0).(func(string, int64, int64) string); ok {
		r0 = rf(id, rank, overrideExpiry)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, int64, int64) error); ok {
		r1 = rf(id, rank, overrideExpiry)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LeaderboardsGetId provides a mock function with given fields: ctx, ids
func (_m *MockNakamaModule) LeaderboardsGetId(ctx context.Context, ids []string) ([]*api.Leaderboard, error) {
	ret := _m.Called(ctx, ids)

	var r0 []*api.Leaderboard
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Leaderboard, error)); ok {
		return rf(ctx, ids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Leaderboard); ok {
		r0 = rf(ctx, ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Leaderboard)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LinkApple provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) LinkApple(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LinkCustom provides a mock function with given fields: ctx, userID, customID
func (_m *MockNakamaModule) LinkCustom(ctx context.Context, userID string, customID string) error {
	ret := _m.Called(ctx, userID, customID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, customID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LinkDevice provides a mock function with given fields: ctx, userID, deviceID
func (_m *MockNakamaModule) LinkDevice(ctx context.Context, userID string, deviceID string) error {
	ret := _m.Called(ctx, userID, deviceID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, deviceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LinkEmail provides a mock function with given fields: ctx, userID, email, password
func (_m *MockNakamaModule) LinkEmail(ctx context.Context, userID string, email string, password string) error {
	ret := _m.Called(ctx, userID, email, password)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, userID, email, password)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LinkFacebook provides a mock function with given fields: ctx, userID, username, token, importFriends
func (_m *MockNakamaModule) LinkFacebook(ctx context.Context, userID string, username string, token string, importFriends bool) error {
	ret := _m.Called(ctx, userID, username, token, importFriends)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) error); ok {
		r0 = rf(ctx, userID, username, token, importFriends)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LinkFacebookInstantGame provides a mock function with given fields: ctx, userID, signedPlayerInfo
func (_m *MockNakamaModule) LinkFacebookInstantGame(ctx context.Context, userID string, signedPlayerInfo string) error {
	ret := _m.Called(ctx, userID, signedPlayerInfo)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, signedPlayerInfo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LinkGameCenter provides a mock function with given fields: ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl
func (_m *MockNakamaModule) LinkGameCenter(ctx context.Context, userID string, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string) error {
	ret := _m.Called(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, string, string, string) error); ok {
		r0 = rf(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LinkGoogle provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) LinkGoogle(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LinkSteam provides a mock function with given fields: ctx, userID, username, token, importFriends
func (_m *MockNakamaModule) LinkSteam(ctx context.Context, userID string, username string, token string, importFriends bool) error {
	ret := _m.Called(ctx, userID, username, token, importFriends)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) error); ok {
		r0 = rf(ctx, userID, username, token, importFriends)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MatchCreate provides a mock function with given fields: ctx, module, params
func (_m *MockNakamaModule) MatchCreate(ctx context.Context, module string, params map[string]interface{}) (string, error) {
	ret := _m.Called(ctx, module, params)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) (string, error)); ok {
		return rf(ctx, module, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) string); ok {
		r0 = rf(ctx, module, params)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]interface{}) error); ok {
		r1 = rf(ctx, module, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MatchGet provides a mock function with given fields: ctx, id
func (_m *MockNakamaModule) MatchGet(ctx context.Context, id string) (*api.Match, error) {
	ret := _m.Called(ctx, id)

	var r0 *api.Match
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*api.Match, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.Match); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Match)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MatchList provides a mock function with given fields: ctx, limit, authoritative, label, minSize, maxSize, query
func (_m *MockNakamaModule) MatchList(ctx context.Context, limit int, authoritative bool, label string, minSize *int, maxSize *int, query string) ([]*api.Match, error) {
	ret := _m.Called(ctx, limit, authoritative, label, minSize, maxSize, query)

	var r0 []*api.Match
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, bool, string, *int, *int, string) ([]*api.Match, error)); ok {
		return rf(ctx, limit, authoritative, label, minSize, maxSize, query)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, bool, string, *int, *int, string) []*api.Match); ok {
		r0 = rf(ctx, limit, authoritative, label, minSize, maxSize, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Match)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, bool, string, *int, *int, string) error); ok {
		r1 = rf(ctx, limit, authoritative, label, minSize, maxSize, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MatchSignal provides a mock function with given fields: ctx, id, data
func (_m *MockNakamaModule) MatchSignal(ctx context.Context, id string, data string) (string, error) {
	ret := _m.Called(ctx, id, data)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, id, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, id, data)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, id, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MetricsCounterAdd provides a mock function with given fields: name, tags, delta
func (_m *MockNakamaModule) MetricsCounterAdd(name string, tags map[string]string, delta int64) {
	_m.Called(name, tags, delta)
}

// MetricsGaugeSet provides a mock function with given fields: name, tags, value
func (_m *MockNakamaModule) MetricsGaugeSet(name string, tags map[string]string, value float64) {
	_m.Called(name, tags, value)
}

// MetricsTimerRecord provides a mock function with given fields: name, tags, value
func (_m *MockNakamaModule) MetricsTimerRecord(name string, tags map[string]string, value time.Duration) {
	_m.Called(name, tags, value)
}

// MultiUpdate provides a mock function with given fields: ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger
func (_m *MockNakamaModule) MultiUpdate(ctx context.Context, accountUpdates []*runtime.AccountUpdate, storageWrites []*runtime.StorageWrite, storageDeletes []*runtime.StorageDelete, walletUpdates []*runtime.WalletUpdate, updateLedger bool) ([]*api.StorageObjectAck, []*runtime.WalletUpdateResult, error) {
	ret := _m.Called(ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)

	var r0 []*api.StorageObjectAck
	var r1 []*runtime.WalletUpdateResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.StorageDelete, []*runtime.WalletUpdate, bool) ([]*api.StorageObjectAck, []*runtime.WalletUpdateResult, error)); ok {
		return rf(ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.StorageDelete, []*runtime.WalletUpdate, bool) []*api.StorageObjectAck); ok {
		r0 = rf(ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObjectAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.StorageDelete, []*runtime.WalletUpdate, bool) []*runtime.WalletUpdateResult); ok {
		r1 = rf(ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*runtime.WalletUpdateResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.StorageDelete, []*runtime.WalletUpdate, bool) error); ok {
		r2 = rf(ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotificationSend provides a mock function with given fields: ctx, userID, subject, content, code, sender, persistent
func (_m *MockNakamaModule) NotificationSend(ctx context.Context, userID string, subject string, content map[string]interface{}, code int, sender string, persistent bool) error {
	ret := _m.Called(ctx, userID, subject, content, code, sender, persistent)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, int, string, bool) error); ok {
		r0 = rf(ctx, userID, subject, content, code, sender, persistent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NotificationSendAll provides a mock function with given fields: ctx, subject, content, code, persistent
func (_m *MockNakamaModule) NotificationSendAll(ctx context.Context, subject string, content map[string]interface{}, code int, persistent bool) error {
	ret := _m.Called(ctx, subject, content, code, persistent)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, int, bool) error); ok {
		r0 = rf(ctx, subject, content, code, persistent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NotificationsDelete provides a mock function with given fields: ctx, notifications
func (_m *MockNakamaModule) NotificationsDelete(ctx context.Context, notifications []*runtime.NotificationDelete) error {
	ret := _m.Called(ctx, notifications)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.NotificationDelete) error); ok {
		r0 = rf(ctx, notifications)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NotificationsSend provides a mock function with given fields: ctx, notifications
func (_m *MockNakamaModule) NotificationsSend(ctx context.Context, notifications []*runtime.NotificationSend) error {
	ret := _m.Called(ctx, notifications)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.NotificationSend) error); ok {
		r0 = rf(ctx, notifications)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PurchaseGetByTransactionId provides a mock function with given fields: ctx, transactionID
func (_m *MockNakamaModule) PurchaseGetByTransactionId(ctx context.Context, transactionID string) (*api.ValidatedPurchase, error) {
	ret := _m.Called(ctx, transactionID)

	var r0 *api.ValidatedPurchase
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*api.ValidatedPurchase, error)); ok {
		return rf(ctx, transactionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.ValidatedPurchase); ok {
		r0 = rf(ctx, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatedPurchase)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, transactionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseValidateApple provides a mock function with given fields: ctx, userID, receipt, persist, passwordOverride
func (_m *MockNakamaModule) PurchaseValidateApple(ctx context.Context, userID string, receipt string, persist bool, passwordOverride ...string) (*api.ValidatePurchaseResponse, error) {
	_va := make([]interface{}, len(passwordOverride))
	for _i := range passwordOverride {
		_va[_i] = passwordOverride[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, passwordOverride...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...string) error); ok {
		r1 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseValidateFacebookInstant provides a mock function with given fields: ctx, userID, signedRequest, persist
func (_m *MockNakamaModule) PurchaseValidateFacebookInstant(ctx context.Context, userID string, signedRequest string, persist bool) (*api.ValidatePurchaseResponse, error) {
	ret := _m.Called(ctx, userID, signedRequest, persist)

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, signedRequest, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, signedRequest, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) error); ok {
		r1 = rf(ctx, userID, signedRequest, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseValidateGoogle provides a mock function with given fields: ctx, userID, receipt, persist, overrides
func (_m *MockNakamaModule) PurchaseValidateGoogle(ctx context.Context, userID string, receipt string, persist bool, overrides ...struct {
	ClientEmail string
	PrivateKey  string
}) (*api.ValidatePurchaseResponse, error) {
	_va := make([]interface{}, len(overrides))
	for _i := range overrides {
		_va[_i] = overrides[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, overrides...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) error); ok {
		r1 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseValidateHuawei provides a mock function with given fields: ctx, userID, signature, inAppPurchaseData, persist
func (_m *MockNakamaModule) PurchaseValidateHuawei(ctx context.Context, userID string, signature string, inAppPurchaseData string, persist bool) (*api.ValidatePurchaseResponse, error) {
	ret := _m.Called(ctx, userID, signature, inAppPurchaseData, persist)

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, signature, inAppPurchaseData, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, signature, inAppPurchaseData, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, bool) error); ok {
		r1 = rf(ctx, userID, signature, inAppPurchaseData, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchasesList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *MockNakamaModule) PurchasesList(ctx context.Context, userID string, limit int, cursor string) (*api.PurchaseList, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	var r0 *api.PurchaseList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*api.PurchaseList, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *api.PurchaseList); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PurchaseList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadFile provides a mock function with given fields: path
func (_m *MockNakamaModule) ReadFile(path string) (*os.File, error) {
	ret := _m.Called(path)

	var r0 *os.File
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*os.File, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) *os.File); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*os.File)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SessionDisconnect provides a mock function with given fields: ctx, sessionID, reason
func (_m *MockNakamaModule) SessionDisconnect(ctx context.Context, sessionID string, reason ...runtime.PresenceReason) error {
	_va := make([]interface{}, len(reason))
	for _i := range reason {
		_va[_i] = reason[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, sessionID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...runtime.PresenceReason) error); ok {
		r0 = rf(ctx, sessionID, reason...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionLogout provides a mock function with given fields: userID, token, refreshToken
func (_m *MockNakamaModule) SessionLogout(userID string, token string, refreshToken string) error {
	ret := _m.Called(userID, token, refreshToken)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(userID, token, refreshToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageDelete provides a mock function with given fields: ctx, deletes
func (_m *MockNakamaModule) StorageDelete(ctx context.Context, deletes []*runtime.StorageDelete) error {
	ret := _m.Called(ctx, deletes)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageDelete) error); ok {
		r0 = rf(ctx, deletes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageIndexList provides a mock function with given fields: ctx, callerID, indexName, query, limit, order
func (_m *MockNakamaModule) StorageIndexList(ctx context.Context, callerID string, indexName string, query string, limit int, order []string) (*api.StorageObjects, error) {
	ret := _m.Called(ctx, callerID, indexName, query, limit, order)

	var r0 *api.StorageObjects
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, []string) (*api.StorageObjects, error)); ok {
		return rf(ctx, callerID, indexName, query, limit, order)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, []string) *api.StorageObjects); ok {
		r0 = rf(ctx, callerID, indexName, query, limit, order)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.StorageObjects)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int, []string) error); ok {
		r1 = rf(ctx, callerID, indexName, query, limit, order)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageList provides a mock function with given fields: ctx, callerID, userID, collection, limit, cursor
func (_m *MockNakamaModule) StorageList(ctx context.Context, callerID string, userID string, collection string, limit int, cursor string) ([]*api.StorageObject, string, error) {
	ret := _m.Called(ctx, callerID, userID, collection, limit, cursor)

	var r0 []*api.StorageObject
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, string) ([]*api.StorageObject, string, error)); ok {
		return rf(ctx, callerID, userID, collection, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, string) []*api.StorageObject); ok {
		r0 = rf(ctx, callerID, userID, collection, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObject)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int, string) string); ok {
		r1 = rf(ctx, callerID, userID, collection, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, int, string) error); ok {
		r2 = rf(ctx, callerID, userID, collection, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StorageRead provides a mock function with given fields: ctx, reads
func (_m *MockNakamaModule) StorageRead(ctx context.Context, reads []*runtime.StorageRead) ([]*api.StorageObject, error) {
	ret := _m.Called(ctx, reads)

	var r0 []*api.StorageObject
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageRead) ([]*api.StorageObject, error)); ok {
		return rf(ctx, reads)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageRead) []*api.StorageObject); ok {
		r0 = rf(ctx, reads)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObject)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.StorageRead) error); ok {
		r1 = rf(ctx, reads)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StorageWrite provides a mock function with given fields: ctx, writes
func (_m *MockNakamaModule) StorageWrite(ctx context.Context, writes []*runtime.StorageWrite) ([]*api.StorageObjectAck, error) {
	ret := _m.Called(ctx, writes)

	var r0 []*api.StorageObjectAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageWrite) ([]*api.StorageObjectAck, error)); ok {
		return rf(ctx, writes)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageWrite) []*api.StorageObjectAck); ok {
		r0 = rf(ctx, writes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObjectAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.StorageWrite) error); ok {
		r1 = rf(ctx, writes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StreamClose provides a mock function with given fields: mode, subject, subcontext, label
func (_m *MockNakamaModule) StreamClose(mode uint8, subject string, subcontext string, label string) error {
	ret := _m.Called(mode, subject, subcontext, label)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string) error); ok {
		r0 = rf(mode, subject, subcontext, label)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StreamCount provides a mock function with given fields: mode, subject, subcontext, label
func (_m *MockNakamaModule) StreamCount(mode uint8, subject string, subcontext string, label string) (int, error) {
	ret := _m.Called(mode, subject, subcontext, label)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string) (int, error)); ok {
		return rf(mode, subject, subcontext, label)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string) int); ok {
		r0 = rf(mode, subject, subcontext, label)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string) error); ok {
		r1 = rf(mode, subject, subcontext, label)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StreamSend provides a mock function with given fields: mode, subject, subcontext, label, data, presences, reliable
func (_m *MockNakamaModule) StreamSend(mode uint8, subject string, subcontext string, label string, data string, presences []runtime.Presence, reliable bool) error {
	ret := _m.Called(mode, subject, subcontext, label, data, presences, reliable)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, []runtime.Presence, bool) error); ok {
		r0 = rf(mode, subject, subcontext, label, data, presences, reliable)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StreamSendRaw provides a mock function with given fields: mode, subject, subcontext, label, msg, presences, reliable
func (_m *MockNakamaModule) StreamSendRaw(mode uint8, subject string, subcontext string, label string, msg *rtapi.Envelope, presences []runtime.Presence, reliable bool) error {
	ret := _m.Called(mode, subject, subcontext, label, msg, presences, reliable)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, *rtapi.Envelope, []runtime.Presence, bool) error); ok {
		r0 = rf(mode, subject, subcontext, label, msg, presences, reliable)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StreamUserGet provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID
func (_m *MockNakamaModule) StreamUserGet(mode uint8, subject string, subcontext string, label string, userID string, sessionID string) (runtime.PresenceMeta, error) {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID)

	var r0 runtime.PresenceMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string) (runtime.PresenceMeta, error)); ok {
		return rf(mode, subject, subcontext, label, userID, sessionID)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string) runtime.PresenceMeta); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.PresenceMeta)
		}
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string, string, string) error); ok {
		r1 = rf(mode, subject, subcontext, label, userID, sessionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StreamUserJoin provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status
func (_m *MockNakamaModule) StreamUserJoin(mode uint8, subject string, subcontext string, label string, userID string, sessionID string, hidden bool, persistence bool, status string) (bool, error) {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string, bool, bool, string) (bool, error)); ok {
		return rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string, bool, bool, string) bool); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string, string, string, bool, bool, string) error); ok {
		r1 = rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StreamUserKick provides a mock function with given fields: mode, subject, subcontext, label, presence
func (_m *MockNakamaModule) StreamUserKick(mode uint8, subject string, subcontext string, label string, presence runtime.Presence) error {
	ret := _m.Called(mode, subject, subcontext, label, presence)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, runtime.Presence) error); ok {
		r0 = rf(mode, subject, subcontext, label, presence)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StreamUserLeave provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID
func (_m *MockNakamaModule) StreamUserLeave(mode uint8, subject string, subcontext string, label string, userID string, sessionID string) error {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string) error); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StreamUserList provides a mock function with given fields: mode, subject, subcontext, label, includeHidden, includeNotHidden
func (_m *MockNakamaModule) StreamUserList(mode uint8, subject string, subcontext string, label string, includeHidden bool, includeNotHidden bool) ([]runtime.Presence, error) {
	ret := _m.Called(mode, subject, subcontext, label, includeHidden, includeNotHidden)

	var r0 []runtime.Presence
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, bool, bool) ([]runtime.Presence, error)); ok {
		return rf(mode, subject, subcontext, label, includeHidden, includeNotHidden)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, bool, bool) []runtime.Presence); ok {
		r0 = rf(mode, subject, subcontext, label, includeHidden, includeNotHidden)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.Presence)
		}
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string, bool, bool) error); ok {
		r1 = rf(mode, subject, subcontext, label, includeHidden, includeNotHidden)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StreamUserUpdate provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status
func (_m *MockNakamaModule) StreamUserUpdate(mode uint8, subject string, subcontext string, label string, userID string, sessionID string, hidden bool, persistence bool, status string) error {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string, bool, bool, string) error); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubscriptionGetByProductId provides a mock function with given fields: ctx, userID, productID
func (_m *MockNakamaModule) SubscriptionGetByProductId(ctx context.Context, userID string, productID string) (*api.ValidatedSubscription, error) {
	ret := _m.Called(ctx, userID, productID)

	var r0 *api.ValidatedSubscription
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*api.ValidatedSubscription, error)); ok {
		return rf(ctx, userID, productID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *api.ValidatedSubscription); ok {
		r0 = rf(ctx, userID, productID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatedSubscription)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userID, productID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscriptionValidateApple provides a mock function with given fields: ctx, userID, receipt, persist, passwordOverride
func (_m *MockNakamaModule) SubscriptionValidateApple(ctx context.Context, userID string, receipt string, persist bool, passwordOverride ...string) (*api.ValidateSubscriptionResponse, error) {
	_va := make([]interface{}, len(passwordOverride))
	for _i := range passwordOverride {
		_va[_i] = passwordOverride[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *api.ValidateSubscriptionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) (*api.ValidateSubscriptionResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, passwordOverride...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) *api.ValidateSubscriptionResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidateSubscriptionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...string) error); ok {
		r1 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscriptionValidateGoogle provides a mock function with given fields: ctx, userID, receipt, persist, overrides
func (_m *MockNakamaModule) SubscriptionValidateGoogle(ctx context.Context, userID string, receipt string, persist bool, overrides ...struct {
	ClientEmail string
	PrivateKey  string
}) (*api.ValidateSubscriptionResponse, error) {
	_va := make([]interface{}, len(overrides))
	for _i := range overrides {
		_va[_i] = overrides[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *api.ValidateSubscriptionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) (*api.ValidateSubscriptionResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, overrides...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) *api.ValidateSubscriptionResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidateSubscriptionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) error); ok {
		r1 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscriptionsList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *MockNakamaModule) SubscriptionsList(ctx context.Context, userID string, limit int, cursor string) (*api.SubscriptionList, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	var r0 *api.SubscriptionList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*api.SubscriptionList, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *api.SubscriptionList); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.SubscriptionList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TournamentAddAttempt provides a mock function with given fields: ctx, id, ownerID, count
func (_m *MockNakamaModule) TournamentAddAttempt(ctx context.Context, id string, ownerID string, count int) error {
	ret := _m.Called(ctx, id, ownerID, count)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) error); ok {
		r0 = rf(ctx, id, ownerID, count)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TournamentCreate provides a mock function with given fields: ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired
func (_m *MockNakamaModule) TournamentCreate(ctx context.Context, id string, authoritative bool, sortOrder string, operator string, resetSchedule string, metadata map[string]interface{}, title string, description string, category int, startTime int, endTime int, duration int, maxSize int, maxNumScore int, joinRequired bool) error {
	ret := _m.Called(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, string, string, map[string]interface{}, string, string, int, int, int, int, int, int, bool) error); ok {
		r0 = rf(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TournamentDelete provides a mock function with given fields: ctx, id
func (_m *MockNakamaModule) TournamentDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TournamentJoin provides a mock function with given fields: ctx, id, ownerID, username
func (_m *MockNakamaModule) TournamentJoin(ctx context.Context, id string, ownerID string, username string) error {
	ret := _m.Called(ctx, id, ownerID, username)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, id, ownerID, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TournamentList provides a mock function with given fields: ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor
func (_m *MockNakamaModule) TournamentList(ctx context.Context, categoryStart int, categoryEnd int, startTime int, endTime int, limit int, cursor string) (*api.TournamentList, error) {
	ret := _m.Called(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)

	var r0 *api.TournamentList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, int, int, string) (*api.TournamentList, error)); ok {
		return rf(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, int, int, string) *api.TournamentList); ok {
		r0 = rf(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.TournamentList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int, int, int, string) error); ok {
		r1 = rf(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TournamentRecordDelete provides a mock function with given fields: ctx, id, ownerID
func (_m *MockNakamaModule) TournamentRecordDelete(ctx context.Context, id string, ownerID string) error {
	ret := _m.Called(ctx, id, ownerID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, id, ownerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TournamentRecordWrite provides a mock function with given fields: ctx, id, ownerID, username, score, subscore, metadata, operatorOverride
func (_m *MockNakamaModule) TournamentRecordWrite(ctx context.Context, id string, ownerID string, username string, score int64, subscore int64, metadata map[string]interface{}, operatorOverride *int) (*api.LeaderboardRecord, error) {
	ret := _m.Called(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)

	var r0 *api.LeaderboardRecord
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) (*api.LeaderboardRecord, error)); ok {
		return rf(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) *api.LeaderboardRecord); ok {
		r0 = rf(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) error); ok {
		r1 = rf(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TournamentRecordsHaystack provides a mock function with given fields: ctx, id, ownerID, limit, cursor, expiry
func (_m *MockNakamaModule) TournamentRecordsHaystack(ctx context.Context, id string, ownerID string, limit int, cursor string, expiry int64) (*api.TournamentRecordList, error) {
	ret := _m.Called(ctx, id, ownerID, limit, cursor, expiry)

	var r0 *api.TournamentRecordList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) (*api.TournamentRecordList, error)); ok {
		return rf(ctx, id, ownerID, limit, cursor, expiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) *api.TournamentRecordList); ok {
		r0 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.TournamentRecordList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int, string, int64) error); ok {
		r1 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TournamentRecordsList provides a mock function with given fields: ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry
func (_m *MockNakamaModule) TournamentRecordsList(ctx context.Context, tournamentId string, ownerIDs []string, limit int, cursor string, overrideExpiry int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error) {
	ret := _m.Called(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)

	var r0 []*api.LeaderboardRecord
	var r1 []*api.LeaderboardRecord
	var r2 string
	var r3 string
	var r4 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error)); ok {
		return rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r0 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r1 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, []string, int, string, int64) string); ok {
		r2 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, []string, int, string, int64) string); ok {
		r3 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		r3 = ret.Get(3).(string)
	}

	if rf, ok := ret.Get(4).(func(context.Context, string, []string, int, string, int64) error); ok {
		r4 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// TournamentsGetId provides a mock function with given fields: ctx, tournamentIDs
func (_m *MockNakamaModule) TournamentsGetId(ctx context.Context, tournamentIDs []string) ([]*api.Tournament, error) {
	ret := _m.Called(ctx, tournamentIDs)

	var r0 []*api.Tournament
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Tournament, error)); ok {
		return rf(ctx, tournamentIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Tournament); ok {
		r0 = rf(ctx, tournamentIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Tournament)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, tournamentIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnlinkApple provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) UnlinkApple(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlinkCustom provides a mock function with given fields: ctx, userID, customID
func (_m *MockNakamaModule) UnlinkCustom(ctx context.Context, userID string, customID string) error {
	ret := _m.Called(ctx, userID, customID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, customID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlinkDevice provides a mock function with given fields: ctx, userID, deviceID
func (_m *MockNakamaModule) UnlinkDevice(ctx context.Context, userID string, deviceID string) error {
	ret := _m.Called(ctx, userID, deviceID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, deviceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlinkEmail provides a mock function with given fields: ctx, userID, email
func (_m *MockNakamaModule) UnlinkEmail(ctx context.Context, userID string, email string) error {
	ret := _m.Called(ctx, userID, email)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, email)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlinkFacebook provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) UnlinkFacebook(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlinkFacebookInstantGame provides a mock function with given fields: ctx, userID, signedPlayerInfo
func (_m *MockNakamaModule) UnlinkFacebookInstantGame(ctx context.Context, userID string, signedPlayerInfo string) error {
	ret := _m.Called(ctx, userID, signedPlayerInfo)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, signedPlayerInfo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlinkGameCenter provides a mock function with given fields: ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl
func (_m *MockNakamaModule) UnlinkGameCenter(ctx context.Context, userID string, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string) error {
	ret := _m.Called(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, string, string, string) error); ok {
		r0 = rf(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlinkGoogle provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) UnlinkGoogle(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlinkSteam provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) UnlinkSteam(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UserGroupsList provides a mock function with given fields: ctx, userID, limit, state, cursor
func (_m *MockNakamaModule) UserGroupsList(ctx context.Context, userID string, limit int, state *int, cursor string) ([]*api.UserGroupList_UserGroup, string, error) {
	ret := _m.Called(ctx, userID, limit, state, cursor)

	var r0 []*api.UserGroupList_UserGroup
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) ([]*api.UserGroupList_UserGroup, string, error)); ok {
		return rf(ctx, userID, limit, state, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) []*api.UserGroupList_UserGroup); ok {
		r0 = rf(ctx, userID, limit, state, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.UserGroupList_UserGroup)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *int, string) string); ok {
		r1 = rf(ctx, userID, limit, state, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, *int, string) error); ok {
		r2 = rf(ctx, userID, limit, state, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersBanId provides a mock function with given fields: ctx, userIDs
func (_m *MockNakamaModule) UsersBanId(ctx context.Context, userIDs []string) error {
	ret := _m.Called(ctx, userIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsersGetId provides a mock function with given fields: ctx, userIDs, facebookIDs
func (_m *MockNakamaModule) UsersGetId(ctx context.Context, userIDs []string, facebookIDs []string) ([]*api.User, error) {
	ret := _m.Called(ctx, userIDs, facebookIDs)

	var r0 []*api.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, []string) ([]*api.User, error)); ok {
		return rf(ctx, userIDs, facebookIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, []string) []*api.User); ok {
		r0 = rf(ctx, userIDs, facebookIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, []string) error); ok {
		r1 = rf(ctx, userIDs, facebookIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersGetRandom provides a mock function with given fields: ctx, count
func (_m *MockNakamaModule) UsersGetRandom(ctx context.Context, count int) ([]*api.User, error) {
	ret := _m.Called(ctx, count)

	var r0 []*api.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*api.User, error)); ok {
		return rf(ctx, count)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*api.User); ok {
		r0 = rf(ctx, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersGetUsername provides a mock function with given fields: ctx, usernames
func (_m *MockNakamaModule) UsersGetUsername(ctx context.Context, usernames []string) ([]*api.User, error) {
	ret := _m.Called(ctx, usernames)

	var r0 []*api.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.User, error)); ok {
		return rf(ctx, usernames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.User); ok {
		r0 = rf(ctx, usernames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, usernames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersUnbanId provides a mock function with given fields: ctx, userIDs
func (_m *MockNakamaModule) UsersUnbanId(ctx context.Context, userIDs []string) error {
	ret := _m.Called(ctx, userIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WalletLedgerList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *MockNakamaModule) WalletLedgerList(ctx context.Context, userID string, limit int, cursor string) ([]runtime.WalletLedgerItem, string, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	var r0 []runtime.WalletLedgerItem
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) ([]runtime.WalletLedgerItem, string, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) []runtime.WalletLedgerItem); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.WalletLedgerItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) string); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, string) error); ok {
		r2 = rf(ctx, userID, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// WalletLedgerUpdate provides a mock function with given fields: ctx, itemID, metadata
func (_m *MockNakamaModule) WalletLedgerUpdate(ctx context.Context, itemID string, metadata map[string]interface{}) (runtime.WalletLedgerItem, error) {
	ret := _m.Called(ctx, itemID, metadata)

	var r0 runtime.WalletLedgerItem
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) (runtime.WalletLedgerItem, error)); ok {
		return rf(ctx, itemID, metadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) runtime.WalletLedgerItem); ok {
		r0 = rf(ctx, itemID, metadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.WalletLedgerItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]interface{}) error); ok {
		r1 = rf(ctx, itemID, metadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletUpdate provides a mock function with given fields: ctx, userID, changeset, metadata, updateLedger
func (_m *MockNakamaModule) WalletUpdate(ctx context.Context, userID string, changeset map[string]int64, metadata map[string]interface{}, updateLedger bool) (map[string]int64, map[string]int64, error) {
	ret := _m.Called(ctx, userID, changeset, metadata, updateLedger)

	var r0 map[string]int64
	var r1 map[string]int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) (map[string]int64, map[string]int64, error)); ok {
		return rf(ctx, userID, changeset, metadata, updateLedger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) map[string]int64); ok {
		r0 = rf(ctx, userID, changeset, metadata, updateLedger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) map[string]int64); ok {
		r1 = rf(ctx, userID, changeset, metadata, updateLedger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[string]int64)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) error); ok {
		r2 = rf(ctx, userID, changeset, metadata, updateLedger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// WalletsUpdate provides a mock function with given fields: ctx, updates, updateLedger
func (_m *MockNakamaModule) WalletsUpdate(ctx context.Context, updates []*runtime.WalletUpdate, updateLedger bool) ([]*runtime.WalletUpdateResult, error) {
	ret := _m.Called(ctx, updates, updateLedger)

	var r0 []*runtime.WalletUpdateResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.WalletUpdate, bool) ([]*runtime.WalletUpdateResult, error)); ok {
		return rf(ctx, updates, updateLedger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.WalletUpdate, bool) []*runtime.WalletUpdateResult); ok {
		r0 = rf(ctx, updates, updateLedger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*runtime.WalletUpdateResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.WalletUpdate, bool) error); ok {
		r1 = rf(ctx, updates, updateLedger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewMockNakamaModule interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockNakamaModule creates a new instance of MockNakamaModule. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockNakamaModule(t mockConstructorTestingTNewMockNakamaModule) *MockNakamaModule {
	mock := &MockNakamaModule{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
