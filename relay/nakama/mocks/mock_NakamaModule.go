// Code generated by mockery v2.50.0. DO NOT EDIT.

package mocks

import (
	context "context"

	api "github.com/heroiclabs/nakama-common/api"

	mock "github.com/stretchr/testify/mock"

	os "os"

	rtapi "github.com/heroiclabs/nakama-common/rtapi"

	runtime "github.com/heroiclabs/nakama-common/runtime"

	time "time"
)

// MockNakamaModule is an autogenerated mock type for the NakamaModule type
type MockNakamaModule struct {
	mock.Mock
}

type MockNakamaModule_Expecter struct {
	mock *mock.Mock
}

func (_m *MockNakamaModule) EXPECT() *MockNakamaModule_Expecter {
	return &MockNakamaModule_Expecter{mock: &_m.Mock}
}

// AccountDeleteId provides a mock function with given fields: ctx, userID, recorded
func (_m *MockNakamaModule) AccountDeleteId(ctx context.Context, userID string, recorded bool) error {
	ret := _m.Called(ctx, userID, recorded)

	if len(ret) == 0 {
		panic("no return value specified for AccountDeleteId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = rf(ctx, userID, recorded)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_AccountDeleteId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountDeleteId'
type MockNakamaModule_AccountDeleteId_Call struct {
	*mock.Call
}

// AccountDeleteId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - recorded bool
func (_e *MockNakamaModule_Expecter) AccountDeleteId(ctx interface{}, userID interface{}, recorded interface{}) *MockNakamaModule_AccountDeleteId_Call {
	return &MockNakamaModule_AccountDeleteId_Call{Call: _e.mock.On("AccountDeleteId", ctx, userID, recorded)}
}

func (_c *MockNakamaModule_AccountDeleteId_Call) Run(run func(ctx context.Context, userID string, recorded bool)) *MockNakamaModule_AccountDeleteId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_AccountDeleteId_Call) Return(_a0 error) *MockNakamaModule_AccountDeleteId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_AccountDeleteId_Call) RunAndReturn(run func(context.Context, string, bool) error) *MockNakamaModule_AccountDeleteId_Call {
	_c.Call.Return(run)
	return _c
}

// AccountExportId provides a mock function with given fields: ctx, userID
func (_m *MockNakamaModule) AccountExportId(ctx context.Context, userID string) (string, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for AccountExportId")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_AccountExportId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountExportId'
type MockNakamaModule_AccountExportId_Call struct {
	*mock.Call
}

// AccountExportId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockNakamaModule_Expecter) AccountExportId(ctx interface{}, userID interface{}) *MockNakamaModule_AccountExportId_Call {
	return &MockNakamaModule_AccountExportId_Call{Call: _e.mock.On("AccountExportId", ctx, userID)}
}

func (_c *MockNakamaModule_AccountExportId_Call) Run(run func(ctx context.Context, userID string)) *MockNakamaModule_AccountExportId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockNakamaModule_AccountExportId_Call) Return(_a0 string, _a1 error) *MockNakamaModule_AccountExportId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_AccountExportId_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockNakamaModule_AccountExportId_Call {
	_c.Call.Return(run)
	return _c
}

// AccountGetId provides a mock function with given fields: ctx, userID
func (_m *MockNakamaModule) AccountGetId(ctx context.Context, userID string) (*api.Account, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for AccountGetId")
	}

	var r0 *api.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*api.Account, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.Account); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_AccountGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountGetId'
type MockNakamaModule_AccountGetId_Call struct {
	*mock.Call
}

// AccountGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockNakamaModule_Expecter) AccountGetId(ctx interface{}, userID interface{}) *MockNakamaModule_AccountGetId_Call {
	return &MockNakamaModule_AccountGetId_Call{Call: _e.mock.On("AccountGetId", ctx, userID)}
}

func (_c *MockNakamaModule_AccountGetId_Call) Run(run func(ctx context.Context, userID string)) *MockNakamaModule_AccountGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockNakamaModule_AccountGetId_Call) Return(_a0 *api.Account, _a1 error) *MockNakamaModule_AccountGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_AccountGetId_Call) RunAndReturn(run func(context.Context, string) (*api.Account, error)) *MockNakamaModule_AccountGetId_Call {
	_c.Call.Return(run)
	return _c
}

// AccountUpdateId provides a mock function with given fields: ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl
func (_m *MockNakamaModule) AccountUpdateId(ctx context.Context, userID string, username string, metadata map[string]interface{}, displayName string, timezone string, location string, langTag string, avatarUrl string) error {
	ret := _m.Called(ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl)

	if len(ret) == 0 {
		panic("no return value specified for AccountUpdateId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, string, string, string, string, string) error); ok {
		r0 = rf(ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_AccountUpdateId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountUpdateId'
type MockNakamaModule_AccountUpdateId_Call struct {
	*mock.Call
}

// AccountUpdateId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - metadata map[string]interface{}
//   - displayName string
//   - timezone string
//   - location string
//   - langTag string
//   - avatarUrl string
func (_e *MockNakamaModule_Expecter) AccountUpdateId(ctx interface{}, userID interface{}, username interface{}, metadata interface{}, displayName interface{}, timezone interface{}, location interface{}, langTag interface{}, avatarUrl interface{}) *MockNakamaModule_AccountUpdateId_Call {
	return &MockNakamaModule_AccountUpdateId_Call{Call: _e.mock.On("AccountUpdateId", ctx, userID, username, metadata, displayName, timezone, location, langTag, avatarUrl)}
}

func (_c *MockNakamaModule_AccountUpdateId_Call) Run(run func(ctx context.Context, userID string, username string, metadata map[string]interface{}, displayName string, timezone string, location string, langTag string, avatarUrl string)) *MockNakamaModule_AccountUpdateId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string]interface{}), args[4].(string), args[5].(string), args[6].(string), args[7].(string), args[8].(string))
	})
	return _c
}

func (_c *MockNakamaModule_AccountUpdateId_Call) Return(_a0 error) *MockNakamaModule_AccountUpdateId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_AccountUpdateId_Call) RunAndReturn(run func(context.Context, string, string, map[string]interface{}, string, string, string, string, string) error) *MockNakamaModule_AccountUpdateId_Call {
	_c.Call.Return(run)
	return _c
}

// AccountsGetId provides a mock function with given fields: ctx, userIDs
func (_m *MockNakamaModule) AccountsGetId(ctx context.Context, userIDs []string) ([]*api.Account, error) {
	ret := _m.Called(ctx, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for AccountsGetId")
	}

	var r0 []*api.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Account, error)); ok {
		return rf(ctx, userIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Account); ok {
		r0 = rf(ctx, userIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, userIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_AccountsGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountsGetId'
type MockNakamaModule_AccountsGetId_Call struct {
	*mock.Call
}

// AccountsGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) AccountsGetId(ctx interface{}, userIDs interface{}) *MockNakamaModule_AccountsGetId_Call {
	return &MockNakamaModule_AccountsGetId_Call{Call: _e.mock.On("AccountsGetId", ctx, userIDs)}
}

func (_c *MockNakamaModule_AccountsGetId_Call) Run(run func(ctx context.Context, userIDs []string)) *MockNakamaModule_AccountsGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_AccountsGetId_Call) Return(_a0 []*api.Account, _a1 error) *MockNakamaModule_AccountsGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_AccountsGetId_Call) RunAndReturn(run func(context.Context, []string) ([]*api.Account, error)) *MockNakamaModule_AccountsGetId_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateApple provides a mock function with given fields: ctx, token, username, create
func (_m *MockNakamaModule) AuthenticateApple(ctx context.Context, token string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateApple")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, token, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, token, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, token, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, token, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockNakamaModule_AuthenticateApple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateApple'
type MockNakamaModule_AuthenticateApple_Call struct {
	*mock.Call
}

// AuthenticateApple is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
//   - username string
//   - create bool
func (_e *MockNakamaModule_Expecter) AuthenticateApple(ctx interface{}, token interface{}, username interface{}, create interface{}) *MockNakamaModule_AuthenticateApple_Call {
	return &MockNakamaModule_AuthenticateApple_Call{Call: _e.mock.On("AuthenticateApple", ctx, token, username, create)}
}

func (_c *MockNakamaModule_AuthenticateApple_Call) Run(run func(ctx context.Context, token string, username string, create bool)) *MockNakamaModule_AuthenticateApple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_AuthenticateApple_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *MockNakamaModule_AuthenticateApple_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockNakamaModule_AuthenticateApple_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *MockNakamaModule_AuthenticateApple_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateCustom provides a mock function with given fields: ctx, id, username, create
func (_m *MockNakamaModule) AuthenticateCustom(ctx context.Context, id string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, id, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateCustom")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, id, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, id, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, id, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, id, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, id, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockNakamaModule_AuthenticateCustom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateCustom'
type MockNakamaModule_AuthenticateCustom_Call struct {
	*mock.Call
}

// AuthenticateCustom is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - username string
//   - create bool
func (_e *MockNakamaModule_Expecter) AuthenticateCustom(ctx interface{}, id interface{}, username interface{}, create interface{}) *MockNakamaModule_AuthenticateCustom_Call {
	return &MockNakamaModule_AuthenticateCustom_Call{Call: _e.mock.On("AuthenticateCustom", ctx, id, username, create)}
}

func (_c *MockNakamaModule_AuthenticateCustom_Call) Run(run func(ctx context.Context, id string, username string, create bool)) *MockNakamaModule_AuthenticateCustom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_AuthenticateCustom_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *MockNakamaModule_AuthenticateCustom_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockNakamaModule_AuthenticateCustom_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *MockNakamaModule_AuthenticateCustom_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateDevice provides a mock function with given fields: ctx, id, username, create
func (_m *MockNakamaModule) AuthenticateDevice(ctx context.Context, id string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, id, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateDevice")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, id, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, id, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, id, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, id, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, id, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockNakamaModule_AuthenticateDevice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateDevice'
type MockNakamaModule_AuthenticateDevice_Call struct {
	*mock.Call
}

// AuthenticateDevice is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - username string
//   - create bool
func (_e *MockNakamaModule_Expecter) AuthenticateDevice(ctx interface{}, id interface{}, username interface{}, create interface{}) *MockNakamaModule_AuthenticateDevice_Call {
	return &MockNakamaModule_AuthenticateDevice_Call{Call: _e.mock.On("AuthenticateDevice", ctx, id, username, create)}
}

func (_c *MockNakamaModule_AuthenticateDevice_Call) Run(run func(ctx context.Context, id string, username string, create bool)) *MockNakamaModule_AuthenticateDevice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_AuthenticateDevice_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *MockNakamaModule_AuthenticateDevice_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockNakamaModule_AuthenticateDevice_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *MockNakamaModule_AuthenticateDevice_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateEmail provides a mock function with given fields: ctx, email, password, username, create
func (_m *MockNakamaModule) AuthenticateEmail(ctx context.Context, email string, password string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, email, password, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateEmail")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, email, password, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) string); ok {
		r0 = rf(ctx, email, password, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, bool) string); ok {
		r1 = rf(ctx, email, password, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, bool) bool); ok {
		r2 = rf(ctx, email, password, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, string, bool) error); ok {
		r3 = rf(ctx, email, password, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockNakamaModule_AuthenticateEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateEmail'
type MockNakamaModule_AuthenticateEmail_Call struct {
	*mock.Call
}

// AuthenticateEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - password string
//   - username string
//   - create bool
func (_e *MockNakamaModule_Expecter) AuthenticateEmail(ctx interface{}, email interface{}, password interface{}, username interface{}, create interface{}) *MockNakamaModule_AuthenticateEmail_Call {
	return &MockNakamaModule_AuthenticateEmail_Call{Call: _e.mock.On("AuthenticateEmail", ctx, email, password, username, create)}
}

func (_c *MockNakamaModule_AuthenticateEmail_Call) Run(run func(ctx context.Context, email string, password string, username string, create bool)) *MockNakamaModule_AuthenticateEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_AuthenticateEmail_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *MockNakamaModule_AuthenticateEmail_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockNakamaModule_AuthenticateEmail_Call) RunAndReturn(run func(context.Context, string, string, string, bool) (string, string, bool, error)) *MockNakamaModule_AuthenticateEmail_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateFacebook provides a mock function with given fields: ctx, token, importFriends, username, create
func (_m *MockNakamaModule) AuthenticateFacebook(ctx context.Context, token string, importFriends bool, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, importFriends, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateFacebook")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, importFriends, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, bool) string); ok {
		r0 = rf(ctx, token, importFriends, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool, string, bool) string); ok {
		r1 = rf(ctx, token, importFriends, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, bool, string, bool) bool); ok {
		r2 = rf(ctx, token, importFriends, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, bool, string, bool) error); ok {
		r3 = rf(ctx, token, importFriends, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockNakamaModule_AuthenticateFacebook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateFacebook'
type MockNakamaModule_AuthenticateFacebook_Call struct {
	*mock.Call
}

// AuthenticateFacebook is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
//   - importFriends bool
//   - username string
//   - create bool
func (_e *MockNakamaModule_Expecter) AuthenticateFacebook(ctx interface{}, token interface{}, importFriends interface{}, username interface{}, create interface{}) *MockNakamaModule_AuthenticateFacebook_Call {
	return &MockNakamaModule_AuthenticateFacebook_Call{Call: _e.mock.On("AuthenticateFacebook", ctx, token, importFriends, username, create)}
}

func (_c *MockNakamaModule_AuthenticateFacebook_Call) Run(run func(ctx context.Context, token string, importFriends bool, username string, create bool)) *MockNakamaModule_AuthenticateFacebook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool), args[3].(string), args[4].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_AuthenticateFacebook_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *MockNakamaModule_AuthenticateFacebook_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockNakamaModule_AuthenticateFacebook_Call) RunAndReturn(run func(context.Context, string, bool, string, bool) (string, string, bool, error)) *MockNakamaModule_AuthenticateFacebook_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateFacebookInstantGame provides a mock function with given fields: ctx, signedPlayerInfo, username, create
func (_m *MockNakamaModule) AuthenticateFacebookInstantGame(ctx context.Context, signedPlayerInfo string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, signedPlayerInfo, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateFacebookInstantGame")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, signedPlayerInfo, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, signedPlayerInfo, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockNakamaModule_AuthenticateFacebookInstantGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateFacebookInstantGame'
type MockNakamaModule_AuthenticateFacebookInstantGame_Call struct {
	*mock.Call
}

// AuthenticateFacebookInstantGame is a helper method to define mock.On call
//   - ctx context.Context
//   - signedPlayerInfo string
//   - username string
//   - create bool
func (_e *MockNakamaModule_Expecter) AuthenticateFacebookInstantGame(ctx interface{}, signedPlayerInfo interface{}, username interface{}, create interface{}) *MockNakamaModule_AuthenticateFacebookInstantGame_Call {
	return &MockNakamaModule_AuthenticateFacebookInstantGame_Call{Call: _e.mock.On("AuthenticateFacebookInstantGame", ctx, signedPlayerInfo, username, create)}
}

func (_c *MockNakamaModule_AuthenticateFacebookInstantGame_Call) Run(run func(ctx context.Context, signedPlayerInfo string, username string, create bool)) *MockNakamaModule_AuthenticateFacebookInstantGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_AuthenticateFacebookInstantGame_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *MockNakamaModule_AuthenticateFacebookInstantGame_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockNakamaModule_AuthenticateFacebookInstantGame_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *MockNakamaModule_AuthenticateFacebookInstantGame_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateGameCenter provides a mock function with given fields: ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create
func (_m *MockNakamaModule) AuthenticateGameCenter(ctx context.Context, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateGameCenter")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, string, string, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, string, string, string, string, bool) string); ok {
		r0 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int64, string, string, string, string, bool) string); ok {
		r1 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, int64, string, string, string, string, bool) bool); ok {
		r2 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, int64, string, string, string, string, bool) error); ok {
		r3 = rf(ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockNakamaModule_AuthenticateGameCenter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateGameCenter'
type MockNakamaModule_AuthenticateGameCenter_Call struct {
	*mock.Call
}

// AuthenticateGameCenter is a helper method to define mock.On call
//   - ctx context.Context
//   - playerID string
//   - bundleID string
//   - timestamp int64
//   - salt string
//   - signature string
//   - publicKeyUrl string
//   - username string
//   - create bool
func (_e *MockNakamaModule_Expecter) AuthenticateGameCenter(ctx interface{}, playerID interface{}, bundleID interface{}, timestamp interface{}, salt interface{}, signature interface{}, publicKeyUrl interface{}, username interface{}, create interface{}) *MockNakamaModule_AuthenticateGameCenter_Call {
	return &MockNakamaModule_AuthenticateGameCenter_Call{Call: _e.mock.On("AuthenticateGameCenter", ctx, playerID, bundleID, timestamp, salt, signature, publicKeyUrl, username, create)}
}

func (_c *MockNakamaModule_AuthenticateGameCenter_Call) Run(run func(ctx context.Context, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string, username string, create bool)) *MockNakamaModule_AuthenticateGameCenter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64), args[4].(string), args[5].(string), args[6].(string), args[7].(string), args[8].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_AuthenticateGameCenter_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *MockNakamaModule_AuthenticateGameCenter_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockNakamaModule_AuthenticateGameCenter_Call) RunAndReturn(run func(context.Context, string, string, int64, string, string, string, string, bool) (string, string, bool, error)) *MockNakamaModule_AuthenticateGameCenter_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateGoogle provides a mock function with given fields: ctx, token, username, create
func (_m *MockNakamaModule) AuthenticateGoogle(ctx context.Context, token string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateGoogle")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, token, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, token, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, token, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, token, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockNakamaModule_AuthenticateGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateGoogle'
type MockNakamaModule_AuthenticateGoogle_Call struct {
	*mock.Call
}

// AuthenticateGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
//   - username string
//   - create bool
func (_e *MockNakamaModule_Expecter) AuthenticateGoogle(ctx interface{}, token interface{}, username interface{}, create interface{}) *MockNakamaModule_AuthenticateGoogle_Call {
	return &MockNakamaModule_AuthenticateGoogle_Call{Call: _e.mock.On("AuthenticateGoogle", ctx, token, username, create)}
}

func (_c *MockNakamaModule_AuthenticateGoogle_Call) Run(run func(ctx context.Context, token string, username string, create bool)) *MockNakamaModule_AuthenticateGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_AuthenticateGoogle_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *MockNakamaModule_AuthenticateGoogle_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockNakamaModule_AuthenticateGoogle_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *MockNakamaModule_AuthenticateGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateSteam provides a mock function with given fields: ctx, token, username, create
func (_m *MockNakamaModule) AuthenticateSteam(ctx context.Context, token string, username string, create bool) (string, string, bool, error) {
	ret := _m.Called(ctx, token, username, create)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateSteam")
	}

	var r0 string
	var r1 string
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, string, bool, error)); ok {
		return rf(ctx, token, username, create)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, token, username, create)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) string); ok {
		r1 = rf(ctx, token, username, create)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool) bool); ok {
		r2 = rf(ctx, token, username, create)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, bool) error); ok {
		r3 = rf(ctx, token, username, create)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockNakamaModule_AuthenticateSteam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateSteam'
type MockNakamaModule_AuthenticateSteam_Call struct {
	*mock.Call
}

// AuthenticateSteam is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
//   - username string
//   - create bool
func (_e *MockNakamaModule_Expecter) AuthenticateSteam(ctx interface{}, token interface{}, username interface{}, create interface{}) *MockNakamaModule_AuthenticateSteam_Call {
	return &MockNakamaModule_AuthenticateSteam_Call{Call: _e.mock.On("AuthenticateSteam", ctx, token, username, create)}
}

func (_c *MockNakamaModule_AuthenticateSteam_Call) Run(run func(ctx context.Context, token string, username string, create bool)) *MockNakamaModule_AuthenticateSteam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_AuthenticateSteam_Call) Return(_a0 string, _a1 string, _a2 bool, _a3 error) *MockNakamaModule_AuthenticateSteam_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockNakamaModule_AuthenticateSteam_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, string, bool, error)) *MockNakamaModule_AuthenticateSteam_Call {
	_c.Call.Return(run)
	return _c
}

// AuthenticateTokenGenerate provides a mock function with given fields: userID, username, exp, vars
func (_m *MockNakamaModule) AuthenticateTokenGenerate(userID string, username string, exp int64, vars map[string]string) (string, int64, error) {
	ret := _m.Called(userID, username, exp, vars)

	if len(ret) == 0 {
		panic("no return value specified for AuthenticateTokenGenerate")
	}

	var r0 string
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, int64, map[string]string) (string, int64, error)); ok {
		return rf(userID, username, exp, vars)
	}
	if rf, ok := ret.Get(0).(func(string, string, int64, map[string]string) string); ok {
		r0 = rf(userID, username, exp, vars)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string, int64, map[string]string) int64); ok {
		r1 = rf(userID, username, exp, vars)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(string, string, int64, map[string]string) error); ok {
		r2 = rf(userID, username, exp, vars)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_AuthenticateTokenGenerate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateTokenGenerate'
type MockNakamaModule_AuthenticateTokenGenerate_Call struct {
	*mock.Call
}

// AuthenticateTokenGenerate is a helper method to define mock.On call
//   - userID string
//   - username string
//   - exp int64
//   - vars map[string]string
func (_e *MockNakamaModule_Expecter) AuthenticateTokenGenerate(userID interface{}, username interface{}, exp interface{}, vars interface{}) *MockNakamaModule_AuthenticateTokenGenerate_Call {
	return &MockNakamaModule_AuthenticateTokenGenerate_Call{Call: _e.mock.On("AuthenticateTokenGenerate", userID, username, exp, vars)}
}

func (_c *MockNakamaModule_AuthenticateTokenGenerate_Call) Run(run func(userID string, username string, exp int64, vars map[string]string)) *MockNakamaModule_AuthenticateTokenGenerate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(int64), args[3].(map[string]string))
	})
	return _c
}

func (_c *MockNakamaModule_AuthenticateTokenGenerate_Call) Return(_a0 string, _a1 int64, _a2 error) *MockNakamaModule_AuthenticateTokenGenerate_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_AuthenticateTokenGenerate_Call) RunAndReturn(run func(string, string, int64, map[string]string) (string, int64, error)) *MockNakamaModule_AuthenticateTokenGenerate_Call {
	_c.Call.Return(run)
	return _c
}

// ChannelIdBuild provides a mock function with given fields: ctx, sender, target, chanType
func (_m *MockNakamaModule) ChannelIdBuild(ctx context.Context, sender string, target string, chanType runtime.ChannelType) (string, error) {
	ret := _m.Called(ctx, sender, target, chanType)

	if len(ret) == 0 {
		panic("no return value specified for ChannelIdBuild")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, runtime.ChannelType) (string, error)); ok {
		return rf(ctx, sender, target, chanType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, runtime.ChannelType) string); ok {
		r0 = rf(ctx, sender, target, chanType)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, runtime.ChannelType) error); ok {
		r1 = rf(ctx, sender, target, chanType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_ChannelIdBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChannelIdBuild'
type MockNakamaModule_ChannelIdBuild_Call struct {
	*mock.Call
}

// ChannelIdBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - sender string
//   - target string
//   - chanType runtime.ChannelType
func (_e *MockNakamaModule_Expecter) ChannelIdBuild(ctx interface{}, sender interface{}, target interface{}, chanType interface{}) *MockNakamaModule_ChannelIdBuild_Call {
	return &MockNakamaModule_ChannelIdBuild_Call{Call: _e.mock.On("ChannelIdBuild", ctx, sender, target, chanType)}
}

func (_c *MockNakamaModule_ChannelIdBuild_Call) Run(run func(ctx context.Context, sender string, target string, chanType runtime.ChannelType)) *MockNakamaModule_ChannelIdBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(runtime.ChannelType))
	})
	return _c
}

func (_c *MockNakamaModule_ChannelIdBuild_Call) Return(_a0 string, _a1 error) *MockNakamaModule_ChannelIdBuild_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_ChannelIdBuild_Call) RunAndReturn(run func(context.Context, string, string, runtime.ChannelType) (string, error)) *MockNakamaModule_ChannelIdBuild_Call {
	_c.Call.Return(run)
	return _c
}

// ChannelMessageRemove provides a mock function with given fields: ctx, channelId, messageId, senderId, senderUsername, persist
func (_m *MockNakamaModule) ChannelMessageRemove(ctx context.Context, channelId string, messageId string, senderId string, senderUsername string, persist bool) (*rtapi.ChannelMessageAck, error) {
	ret := _m.Called(ctx, channelId, messageId, senderId, senderUsername, persist)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageRemove")
	}

	var r0 *rtapi.ChannelMessageAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, bool) (*rtapi.ChannelMessageAck, error)); ok {
		return rf(ctx, channelId, messageId, senderId, senderUsername, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, bool) *rtapi.ChannelMessageAck); ok {
		r0 = rf(ctx, channelId, messageId, senderId, senderUsername, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtapi.ChannelMessageAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, bool) error); ok {
		r1 = rf(ctx, channelId, messageId, senderId, senderUsername, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_ChannelMessageRemove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChannelMessageRemove'
type MockNakamaModule_ChannelMessageRemove_Call struct {
	*mock.Call
}

// ChannelMessageRemove is a helper method to define mock.On call
//   - ctx context.Context
//   - channelId string
//   - messageId string
//   - senderId string
//   - senderUsername string
//   - persist bool
func (_e *MockNakamaModule_Expecter) ChannelMessageRemove(ctx interface{}, channelId interface{}, messageId interface{}, senderId interface{}, senderUsername interface{}, persist interface{}) *MockNakamaModule_ChannelMessageRemove_Call {
	return &MockNakamaModule_ChannelMessageRemove_Call{Call: _e.mock.On("ChannelMessageRemove", ctx, channelId, messageId, senderId, senderUsername, persist)}
}

func (_c *MockNakamaModule_ChannelMessageRemove_Call) Run(run func(ctx context.Context, channelId string, messageId string, senderId string, senderUsername string, persist bool)) *MockNakamaModule_ChannelMessageRemove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_ChannelMessageRemove_Call) Return(_a0 *rtapi.ChannelMessageAck, _a1 error) *MockNakamaModule_ChannelMessageRemove_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_ChannelMessageRemove_Call) RunAndReturn(run func(context.Context, string, string, string, string, bool) (*rtapi.ChannelMessageAck, error)) *MockNakamaModule_ChannelMessageRemove_Call {
	_c.Call.Return(run)
	return _c
}

// ChannelMessageSend provides a mock function with given fields: ctx, channelID, content, senderId, senderUsername, persist
func (_m *MockNakamaModule) ChannelMessageSend(ctx context.Context, channelID string, content map[string]interface{}, senderId string, senderUsername string, persist bool) (*rtapi.ChannelMessageAck, error) {
	ret := _m.Called(ctx, channelID, content, senderId, senderUsername, persist)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageSend")
	}

	var r0 *rtapi.ChannelMessageAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, string, string, bool) (*rtapi.ChannelMessageAck, error)); ok {
		return rf(ctx, channelID, content, senderId, senderUsername, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, string, string, bool) *rtapi.ChannelMessageAck); ok {
		r0 = rf(ctx, channelID, content, senderId, senderUsername, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtapi.ChannelMessageAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]interface{}, string, string, bool) error); ok {
		r1 = rf(ctx, channelID, content, senderId, senderUsername, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_ChannelMessageSend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChannelMessageSend'
type MockNakamaModule_ChannelMessageSend_Call struct {
	*mock.Call
}

// ChannelMessageSend is a helper method to define mock.On call
//   - ctx context.Context
//   - channelID string
//   - content map[string]interface{}
//   - senderId string
//   - senderUsername string
//   - persist bool
func (_e *MockNakamaModule_Expecter) ChannelMessageSend(ctx interface{}, channelID interface{}, content interface{}, senderId interface{}, senderUsername interface{}, persist interface{}) *MockNakamaModule_ChannelMessageSend_Call {
	return &MockNakamaModule_ChannelMessageSend_Call{Call: _e.mock.On("ChannelMessageSend", ctx, channelID, content, senderId, senderUsername, persist)}
}

func (_c *MockNakamaModule_ChannelMessageSend_Call) Run(run func(ctx context.Context, channelID string, content map[string]interface{}, senderId string, senderUsername string, persist bool)) *MockNakamaModule_ChannelMessageSend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]interface{}), args[3].(string), args[4].(string), args[5].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_ChannelMessageSend_Call) Return(_a0 *rtapi.ChannelMessageAck, _a1 error) *MockNakamaModule_ChannelMessageSend_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_ChannelMessageSend_Call) RunAndReturn(run func(context.Context, string, map[string]interface{}, string, string, bool) (*rtapi.ChannelMessageAck, error)) *MockNakamaModule_ChannelMessageSend_Call {
	_c.Call.Return(run)
	return _c
}

// ChannelMessageUpdate provides a mock function with given fields: ctx, channelID, messageID, content, senderId, senderUsername, persist
func (_m *MockNakamaModule) ChannelMessageUpdate(ctx context.Context, channelID string, messageID string, content map[string]interface{}, senderId string, senderUsername string, persist bool) (*rtapi.ChannelMessageAck, error) {
	ret := _m.Called(ctx, channelID, messageID, content, senderId, senderUsername, persist)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageUpdate")
	}

	var r0 *rtapi.ChannelMessageAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, string, string, bool) (*rtapi.ChannelMessageAck, error)); ok {
		return rf(ctx, channelID, messageID, content, senderId, senderUsername, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, string, string, bool) *rtapi.ChannelMessageAck); ok {
		r0 = rf(ctx, channelID, messageID, content, senderId, senderUsername, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtapi.ChannelMessageAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, map[string]interface{}, string, string, bool) error); ok {
		r1 = rf(ctx, channelID, messageID, content, senderId, senderUsername, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_ChannelMessageUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChannelMessageUpdate'
type MockNakamaModule_ChannelMessageUpdate_Call struct {
	*mock.Call
}

// ChannelMessageUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - channelID string
//   - messageID string
//   - content map[string]interface{}
//   - senderId string
//   - senderUsername string
//   - persist bool
func (_e *MockNakamaModule_Expecter) ChannelMessageUpdate(ctx interface{}, channelID interface{}, messageID interface{}, content interface{}, senderId interface{}, senderUsername interface{}, persist interface{}) *MockNakamaModule_ChannelMessageUpdate_Call {
	return &MockNakamaModule_ChannelMessageUpdate_Call{Call: _e.mock.On("ChannelMessageUpdate", ctx, channelID, messageID, content, senderId, senderUsername, persist)}
}

func (_c *MockNakamaModule_ChannelMessageUpdate_Call) Run(run func(ctx context.Context, channelID string, messageID string, content map[string]interface{}, senderId string, senderUsername string, persist bool)) *MockNakamaModule_ChannelMessageUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string]interface{}), args[4].(string), args[5].(string), args[6].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_ChannelMessageUpdate_Call) Return(_a0 *rtapi.ChannelMessageAck, _a1 error) *MockNakamaModule_ChannelMessageUpdate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_ChannelMessageUpdate_Call) RunAndReturn(run func(context.Context, string, string, map[string]interface{}, string, string, bool) (*rtapi.ChannelMessageAck, error)) *MockNakamaModule_ChannelMessageUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// ChannelMessagesList provides a mock function with given fields: ctx, channelId, limit, forward, cursor
func (_m *MockNakamaModule) ChannelMessagesList(ctx context.Context, channelId string, limit int, forward bool, cursor string) ([]*api.ChannelMessage, string, string, error) {
	ret := _m.Called(ctx, channelId, limit, forward, cursor)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessagesList")
	}

	var r0 []*api.ChannelMessage
	var r1 string
	var r2 string
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, bool, string) ([]*api.ChannelMessage, string, string, error)); ok {
		return rf(ctx, channelId, limit, forward, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, bool, string) []*api.ChannelMessage); ok {
		r0 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.ChannelMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, bool, string) string); ok {
		r1 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, bool, string) string); ok {
		r2 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, int, bool, string) error); ok {
		r3 = rf(ctx, channelId, limit, forward, cursor)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockNakamaModule_ChannelMessagesList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChannelMessagesList'
type MockNakamaModule_ChannelMessagesList_Call struct {
	*mock.Call
}

// ChannelMessagesList is a helper method to define mock.On call
//   - ctx context.Context
//   - channelId string
//   - limit int
//   - forward bool
//   - cursor string
func (_e *MockNakamaModule_Expecter) ChannelMessagesList(ctx interface{}, channelId interface{}, limit interface{}, forward interface{}, cursor interface{}) *MockNakamaModule_ChannelMessagesList_Call {
	return &MockNakamaModule_ChannelMessagesList_Call{Call: _e.mock.On("ChannelMessagesList", ctx, channelId, limit, forward, cursor)}
}

func (_c *MockNakamaModule_ChannelMessagesList_Call) Run(run func(ctx context.Context, channelId string, limit int, forward bool, cursor string)) *MockNakamaModule_ChannelMessagesList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(bool), args[4].(string))
	})
	return _c
}

func (_c *MockNakamaModule_ChannelMessagesList_Call) Return(messages []*api.ChannelMessage, nextCursor string, prevCursor string, err error) *MockNakamaModule_ChannelMessagesList_Call {
	_c.Call.Return(messages, nextCursor, prevCursor, err)
	return _c
}

func (_c *MockNakamaModule_ChannelMessagesList_Call) RunAndReturn(run func(context.Context, string, int, bool, string) ([]*api.ChannelMessage, string, string, error)) *MockNakamaModule_ChannelMessagesList_Call {
	_c.Call.Return(run)
	return _c
}

// CronNext provides a mock function with given fields: expression, timestamp
func (_m *MockNakamaModule) CronNext(expression string, timestamp int64) (int64, error) {
	ret := _m.Called(expression, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for CronNext")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int64) (int64, error)); ok {
		return rf(expression, timestamp)
	}
	if rf, ok := ret.Get(0).(func(string, int64) int64); ok {
		r0 = rf(expression, timestamp)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string, int64) error); ok {
		r1 = rf(expression, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_CronNext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CronNext'
type MockNakamaModule_CronNext_Call struct {
	*mock.Call
}

// CronNext is a helper method to define mock.On call
//   - expression string
//   - timestamp int64
func (_e *MockNakamaModule_Expecter) CronNext(expression interface{}, timestamp interface{}) *MockNakamaModule_CronNext_Call {
	return &MockNakamaModule_CronNext_Call{Call: _e.mock.On("CronNext", expression, timestamp)}
}

func (_c *MockNakamaModule_CronNext_Call) Run(run func(expression string, timestamp int64)) *MockNakamaModule_CronNext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64))
	})
	return _c
}

func (_c *MockNakamaModule_CronNext_Call) Return(_a0 int64, _a1 error) *MockNakamaModule_CronNext_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_CronNext_Call) RunAndReturn(run func(string, int64) (int64, error)) *MockNakamaModule_CronNext_Call {
	_c.Call.Return(run)
	return _c
}

// CronPrev provides a mock function with given fields: expression, timestamp
func (_m *MockNakamaModule) CronPrev(expression string, timestamp int64) (int64, error) {
	ret := _m.Called(expression, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for CronPrev")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int64) (int64, error)); ok {
		return rf(expression, timestamp)
	}
	if rf, ok := ret.Get(0).(func(string, int64) int64); ok {
		r0 = rf(expression, timestamp)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string, int64) error); ok {
		r1 = rf(expression, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_CronPrev_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CronPrev'
type MockNakamaModule_CronPrev_Call struct {
	*mock.Call
}

// CronPrev is a helper method to define mock.On call
//   - expression string
//   - timestamp int64
func (_e *MockNakamaModule_Expecter) CronPrev(expression interface{}, timestamp interface{}) *MockNakamaModule_CronPrev_Call {
	return &MockNakamaModule_CronPrev_Call{Call: _e.mock.On("CronPrev", expression, timestamp)}
}

func (_c *MockNakamaModule_CronPrev_Call) Run(run func(expression string, timestamp int64)) *MockNakamaModule_CronPrev_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64))
	})
	return _c
}

func (_c *MockNakamaModule_CronPrev_Call) Return(_a0 int64, _a1 error) *MockNakamaModule_CronPrev_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_CronPrev_Call) RunAndReturn(run func(string, int64) (int64, error)) *MockNakamaModule_CronPrev_Call {
	_c.Call.Return(run)
	return _c
}

// Event provides a mock function with given fields: ctx, evt
func (_m *MockNakamaModule) Event(ctx context.Context, evt *api.Event) error {
	ret := _m.Called(ctx, evt)

	if len(ret) == 0 {
		panic("no return value specified for Event")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.Event) error); ok {
		r0 = rf(ctx, evt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_Event_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Event'
type MockNakamaModule_Event_Call struct {
	*mock.Call
}

// Event is a helper method to define mock.On call
//   - ctx context.Context
//   - evt *api.Event
func (_e *MockNakamaModule_Expecter) Event(ctx interface{}, evt interface{}) *MockNakamaModule_Event_Call {
	return &MockNakamaModule_Event_Call{Call: _e.mock.On("Event", ctx, evt)}
}

func (_c *MockNakamaModule_Event_Call) Run(run func(ctx context.Context, evt *api.Event)) *MockNakamaModule_Event_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*api.Event))
	})
	return _c
}

func (_c *MockNakamaModule_Event_Call) Return(_a0 error) *MockNakamaModule_Event_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_Event_Call) RunAndReturn(run func(context.Context, *api.Event) error) *MockNakamaModule_Event_Call {
	_c.Call.Return(run)
	return _c
}

// FriendsAdd provides a mock function with given fields: ctx, userID, username, ids, usernames
func (_m *MockNakamaModule) FriendsAdd(ctx context.Context, userID string, username string, ids []string, usernames []string) error {
	ret := _m.Called(ctx, userID, username, ids, usernames)

	if len(ret) == 0 {
		panic("no return value specified for FriendsAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, []string) error); ok {
		r0 = rf(ctx, userID, username, ids, usernames)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_FriendsAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FriendsAdd'
type MockNakamaModule_FriendsAdd_Call struct {
	*mock.Call
}

// FriendsAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - ids []string
//   - usernames []string
func (_e *MockNakamaModule_Expecter) FriendsAdd(ctx interface{}, userID interface{}, username interface{}, ids interface{}, usernames interface{}) *MockNakamaModule_FriendsAdd_Call {
	return &MockNakamaModule_FriendsAdd_Call{Call: _e.mock.On("FriendsAdd", ctx, userID, username, ids, usernames)}
}

func (_c *MockNakamaModule_FriendsAdd_Call) Run(run func(ctx context.Context, userID string, username string, ids []string, usernames []string)) *MockNakamaModule_FriendsAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string), args[4].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_FriendsAdd_Call) Return(_a0 error) *MockNakamaModule_FriendsAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_FriendsAdd_Call) RunAndReturn(run func(context.Context, string, string, []string, []string) error) *MockNakamaModule_FriendsAdd_Call {
	_c.Call.Return(run)
	return _c
}

// FriendsBlock provides a mock function with given fields: ctx, userID, username, ids, usernames
func (_m *MockNakamaModule) FriendsBlock(ctx context.Context, userID string, username string, ids []string, usernames []string) error {
	ret := _m.Called(ctx, userID, username, ids, usernames)

	if len(ret) == 0 {
		panic("no return value specified for FriendsBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, []string) error); ok {
		r0 = rf(ctx, userID, username, ids, usernames)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_FriendsBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FriendsBlock'
type MockNakamaModule_FriendsBlock_Call struct {
	*mock.Call
}

// FriendsBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - ids []string
//   - usernames []string
func (_e *MockNakamaModule_Expecter) FriendsBlock(ctx interface{}, userID interface{}, username interface{}, ids interface{}, usernames interface{}) *MockNakamaModule_FriendsBlock_Call {
	return &MockNakamaModule_FriendsBlock_Call{Call: _e.mock.On("FriendsBlock", ctx, userID, username, ids, usernames)}
}

func (_c *MockNakamaModule_FriendsBlock_Call) Run(run func(ctx context.Context, userID string, username string, ids []string, usernames []string)) *MockNakamaModule_FriendsBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string), args[4].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_FriendsBlock_Call) Return(_a0 error) *MockNakamaModule_FriendsBlock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_FriendsBlock_Call) RunAndReturn(run func(context.Context, string, string, []string, []string) error) *MockNakamaModule_FriendsBlock_Call {
	_c.Call.Return(run)
	return _c
}

// FriendsDelete provides a mock function with given fields: ctx, userID, username, ids, usernames
func (_m *MockNakamaModule) FriendsDelete(ctx context.Context, userID string, username string, ids []string, usernames []string) error {
	ret := _m.Called(ctx, userID, username, ids, usernames)

	if len(ret) == 0 {
		panic("no return value specified for FriendsDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, []string) error); ok {
		r0 = rf(ctx, userID, username, ids, usernames)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_FriendsDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FriendsDelete'
type MockNakamaModule_FriendsDelete_Call struct {
	*mock.Call
}

// FriendsDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - ids []string
//   - usernames []string
func (_e *MockNakamaModule_Expecter) FriendsDelete(ctx interface{}, userID interface{}, username interface{}, ids interface{}, usernames interface{}) *MockNakamaModule_FriendsDelete_Call {
	return &MockNakamaModule_FriendsDelete_Call{Call: _e.mock.On("FriendsDelete", ctx, userID, username, ids, usernames)}
}

func (_c *MockNakamaModule_FriendsDelete_Call) Run(run func(ctx context.Context, userID string, username string, ids []string, usernames []string)) *MockNakamaModule_FriendsDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string), args[4].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_FriendsDelete_Call) Return(_a0 error) *MockNakamaModule_FriendsDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_FriendsDelete_Call) RunAndReturn(run func(context.Context, string, string, []string, []string) error) *MockNakamaModule_FriendsDelete_Call {
	_c.Call.Return(run)
	return _c
}

// FriendsList provides a mock function with given fields: ctx, userID, limit, state, cursor
func (_m *MockNakamaModule) FriendsList(ctx context.Context, userID string, limit int, state *int, cursor string) ([]*api.Friend, string, error) {
	ret := _m.Called(ctx, userID, limit, state, cursor)

	if len(ret) == 0 {
		panic("no return value specified for FriendsList")
	}

	var r0 []*api.Friend
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) ([]*api.Friend, string, error)); ok {
		return rf(ctx, userID, limit, state, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) []*api.Friend); ok {
		r0 = rf(ctx, userID, limit, state, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Friend)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *int, string) string); ok {
		r1 = rf(ctx, userID, limit, state, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, *int, string) error); ok {
		r2 = rf(ctx, userID, limit, state, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_FriendsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FriendsList'
type MockNakamaModule_FriendsList_Call struct {
	*mock.Call
}

// FriendsList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - state *int
//   - cursor string
func (_e *MockNakamaModule_Expecter) FriendsList(ctx interface{}, userID interface{}, limit interface{}, state interface{}, cursor interface{}) *MockNakamaModule_FriendsList_Call {
	return &MockNakamaModule_FriendsList_Call{Call: _e.mock.On("FriendsList", ctx, userID, limit, state, cursor)}
}

func (_c *MockNakamaModule_FriendsList_Call) Run(run func(ctx context.Context, userID string, limit int, state *int, cursor string)) *MockNakamaModule_FriendsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*int), args[4].(string))
	})
	return _c
}

func (_c *MockNakamaModule_FriendsList_Call) Return(_a0 []*api.Friend, _a1 string, _a2 error) *MockNakamaModule_FriendsList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_FriendsList_Call) RunAndReturn(run func(context.Context, string, int, *int, string) ([]*api.Friend, string, error)) *MockNakamaModule_FriendsList_Call {
	_c.Call.Return(run)
	return _c
}

// FriendsOfFriendsList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *MockNakamaModule) FriendsOfFriendsList(ctx context.Context, userID string, limit int, cursor string) ([]*api.FriendsOfFriendsList_FriendOfFriend, string, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for FriendsOfFriendsList")
	}

	var r0 []*api.FriendsOfFriendsList_FriendOfFriend
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) ([]*api.FriendsOfFriendsList_FriendOfFriend, string, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) []*api.FriendsOfFriendsList_FriendOfFriend); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.FriendsOfFriendsList_FriendOfFriend)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) string); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, string) error); ok {
		r2 = rf(ctx, userID, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_FriendsOfFriendsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FriendsOfFriendsList'
type MockNakamaModule_FriendsOfFriendsList_Call struct {
	*mock.Call
}

// FriendsOfFriendsList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - cursor string
func (_e *MockNakamaModule_Expecter) FriendsOfFriendsList(ctx interface{}, userID interface{}, limit interface{}, cursor interface{}) *MockNakamaModule_FriendsOfFriendsList_Call {
	return &MockNakamaModule_FriendsOfFriendsList_Call{Call: _e.mock.On("FriendsOfFriendsList", ctx, userID, limit, cursor)}
}

func (_c *MockNakamaModule_FriendsOfFriendsList_Call) Run(run func(ctx context.Context, userID string, limit int, cursor string)) *MockNakamaModule_FriendsOfFriendsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_FriendsOfFriendsList_Call) Return(_a0 []*api.FriendsOfFriendsList_FriendOfFriend, _a1 string, _a2 error) *MockNakamaModule_FriendsOfFriendsList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_FriendsOfFriendsList_Call) RunAndReturn(run func(context.Context, string, int, string) ([]*api.FriendsOfFriendsList_FriendOfFriend, string, error)) *MockNakamaModule_FriendsOfFriendsList_Call {
	_c.Call.Return(run)
	return _c
}

// GetFleetManager provides a mock function with no fields
func (_m *MockNakamaModule) GetFleetManager() runtime.FleetManager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetFleetManager")
	}

	var r0 runtime.FleetManager
	if rf, ok := ret.Get(0).(func() runtime.FleetManager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.FleetManager)
		}
	}

	return r0
}

// MockNakamaModule_GetFleetManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFleetManager'
type MockNakamaModule_GetFleetManager_Call struct {
	*mock.Call
}

// GetFleetManager is a helper method to define mock.On call
func (_e *MockNakamaModule_Expecter) GetFleetManager() *MockNakamaModule_GetFleetManager_Call {
	return &MockNakamaModule_GetFleetManager_Call{Call: _e.mock.On("GetFleetManager")}
}

func (_c *MockNakamaModule_GetFleetManager_Call) Run(run func()) *MockNakamaModule_GetFleetManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockNakamaModule_GetFleetManager_Call) Return(_a0 runtime.FleetManager) *MockNakamaModule_GetFleetManager_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GetFleetManager_Call) RunAndReturn(run func() runtime.FleetManager) *MockNakamaModule_GetFleetManager_Call {
	_c.Call.Return(run)
	return _c
}

// GetSatori provides a mock function with no fields
func (_m *MockNakamaModule) GetSatori() runtime.Satori {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSatori")
	}

	var r0 runtime.Satori
	if rf, ok := ret.Get(0).(func() runtime.Satori); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.Satori)
		}
	}

	return r0
}

// MockNakamaModule_GetSatori_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSatori'
type MockNakamaModule_GetSatori_Call struct {
	*mock.Call
}

// GetSatori is a helper method to define mock.On call
func (_e *MockNakamaModule_Expecter) GetSatori() *MockNakamaModule_GetSatori_Call {
	return &MockNakamaModule_GetSatori_Call{Call: _e.mock.On("GetSatori")}
}

func (_c *MockNakamaModule_GetSatori_Call) Run(run func()) *MockNakamaModule_GetSatori_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockNakamaModule_GetSatori_Call) Return(_a0 runtime.Satori) *MockNakamaModule_GetSatori_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GetSatori_Call) RunAndReturn(run func() runtime.Satori) *MockNakamaModule_GetSatori_Call {
	_c.Call.Return(run)
	return _c
}

// GroupCreate provides a mock function with given fields: ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount
func (_m *MockNakamaModule) GroupCreate(ctx context.Context, userID string, name string, creatorID string, langTag string, description string, avatarUrl string, open bool, metadata map[string]interface{}, maxCount int) (*api.Group, error) {
	ret := _m.Called(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)

	if len(ret) == 0 {
		panic("no return value specified for GroupCreate")
	}

	var r0 *api.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) (*api.Group, error)); ok {
		return rf(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) *api.Group); ok {
		r0 = rf(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) error); ok {
		r1 = rf(ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_GroupCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupCreate'
type MockNakamaModule_GroupCreate_Call struct {
	*mock.Call
}

// GroupCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - name string
//   - creatorID string
//   - langTag string
//   - description string
//   - avatarUrl string
//   - open bool
//   - metadata map[string]interface{}
//   - maxCount int
func (_e *MockNakamaModule_Expecter) GroupCreate(ctx interface{}, userID interface{}, name interface{}, creatorID interface{}, langTag interface{}, description interface{}, avatarUrl interface{}, open interface{}, metadata interface{}, maxCount interface{}) *MockNakamaModule_GroupCreate_Call {
	return &MockNakamaModule_GroupCreate_Call{Call: _e.mock.On("GroupCreate", ctx, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)}
}

func (_c *MockNakamaModule_GroupCreate_Call) Run(run func(ctx context.Context, userID string, name string, creatorID string, langTag string, description string, avatarUrl string, open bool, metadata map[string]interface{}, maxCount int)) *MockNakamaModule_GroupCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string), args[6].(string), args[7].(bool), args[8].(map[string]interface{}), args[9].(int))
	})
	return _c
}

func (_c *MockNakamaModule_GroupCreate_Call) Return(_a0 *api.Group, _a1 error) *MockNakamaModule_GroupCreate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_GroupCreate_Call) RunAndReturn(run func(context.Context, string, string, string, string, string, string, bool, map[string]interface{}, int) (*api.Group, error)) *MockNakamaModule_GroupCreate_Call {
	_c.Call.Return(run)
	return _c
}

// GroupDelete provides a mock function with given fields: ctx, id
func (_m *MockNakamaModule) GroupDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GroupDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_GroupDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupDelete'
type MockNakamaModule_GroupDelete_Call struct {
	*mock.Call
}

// GroupDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockNakamaModule_Expecter) GroupDelete(ctx interface{}, id interface{}) *MockNakamaModule_GroupDelete_Call {
	return &MockNakamaModule_GroupDelete_Call{Call: _e.mock.On("GroupDelete", ctx, id)}
}

func (_c *MockNakamaModule_GroupDelete_Call) Run(run func(ctx context.Context, id string)) *MockNakamaModule_GroupDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupDelete_Call) Return(_a0 error) *MockNakamaModule_GroupDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GroupDelete_Call) RunAndReturn(run func(context.Context, string) error) *MockNakamaModule_GroupDelete_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUpdate provides a mock function with given fields: ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount
func (_m *MockNakamaModule) GroupUpdate(ctx context.Context, id string, userID string, name string, creatorID string, langTag string, description string, avatarUrl string, open bool, metadata map[string]interface{}, maxCount int) error {
	ret := _m.Called(ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)

	if len(ret) == 0 {
		panic("no return value specified for GroupUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, string, bool, map[string]interface{}, int) error); ok {
		r0 = rf(ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_GroupUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUpdate'
type MockNakamaModule_GroupUpdate_Call struct {
	*mock.Call
}

// GroupUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - userID string
//   - name string
//   - creatorID string
//   - langTag string
//   - description string
//   - avatarUrl string
//   - open bool
//   - metadata map[string]interface{}
//   - maxCount int
func (_e *MockNakamaModule_Expecter) GroupUpdate(ctx interface{}, id interface{}, userID interface{}, name interface{}, creatorID interface{}, langTag interface{}, description interface{}, avatarUrl interface{}, open interface{}, metadata interface{}, maxCount interface{}) *MockNakamaModule_GroupUpdate_Call {
	return &MockNakamaModule_GroupUpdate_Call{Call: _e.mock.On("GroupUpdate", ctx, id, userID, name, creatorID, langTag, description, avatarUrl, open, metadata, maxCount)}
}

func (_c *MockNakamaModule_GroupUpdate_Call) Run(run func(ctx context.Context, id string, userID string, name string, creatorID string, langTag string, description string, avatarUrl string, open bool, metadata map[string]interface{}, maxCount int)) *MockNakamaModule_GroupUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string), args[6].(string), args[7].(string), args[8].(bool), args[9].(map[string]interface{}), args[10].(int))
	})
	return _c
}

func (_c *MockNakamaModule_GroupUpdate_Call) Return(_a0 error) *MockNakamaModule_GroupUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GroupUpdate_Call) RunAndReturn(run func(context.Context, string, string, string, string, string, string, string, bool, map[string]interface{}, int) error) *MockNakamaModule_GroupUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUserJoin provides a mock function with given fields: ctx, groupID, userID, username
func (_m *MockNakamaModule) GroupUserJoin(ctx context.Context, groupID string, userID string, username string) error {
	ret := _m.Called(ctx, groupID, userID, username)

	if len(ret) == 0 {
		panic("no return value specified for GroupUserJoin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, groupID, userID, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_GroupUserJoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUserJoin'
type MockNakamaModule_GroupUserJoin_Call struct {
	*mock.Call
}

// GroupUserJoin is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
//   - userID string
//   - username string
func (_e *MockNakamaModule_Expecter) GroupUserJoin(ctx interface{}, groupID interface{}, userID interface{}, username interface{}) *MockNakamaModule_GroupUserJoin_Call {
	return &MockNakamaModule_GroupUserJoin_Call{Call: _e.mock.On("GroupUserJoin", ctx, groupID, userID, username)}
}

func (_c *MockNakamaModule_GroupUserJoin_Call) Run(run func(ctx context.Context, groupID string, userID string, username string)) *MockNakamaModule_GroupUserJoin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupUserJoin_Call) Return(_a0 error) *MockNakamaModule_GroupUserJoin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GroupUserJoin_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockNakamaModule_GroupUserJoin_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUserLeave provides a mock function with given fields: ctx, groupID, userID, username
func (_m *MockNakamaModule) GroupUserLeave(ctx context.Context, groupID string, userID string, username string) error {
	ret := _m.Called(ctx, groupID, userID, username)

	if len(ret) == 0 {
		panic("no return value specified for GroupUserLeave")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, groupID, userID, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_GroupUserLeave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUserLeave'
type MockNakamaModule_GroupUserLeave_Call struct {
	*mock.Call
}

// GroupUserLeave is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
//   - userID string
//   - username string
func (_e *MockNakamaModule_Expecter) GroupUserLeave(ctx interface{}, groupID interface{}, userID interface{}, username interface{}) *MockNakamaModule_GroupUserLeave_Call {
	return &MockNakamaModule_GroupUserLeave_Call{Call: _e.mock.On("GroupUserLeave", ctx, groupID, userID, username)}
}

func (_c *MockNakamaModule_GroupUserLeave_Call) Run(run func(ctx context.Context, groupID string, userID string, username string)) *MockNakamaModule_GroupUserLeave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupUserLeave_Call) Return(_a0 error) *MockNakamaModule_GroupUserLeave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GroupUserLeave_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockNakamaModule_GroupUserLeave_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersAdd provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *MockNakamaModule) GroupUsersAdd(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_GroupUsersAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersAdd'
type MockNakamaModule_GroupUsersAdd_Call struct {
	*mock.Call
}

// GroupUsersAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - groupID string
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) GroupUsersAdd(ctx interface{}, callerID interface{}, groupID interface{}, userIDs interface{}) *MockNakamaModule_GroupUsersAdd_Call {
	return &MockNakamaModule_GroupUsersAdd_Call{Call: _e.mock.On("GroupUsersAdd", ctx, callerID, groupID, userIDs)}
}

func (_c *MockNakamaModule_GroupUsersAdd_Call) Run(run func(ctx context.Context, callerID string, groupID string, userIDs []string)) *MockNakamaModule_GroupUsersAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupUsersAdd_Call) Return(_a0 error) *MockNakamaModule_GroupUsersAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GroupUsersAdd_Call) RunAndReturn(run func(context.Context, string, string, []string) error) *MockNakamaModule_GroupUsersAdd_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersBan provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *MockNakamaModule) GroupUsersBan(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersBan")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_GroupUsersBan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersBan'
type MockNakamaModule_GroupUsersBan_Call struct {
	*mock.Call
}

// GroupUsersBan is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - groupID string
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) GroupUsersBan(ctx interface{}, callerID interface{}, groupID interface{}, userIDs interface{}) *MockNakamaModule_GroupUsersBan_Call {
	return &MockNakamaModule_GroupUsersBan_Call{Call: _e.mock.On("GroupUsersBan", ctx, callerID, groupID, userIDs)}
}

func (_c *MockNakamaModule_GroupUsersBan_Call) Run(run func(ctx context.Context, callerID string, groupID string, userIDs []string)) *MockNakamaModule_GroupUsersBan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupUsersBan_Call) Return(_a0 error) *MockNakamaModule_GroupUsersBan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GroupUsersBan_Call) RunAndReturn(run func(context.Context, string, string, []string) error) *MockNakamaModule_GroupUsersBan_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersDemote provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *MockNakamaModule) GroupUsersDemote(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersDemote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_GroupUsersDemote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersDemote'
type MockNakamaModule_GroupUsersDemote_Call struct {
	*mock.Call
}

// GroupUsersDemote is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - groupID string
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) GroupUsersDemote(ctx interface{}, callerID interface{}, groupID interface{}, userIDs interface{}) *MockNakamaModule_GroupUsersDemote_Call {
	return &MockNakamaModule_GroupUsersDemote_Call{Call: _e.mock.On("GroupUsersDemote", ctx, callerID, groupID, userIDs)}
}

func (_c *MockNakamaModule_GroupUsersDemote_Call) Run(run func(ctx context.Context, callerID string, groupID string, userIDs []string)) *MockNakamaModule_GroupUsersDemote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupUsersDemote_Call) Return(_a0 error) *MockNakamaModule_GroupUsersDemote_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GroupUsersDemote_Call) RunAndReturn(run func(context.Context, string, string, []string) error) *MockNakamaModule_GroupUsersDemote_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersKick provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *MockNakamaModule) GroupUsersKick(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersKick")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_GroupUsersKick_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersKick'
type MockNakamaModule_GroupUsersKick_Call struct {
	*mock.Call
}

// GroupUsersKick is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - groupID string
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) GroupUsersKick(ctx interface{}, callerID interface{}, groupID interface{}, userIDs interface{}) *MockNakamaModule_GroupUsersKick_Call {
	return &MockNakamaModule_GroupUsersKick_Call{Call: _e.mock.On("GroupUsersKick", ctx, callerID, groupID, userIDs)}
}

func (_c *MockNakamaModule_GroupUsersKick_Call) Run(run func(ctx context.Context, callerID string, groupID string, userIDs []string)) *MockNakamaModule_GroupUsersKick_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupUsersKick_Call) Return(_a0 error) *MockNakamaModule_GroupUsersKick_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GroupUsersKick_Call) RunAndReturn(run func(context.Context, string, string, []string) error) *MockNakamaModule_GroupUsersKick_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersList provides a mock function with given fields: ctx, id, limit, state, cursor
func (_m *MockNakamaModule) GroupUsersList(ctx context.Context, id string, limit int, state *int, cursor string) ([]*api.GroupUserList_GroupUser, string, error) {
	ret := _m.Called(ctx, id, limit, state, cursor)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersList")
	}

	var r0 []*api.GroupUserList_GroupUser
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) ([]*api.GroupUserList_GroupUser, string, error)); ok {
		return rf(ctx, id, limit, state, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) []*api.GroupUserList_GroupUser); ok {
		r0 = rf(ctx, id, limit, state, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.GroupUserList_GroupUser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *int, string) string); ok {
		r1 = rf(ctx, id, limit, state, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, *int, string) error); ok {
		r2 = rf(ctx, id, limit, state, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_GroupUsersList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersList'
type MockNakamaModule_GroupUsersList_Call struct {
	*mock.Call
}

// GroupUsersList is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - limit int
//   - state *int
//   - cursor string
func (_e *MockNakamaModule_Expecter) GroupUsersList(ctx interface{}, id interface{}, limit interface{}, state interface{}, cursor interface{}) *MockNakamaModule_GroupUsersList_Call {
	return &MockNakamaModule_GroupUsersList_Call{Call: _e.mock.On("GroupUsersList", ctx, id, limit, state, cursor)}
}

func (_c *MockNakamaModule_GroupUsersList_Call) Run(run func(ctx context.Context, id string, limit int, state *int, cursor string)) *MockNakamaModule_GroupUsersList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*int), args[4].(string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupUsersList_Call) Return(_a0 []*api.GroupUserList_GroupUser, _a1 string, _a2 error) *MockNakamaModule_GroupUsersList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_GroupUsersList_Call) RunAndReturn(run func(context.Context, string, int, *int, string) ([]*api.GroupUserList_GroupUser, string, error)) *MockNakamaModule_GroupUsersList_Call {
	_c.Call.Return(run)
	return _c
}

// GroupUsersPromote provides a mock function with given fields: ctx, callerID, groupID, userIDs
func (_m *MockNakamaModule) GroupUsersPromote(ctx context.Context, callerID string, groupID string, userIDs []string) error {
	ret := _m.Called(ctx, callerID, groupID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupUsersPromote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string) error); ok {
		r0 = rf(ctx, callerID, groupID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_GroupUsersPromote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupUsersPromote'
type MockNakamaModule_GroupUsersPromote_Call struct {
	*mock.Call
}

// GroupUsersPromote is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - groupID string
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) GroupUsersPromote(ctx interface{}, callerID interface{}, groupID interface{}, userIDs interface{}) *MockNakamaModule_GroupUsersPromote_Call {
	return &MockNakamaModule_GroupUsersPromote_Call{Call: _e.mock.On("GroupUsersPromote", ctx, callerID, groupID, userIDs)}
}

func (_c *MockNakamaModule_GroupUsersPromote_Call) Run(run func(ctx context.Context, callerID string, groupID string, userIDs []string)) *MockNakamaModule_GroupUsersPromote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupUsersPromote_Call) Return(_a0 error) *MockNakamaModule_GroupUsersPromote_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_GroupUsersPromote_Call) RunAndReturn(run func(context.Context, string, string, []string) error) *MockNakamaModule_GroupUsersPromote_Call {
	_c.Call.Return(run)
	return _c
}

// GroupsGetId provides a mock function with given fields: ctx, groupIDs
func (_m *MockNakamaModule) GroupsGetId(ctx context.Context, groupIDs []string) ([]*api.Group, error) {
	ret := _m.Called(ctx, groupIDs)

	if len(ret) == 0 {
		panic("no return value specified for GroupsGetId")
	}

	var r0 []*api.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Group, error)); ok {
		return rf(ctx, groupIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Group); ok {
		r0 = rf(ctx, groupIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, groupIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_GroupsGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupsGetId'
type MockNakamaModule_GroupsGetId_Call struct {
	*mock.Call
}

// GroupsGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - groupIDs []string
func (_e *MockNakamaModule_Expecter) GroupsGetId(ctx interface{}, groupIDs interface{}) *MockNakamaModule_GroupsGetId_Call {
	return &MockNakamaModule_GroupsGetId_Call{Call: _e.mock.On("GroupsGetId", ctx, groupIDs)}
}

func (_c *MockNakamaModule_GroupsGetId_Call) Run(run func(ctx context.Context, groupIDs []string)) *MockNakamaModule_GroupsGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupsGetId_Call) Return(_a0 []*api.Group, _a1 error) *MockNakamaModule_GroupsGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_GroupsGetId_Call) RunAndReturn(run func(context.Context, []string) ([]*api.Group, error)) *MockNakamaModule_GroupsGetId_Call {
	_c.Call.Return(run)
	return _c
}

// GroupsGetRandom provides a mock function with given fields: ctx, count
func (_m *MockNakamaModule) GroupsGetRandom(ctx context.Context, count int) ([]*api.Group, error) {
	ret := _m.Called(ctx, count)

	if len(ret) == 0 {
		panic("no return value specified for GroupsGetRandom")
	}

	var r0 []*api.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*api.Group, error)); ok {
		return rf(ctx, count)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*api.Group); ok {
		r0 = rf(ctx, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_GroupsGetRandom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupsGetRandom'
type MockNakamaModule_GroupsGetRandom_Call struct {
	*mock.Call
}

// GroupsGetRandom is a helper method to define mock.On call
//   - ctx context.Context
//   - count int
func (_e *MockNakamaModule_Expecter) GroupsGetRandom(ctx interface{}, count interface{}) *MockNakamaModule_GroupsGetRandom_Call {
	return &MockNakamaModule_GroupsGetRandom_Call{Call: _e.mock.On("GroupsGetRandom", ctx, count)}
}

func (_c *MockNakamaModule_GroupsGetRandom_Call) Run(run func(ctx context.Context, count int)) *MockNakamaModule_GroupsGetRandom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockNakamaModule_GroupsGetRandom_Call) Return(_a0 []*api.Group, _a1 error) *MockNakamaModule_GroupsGetRandom_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_GroupsGetRandom_Call) RunAndReturn(run func(context.Context, int) ([]*api.Group, error)) *MockNakamaModule_GroupsGetRandom_Call {
	_c.Call.Return(run)
	return _c
}

// GroupsList provides a mock function with given fields: ctx, name, langTag, members, open, limit, cursor
func (_m *MockNakamaModule) GroupsList(ctx context.Context, name string, langTag string, members *int, open *bool, limit int, cursor string) ([]*api.Group, string, error) {
	ret := _m.Called(ctx, name, langTag, members, open, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for GroupsList")
	}

	var r0 []*api.Group
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *int, *bool, int, string) ([]*api.Group, string, error)); ok {
		return rf(ctx, name, langTag, members, open, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *int, *bool, int, string) []*api.Group); ok {
		r0 = rf(ctx, name, langTag, members, open, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *int, *bool, int, string) string); ok {
		r1 = rf(ctx, name, langTag, members, open, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, *int, *bool, int, string) error); ok {
		r2 = rf(ctx, name, langTag, members, open, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_GroupsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupsList'
type MockNakamaModule_GroupsList_Call struct {
	*mock.Call
}

// GroupsList is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - langTag string
//   - members *int
//   - open *bool
//   - limit int
//   - cursor string
func (_e *MockNakamaModule_Expecter) GroupsList(ctx interface{}, name interface{}, langTag interface{}, members interface{}, open interface{}, limit interface{}, cursor interface{}) *MockNakamaModule_GroupsList_Call {
	return &MockNakamaModule_GroupsList_Call{Call: _e.mock.On("GroupsList", ctx, name, langTag, members, open, limit, cursor)}
}

func (_c *MockNakamaModule_GroupsList_Call) Run(run func(ctx context.Context, name string, langTag string, members *int, open *bool, limit int, cursor string)) *MockNakamaModule_GroupsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*int), args[4].(*bool), args[5].(int), args[6].(string))
	})
	return _c
}

func (_c *MockNakamaModule_GroupsList_Call) Return(_a0 []*api.Group, _a1 string, _a2 error) *MockNakamaModule_GroupsList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_GroupsList_Call) RunAndReturn(run func(context.Context, string, string, *int, *bool, int, string) ([]*api.Group, string, error)) *MockNakamaModule_GroupsList_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardCreate provides a mock function with given fields: ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, enableRanks
func (_m *MockNakamaModule) LeaderboardCreate(ctx context.Context, id string, authoritative bool, sortOrder string, operator string, resetSchedule string, metadata map[string]interface{}, enableRanks bool) error {
	ret := _m.Called(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, enableRanks)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, string, string, map[string]interface{}, bool) error); ok {
		r0 = rf(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, enableRanks)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LeaderboardCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardCreate'
type MockNakamaModule_LeaderboardCreate_Call struct {
	*mock.Call
}

// LeaderboardCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - authoritative bool
//   - sortOrder string
//   - operator string
//   - resetSchedule string
//   - metadata map[string]interface{}
//   - enableRanks bool
func (_e *MockNakamaModule_Expecter) LeaderboardCreate(ctx interface{}, id interface{}, authoritative interface{}, sortOrder interface{}, operator interface{}, resetSchedule interface{}, metadata interface{}, enableRanks interface{}) *MockNakamaModule_LeaderboardCreate_Call {
	return &MockNakamaModule_LeaderboardCreate_Call{Call: _e.mock.On("LeaderboardCreate", ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, enableRanks)}
}

func (_c *MockNakamaModule_LeaderboardCreate_Call) Run(run func(ctx context.Context, id string, authoritative bool, sortOrder string, operator string, resetSchedule string, metadata map[string]interface{}, enableRanks bool)) *MockNakamaModule_LeaderboardCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool), args[3].(string), args[4].(string), args[5].(string), args[6].(map[string]interface{}), args[7].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_LeaderboardCreate_Call) Return(_a0 error) *MockNakamaModule_LeaderboardCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LeaderboardCreate_Call) RunAndReturn(run func(context.Context, string, bool, string, string, string, map[string]interface{}, bool) error) *MockNakamaModule_LeaderboardCreate_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardDelete provides a mock function with given fields: ctx, id
func (_m *MockNakamaModule) LeaderboardDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LeaderboardDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardDelete'
type MockNakamaModule_LeaderboardDelete_Call struct {
	*mock.Call
}

// LeaderboardDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockNakamaModule_Expecter) LeaderboardDelete(ctx interface{}, id interface{}) *MockNakamaModule_LeaderboardDelete_Call {
	return &MockNakamaModule_LeaderboardDelete_Call{Call: _e.mock.On("LeaderboardDelete", ctx, id)}
}

func (_c *MockNakamaModule_LeaderboardDelete_Call) Run(run func(ctx context.Context, id string)) *MockNakamaModule_LeaderboardDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LeaderboardDelete_Call) Return(_a0 error) *MockNakamaModule_LeaderboardDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LeaderboardDelete_Call) RunAndReturn(run func(context.Context, string) error) *MockNakamaModule_LeaderboardDelete_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardList provides a mock function with given fields: limit, cursor
func (_m *MockNakamaModule) LeaderboardList(limit int, cursor string) (*api.LeaderboardList, error) {
	ret := _m.Called(limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardList")
	}

	var r0 *api.LeaderboardList
	var r1 error
	if rf, ok := ret.Get(0).(func(int, string) (*api.LeaderboardList, error)); ok {
		return rf(limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(int, string) *api.LeaderboardList); ok {
		r0 = rf(limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardList)
		}
	}

	if rf, ok := ret.Get(1).(func(int, string) error); ok {
		r1 = rf(limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_LeaderboardList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardList'
type MockNakamaModule_LeaderboardList_Call struct {
	*mock.Call
}

// LeaderboardList is a helper method to define mock.On call
//   - limit int
//   - cursor string
func (_e *MockNakamaModule_Expecter) LeaderboardList(limit interface{}, cursor interface{}) *MockNakamaModule_LeaderboardList_Call {
	return &MockNakamaModule_LeaderboardList_Call{Call: _e.mock.On("LeaderboardList", limit, cursor)}
}

func (_c *MockNakamaModule_LeaderboardList_Call) Run(run func(limit int, cursor string)) *MockNakamaModule_LeaderboardList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LeaderboardList_Call) Return(_a0 *api.LeaderboardList, _a1 error) *MockNakamaModule_LeaderboardList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_LeaderboardList_Call) RunAndReturn(run func(int, string) (*api.LeaderboardList, error)) *MockNakamaModule_LeaderboardList_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRanksDisable provides a mock function with given fields: ctx, id
func (_m *MockNakamaModule) LeaderboardRanksDisable(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRanksDisable")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LeaderboardRanksDisable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRanksDisable'
type MockNakamaModule_LeaderboardRanksDisable_Call struct {
	*mock.Call
}

// LeaderboardRanksDisable is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockNakamaModule_Expecter) LeaderboardRanksDisable(ctx interface{}, id interface{}) *MockNakamaModule_LeaderboardRanksDisable_Call {
	return &MockNakamaModule_LeaderboardRanksDisable_Call{Call: _e.mock.On("LeaderboardRanksDisable", ctx, id)}
}

func (_c *MockNakamaModule_LeaderboardRanksDisable_Call) Run(run func(ctx context.Context, id string)) *MockNakamaModule_LeaderboardRanksDisable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LeaderboardRanksDisable_Call) Return(_a0 error) *MockNakamaModule_LeaderboardRanksDisable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LeaderboardRanksDisable_Call) RunAndReturn(run func(context.Context, string) error) *MockNakamaModule_LeaderboardRanksDisable_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRecordDelete provides a mock function with given fields: ctx, id, ownerID
func (_m *MockNakamaModule) LeaderboardRecordDelete(ctx context.Context, id string, ownerID string) error {
	ret := _m.Called(ctx, id, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRecordDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, id, ownerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LeaderboardRecordDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRecordDelete'
type MockNakamaModule_LeaderboardRecordDelete_Call struct {
	*mock.Call
}

// LeaderboardRecordDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
func (_e *MockNakamaModule_Expecter) LeaderboardRecordDelete(ctx interface{}, id interface{}, ownerID interface{}) *MockNakamaModule_LeaderboardRecordDelete_Call {
	return &MockNakamaModule_LeaderboardRecordDelete_Call{Call: _e.mock.On("LeaderboardRecordDelete", ctx, id, ownerID)}
}

func (_c *MockNakamaModule_LeaderboardRecordDelete_Call) Run(run func(ctx context.Context, id string, ownerID string)) *MockNakamaModule_LeaderboardRecordDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LeaderboardRecordDelete_Call) Return(_a0 error) *MockNakamaModule_LeaderboardRecordDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LeaderboardRecordDelete_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_LeaderboardRecordDelete_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRecordWrite provides a mock function with given fields: ctx, id, ownerID, username, score, subscore, metadata, overrideOperator
func (_m *MockNakamaModule) LeaderboardRecordWrite(ctx context.Context, id string, ownerID string, username string, score int64, subscore int64, metadata map[string]interface{}, overrideOperator *int) (*api.LeaderboardRecord, error) {
	ret := _m.Called(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRecordWrite")
	}

	var r0 *api.LeaderboardRecord
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) (*api.LeaderboardRecord, error)); ok {
		return rf(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) *api.LeaderboardRecord); ok {
		r0 = rf(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) error); ok {
		r1 = rf(ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_LeaderboardRecordWrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRecordWrite'
type MockNakamaModule_LeaderboardRecordWrite_Call struct {
	*mock.Call
}

// LeaderboardRecordWrite is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - username string
//   - score int64
//   - subscore int64
//   - metadata map[string]interface{}
//   - overrideOperator *int
func (_e *MockNakamaModule_Expecter) LeaderboardRecordWrite(ctx interface{}, id interface{}, ownerID interface{}, username interface{}, score interface{}, subscore interface{}, metadata interface{}, overrideOperator interface{}) *MockNakamaModule_LeaderboardRecordWrite_Call {
	return &MockNakamaModule_LeaderboardRecordWrite_Call{Call: _e.mock.On("LeaderboardRecordWrite", ctx, id, ownerID, username, score, subscore, metadata, overrideOperator)}
}

func (_c *MockNakamaModule_LeaderboardRecordWrite_Call) Run(run func(ctx context.Context, id string, ownerID string, username string, score int64, subscore int64, metadata map[string]interface{}, overrideOperator *int)) *MockNakamaModule_LeaderboardRecordWrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64), args[5].(int64), args[6].(map[string]interface{}), args[7].(*int))
	})
	return _c
}

func (_c *MockNakamaModule_LeaderboardRecordWrite_Call) Return(_a0 *api.LeaderboardRecord, _a1 error) *MockNakamaModule_LeaderboardRecordWrite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_LeaderboardRecordWrite_Call) RunAndReturn(run func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) (*api.LeaderboardRecord, error)) *MockNakamaModule_LeaderboardRecordWrite_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRecordsHaystack provides a mock function with given fields: ctx, id, ownerID, limit, cursor, expiry
func (_m *MockNakamaModule) LeaderboardRecordsHaystack(ctx context.Context, id string, ownerID string, limit int, cursor string, expiry int64) (*api.LeaderboardRecordList, error) {
	ret := _m.Called(ctx, id, ownerID, limit, cursor, expiry)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRecordsHaystack")
	}

	var r0 *api.LeaderboardRecordList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) (*api.LeaderboardRecordList, error)); ok {
		return rf(ctx, id, ownerID, limit, cursor, expiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) *api.LeaderboardRecordList); ok {
		r0 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardRecordList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int, string, int64) error); ok {
		r1 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_LeaderboardRecordsHaystack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRecordsHaystack'
type MockNakamaModule_LeaderboardRecordsHaystack_Call struct {
	*mock.Call
}

// LeaderboardRecordsHaystack is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - limit int
//   - cursor string
//   - expiry int64
func (_e *MockNakamaModule_Expecter) LeaderboardRecordsHaystack(ctx interface{}, id interface{}, ownerID interface{}, limit interface{}, cursor interface{}, expiry interface{}) *MockNakamaModule_LeaderboardRecordsHaystack_Call {
	return &MockNakamaModule_LeaderboardRecordsHaystack_Call{Call: _e.mock.On("LeaderboardRecordsHaystack", ctx, id, ownerID, limit, cursor, expiry)}
}

func (_c *MockNakamaModule_LeaderboardRecordsHaystack_Call) Run(run func(ctx context.Context, id string, ownerID string, limit int, cursor string, expiry int64)) *MockNakamaModule_LeaderboardRecordsHaystack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(string), args[5].(int64))
	})
	return _c
}

func (_c *MockNakamaModule_LeaderboardRecordsHaystack_Call) Return(_a0 *api.LeaderboardRecordList, _a1 error) *MockNakamaModule_LeaderboardRecordsHaystack_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_LeaderboardRecordsHaystack_Call) RunAndReturn(run func(context.Context, string, string, int, string, int64) (*api.LeaderboardRecordList, error)) *MockNakamaModule_LeaderboardRecordsHaystack_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRecordsList provides a mock function with given fields: ctx, id, ownerIDs, limit, cursor, expiry
func (_m *MockNakamaModule) LeaderboardRecordsList(ctx context.Context, id string, ownerIDs []string, limit int, cursor string, expiry int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error) {
	ret := _m.Called(ctx, id, ownerIDs, limit, cursor, expiry)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRecordsList")
	}

	var r0 []*api.LeaderboardRecord
	var r1 []*api.LeaderboardRecord
	var r2 string
	var r3 string
	var r4 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error)); ok {
		return rf(ctx, id, ownerIDs, limit, cursor, expiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r0 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r1 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, []string, int, string, int64) string); ok {
		r2 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, []string, int, string, int64) string); ok {
		r3 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		r3 = ret.Get(3).(string)
	}

	if rf, ok := ret.Get(4).(func(context.Context, string, []string, int, string, int64) error); ok {
		r4 = rf(ctx, id, ownerIDs, limit, cursor, expiry)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MockNakamaModule_LeaderboardRecordsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRecordsList'
type MockNakamaModule_LeaderboardRecordsList_Call struct {
	*mock.Call
}

// LeaderboardRecordsList is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerIDs []string
//   - limit int
//   - cursor string
//   - expiry int64
func (_e *MockNakamaModule_Expecter) LeaderboardRecordsList(ctx interface{}, id interface{}, ownerIDs interface{}, limit interface{}, cursor interface{}, expiry interface{}) *MockNakamaModule_LeaderboardRecordsList_Call {
	return &MockNakamaModule_LeaderboardRecordsList_Call{Call: _e.mock.On("LeaderboardRecordsList", ctx, id, ownerIDs, limit, cursor, expiry)}
}

func (_c *MockNakamaModule_LeaderboardRecordsList_Call) Run(run func(ctx context.Context, id string, ownerIDs []string, limit int, cursor string, expiry int64)) *MockNakamaModule_LeaderboardRecordsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(int), args[4].(string), args[5].(int64))
	})
	return _c
}

func (_c *MockNakamaModule_LeaderboardRecordsList_Call) Return(records []*api.LeaderboardRecord, ownerRecords []*api.LeaderboardRecord, nextCursor string, prevCursor string, err error) *MockNakamaModule_LeaderboardRecordsList_Call {
	_c.Call.Return(records, ownerRecords, nextCursor, prevCursor, err)
	return _c
}

func (_c *MockNakamaModule_LeaderboardRecordsList_Call) RunAndReturn(run func(context.Context, string, []string, int, string, int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error)) *MockNakamaModule_LeaderboardRecordsList_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardRecordsListCursorFromRank provides a mock function with given fields: id, rank, overrideExpiry
func (_m *MockNakamaModule) LeaderboardRecordsListCursorFromRank(id string, rank int64, overrideExpiry int64) (string, error) {
	ret := _m.Called(id, rank, overrideExpiry)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardRecordsListCursorFromRank")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int64, int64) (string, error)); ok {
		return rf(id, rank, overrideExpiry)
	}
	if rf, ok := ret.Get(0).(func(string, int64, int64) string); ok {
		r0 = rf(id, rank, overrideExpiry)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, int64, int64) error); ok {
		r1 = rf(id, rank, overrideExpiry)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_LeaderboardRecordsListCursorFromRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardRecordsListCursorFromRank'
type MockNakamaModule_LeaderboardRecordsListCursorFromRank_Call struct {
	*mock.Call
}

// LeaderboardRecordsListCursorFromRank is a helper method to define mock.On call
//   - id string
//   - rank int64
//   - overrideExpiry int64
func (_e *MockNakamaModule_Expecter) LeaderboardRecordsListCursorFromRank(id interface{}, rank interface{}, overrideExpiry interface{}) *MockNakamaModule_LeaderboardRecordsListCursorFromRank_Call {
	return &MockNakamaModule_LeaderboardRecordsListCursorFromRank_Call{Call: _e.mock.On("LeaderboardRecordsListCursorFromRank", id, rank, overrideExpiry)}
}

func (_c *MockNakamaModule_LeaderboardRecordsListCursorFromRank_Call) Run(run func(id string, rank int64, overrideExpiry int64)) *MockNakamaModule_LeaderboardRecordsListCursorFromRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *MockNakamaModule_LeaderboardRecordsListCursorFromRank_Call) Return(_a0 string, _a1 error) *MockNakamaModule_LeaderboardRecordsListCursorFromRank_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_LeaderboardRecordsListCursorFromRank_Call) RunAndReturn(run func(string, int64, int64) (string, error)) *MockNakamaModule_LeaderboardRecordsListCursorFromRank_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderboardsGetId provides a mock function with given fields: ctx, ids
func (_m *MockNakamaModule) LeaderboardsGetId(ctx context.Context, ids []string) ([]*api.Leaderboard, error) {
	ret := _m.Called(ctx, ids)

	if len(ret) == 0 {
		panic("no return value specified for LeaderboardsGetId")
	}

	var r0 []*api.Leaderboard
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Leaderboard, error)); ok {
		return rf(ctx, ids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Leaderboard); ok {
		r0 = rf(ctx, ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Leaderboard)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_LeaderboardsGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderboardsGetId'
type MockNakamaModule_LeaderboardsGetId_Call struct {
	*mock.Call
}

// LeaderboardsGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - ids []string
func (_e *MockNakamaModule_Expecter) LeaderboardsGetId(ctx interface{}, ids interface{}) *MockNakamaModule_LeaderboardsGetId_Call {
	return &MockNakamaModule_LeaderboardsGetId_Call{Call: _e.mock.On("LeaderboardsGetId", ctx, ids)}
}

func (_c *MockNakamaModule_LeaderboardsGetId_Call) Run(run func(ctx context.Context, ids []string)) *MockNakamaModule_LeaderboardsGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_LeaderboardsGetId_Call) Return(_a0 []*api.Leaderboard, _a1 error) *MockNakamaModule_LeaderboardsGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_LeaderboardsGetId_Call) RunAndReturn(run func(context.Context, []string) ([]*api.Leaderboard, error)) *MockNakamaModule_LeaderboardsGetId_Call {
	_c.Call.Return(run)
	return _c
}

// LinkApple provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) LinkApple(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for LinkApple")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LinkApple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkApple'
type MockNakamaModule_LinkApple_Call struct {
	*mock.Call
}

// LinkApple is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *MockNakamaModule_Expecter) LinkApple(ctx interface{}, userID interface{}, token interface{}) *MockNakamaModule_LinkApple_Call {
	return &MockNakamaModule_LinkApple_Call{Call: _e.mock.On("LinkApple", ctx, userID, token)}
}

func (_c *MockNakamaModule_LinkApple_Call) Run(run func(ctx context.Context, userID string, token string)) *MockNakamaModule_LinkApple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LinkApple_Call) Return(_a0 error) *MockNakamaModule_LinkApple_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LinkApple_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_LinkApple_Call {
	_c.Call.Return(run)
	return _c
}

// LinkCustom provides a mock function with given fields: ctx, userID, customID
func (_m *MockNakamaModule) LinkCustom(ctx context.Context, userID string, customID string) error {
	ret := _m.Called(ctx, userID, customID)

	if len(ret) == 0 {
		panic("no return value specified for LinkCustom")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, customID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LinkCustom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkCustom'
type MockNakamaModule_LinkCustom_Call struct {
	*mock.Call
}

// LinkCustom is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - customID string
func (_e *MockNakamaModule_Expecter) LinkCustom(ctx interface{}, userID interface{}, customID interface{}) *MockNakamaModule_LinkCustom_Call {
	return &MockNakamaModule_LinkCustom_Call{Call: _e.mock.On("LinkCustom", ctx, userID, customID)}
}

func (_c *MockNakamaModule_LinkCustom_Call) Run(run func(ctx context.Context, userID string, customID string)) *MockNakamaModule_LinkCustom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LinkCustom_Call) Return(_a0 error) *MockNakamaModule_LinkCustom_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LinkCustom_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_LinkCustom_Call {
	_c.Call.Return(run)
	return _c
}

// LinkDevice provides a mock function with given fields: ctx, userID, deviceID
func (_m *MockNakamaModule) LinkDevice(ctx context.Context, userID string, deviceID string) error {
	ret := _m.Called(ctx, userID, deviceID)

	if len(ret) == 0 {
		panic("no return value specified for LinkDevice")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, deviceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LinkDevice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkDevice'
type MockNakamaModule_LinkDevice_Call struct {
	*mock.Call
}

// LinkDevice is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - deviceID string
func (_e *MockNakamaModule_Expecter) LinkDevice(ctx interface{}, userID interface{}, deviceID interface{}) *MockNakamaModule_LinkDevice_Call {
	return &MockNakamaModule_LinkDevice_Call{Call: _e.mock.On("LinkDevice", ctx, userID, deviceID)}
}

func (_c *MockNakamaModule_LinkDevice_Call) Run(run func(ctx context.Context, userID string, deviceID string)) *MockNakamaModule_LinkDevice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LinkDevice_Call) Return(_a0 error) *MockNakamaModule_LinkDevice_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LinkDevice_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_LinkDevice_Call {
	_c.Call.Return(run)
	return _c
}

// LinkEmail provides a mock function with given fields: ctx, userID, email, password
func (_m *MockNakamaModule) LinkEmail(ctx context.Context, userID string, email string, password string) error {
	ret := _m.Called(ctx, userID, email, password)

	if len(ret) == 0 {
		panic("no return value specified for LinkEmail")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, userID, email, password)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LinkEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkEmail'
type MockNakamaModule_LinkEmail_Call struct {
	*mock.Call
}

// LinkEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - email string
//   - password string
func (_e *MockNakamaModule_Expecter) LinkEmail(ctx interface{}, userID interface{}, email interface{}, password interface{}) *MockNakamaModule_LinkEmail_Call {
	return &MockNakamaModule_LinkEmail_Call{Call: _e.mock.On("LinkEmail", ctx, userID, email, password)}
}

func (_c *MockNakamaModule_LinkEmail_Call) Run(run func(ctx context.Context, userID string, email string, password string)) *MockNakamaModule_LinkEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LinkEmail_Call) Return(_a0 error) *MockNakamaModule_LinkEmail_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LinkEmail_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockNakamaModule_LinkEmail_Call {
	_c.Call.Return(run)
	return _c
}

// LinkFacebook provides a mock function with given fields: ctx, userID, username, token, importFriends
func (_m *MockNakamaModule) LinkFacebook(ctx context.Context, userID string, username string, token string, importFriends bool) error {
	ret := _m.Called(ctx, userID, username, token, importFriends)

	if len(ret) == 0 {
		panic("no return value specified for LinkFacebook")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) error); ok {
		r0 = rf(ctx, userID, username, token, importFriends)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LinkFacebook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkFacebook'
type MockNakamaModule_LinkFacebook_Call struct {
	*mock.Call
}

// LinkFacebook is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - token string
//   - importFriends bool
func (_e *MockNakamaModule_Expecter) LinkFacebook(ctx interface{}, userID interface{}, username interface{}, token interface{}, importFriends interface{}) *MockNakamaModule_LinkFacebook_Call {
	return &MockNakamaModule_LinkFacebook_Call{Call: _e.mock.On("LinkFacebook", ctx, userID, username, token, importFriends)}
}

func (_c *MockNakamaModule_LinkFacebook_Call) Run(run func(ctx context.Context, userID string, username string, token string, importFriends bool)) *MockNakamaModule_LinkFacebook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_LinkFacebook_Call) Return(_a0 error) *MockNakamaModule_LinkFacebook_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LinkFacebook_Call) RunAndReturn(run func(context.Context, string, string, string, bool) error) *MockNakamaModule_LinkFacebook_Call {
	_c.Call.Return(run)
	return _c
}

// LinkFacebookInstantGame provides a mock function with given fields: ctx, userID, signedPlayerInfo
func (_m *MockNakamaModule) LinkFacebookInstantGame(ctx context.Context, userID string, signedPlayerInfo string) error {
	ret := _m.Called(ctx, userID, signedPlayerInfo)

	if len(ret) == 0 {
		panic("no return value specified for LinkFacebookInstantGame")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, signedPlayerInfo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LinkFacebookInstantGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkFacebookInstantGame'
type MockNakamaModule_LinkFacebookInstantGame_Call struct {
	*mock.Call
}

// LinkFacebookInstantGame is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - signedPlayerInfo string
func (_e *MockNakamaModule_Expecter) LinkFacebookInstantGame(ctx interface{}, userID interface{}, signedPlayerInfo interface{}) *MockNakamaModule_LinkFacebookInstantGame_Call {
	return &MockNakamaModule_LinkFacebookInstantGame_Call{Call: _e.mock.On("LinkFacebookInstantGame", ctx, userID, signedPlayerInfo)}
}

func (_c *MockNakamaModule_LinkFacebookInstantGame_Call) Run(run func(ctx context.Context, userID string, signedPlayerInfo string)) *MockNakamaModule_LinkFacebookInstantGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LinkFacebookInstantGame_Call) Return(_a0 error) *MockNakamaModule_LinkFacebookInstantGame_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LinkFacebookInstantGame_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_LinkFacebookInstantGame_Call {
	_c.Call.Return(run)
	return _c
}

// LinkGameCenter provides a mock function with given fields: ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl
func (_m *MockNakamaModule) LinkGameCenter(ctx context.Context, userID string, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string) error {
	ret := _m.Called(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)

	if len(ret) == 0 {
		panic("no return value specified for LinkGameCenter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, string, string, string) error); ok {
		r0 = rf(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LinkGameCenter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkGameCenter'
type MockNakamaModule_LinkGameCenter_Call struct {
	*mock.Call
}

// LinkGameCenter is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - playerID string
//   - bundleID string
//   - timestamp int64
//   - salt string
//   - signature string
//   - publicKeyUrl string
func (_e *MockNakamaModule_Expecter) LinkGameCenter(ctx interface{}, userID interface{}, playerID interface{}, bundleID interface{}, timestamp interface{}, salt interface{}, signature interface{}, publicKeyUrl interface{}) *MockNakamaModule_LinkGameCenter_Call {
	return &MockNakamaModule_LinkGameCenter_Call{Call: _e.mock.On("LinkGameCenter", ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)}
}

func (_c *MockNakamaModule_LinkGameCenter_Call) Run(run func(ctx context.Context, userID string, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string)) *MockNakamaModule_LinkGameCenter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64), args[5].(string), args[6].(string), args[7].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LinkGameCenter_Call) Return(_a0 error) *MockNakamaModule_LinkGameCenter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LinkGameCenter_Call) RunAndReturn(run func(context.Context, string, string, string, int64, string, string, string) error) *MockNakamaModule_LinkGameCenter_Call {
	_c.Call.Return(run)
	return _c
}

// LinkGoogle provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) LinkGoogle(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for LinkGoogle")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LinkGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkGoogle'
type MockNakamaModule_LinkGoogle_Call struct {
	*mock.Call
}

// LinkGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *MockNakamaModule_Expecter) LinkGoogle(ctx interface{}, userID interface{}, token interface{}) *MockNakamaModule_LinkGoogle_Call {
	return &MockNakamaModule_LinkGoogle_Call{Call: _e.mock.On("LinkGoogle", ctx, userID, token)}
}

func (_c *MockNakamaModule_LinkGoogle_Call) Run(run func(ctx context.Context, userID string, token string)) *MockNakamaModule_LinkGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_LinkGoogle_Call) Return(_a0 error) *MockNakamaModule_LinkGoogle_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LinkGoogle_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_LinkGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// LinkSteam provides a mock function with given fields: ctx, userID, username, token, importFriends
func (_m *MockNakamaModule) LinkSteam(ctx context.Context, userID string, username string, token string, importFriends bool) error {
	ret := _m.Called(ctx, userID, username, token, importFriends)

	if len(ret) == 0 {
		panic("no return value specified for LinkSteam")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) error); ok {
		r0 = rf(ctx, userID, username, token, importFriends)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_LinkSteam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LinkSteam'
type MockNakamaModule_LinkSteam_Call struct {
	*mock.Call
}

// LinkSteam is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - username string
//   - token string
//   - importFriends bool
func (_e *MockNakamaModule_Expecter) LinkSteam(ctx interface{}, userID interface{}, username interface{}, token interface{}, importFriends interface{}) *MockNakamaModule_LinkSteam_Call {
	return &MockNakamaModule_LinkSteam_Call{Call: _e.mock.On("LinkSteam", ctx, userID, username, token, importFriends)}
}

func (_c *MockNakamaModule_LinkSteam_Call) Run(run func(ctx context.Context, userID string, username string, token string, importFriends bool)) *MockNakamaModule_LinkSteam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_LinkSteam_Call) Return(_a0 error) *MockNakamaModule_LinkSteam_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_LinkSteam_Call) RunAndReturn(run func(context.Context, string, string, string, bool) error) *MockNakamaModule_LinkSteam_Call {
	_c.Call.Return(run)
	return _c
}

// MatchCreate provides a mock function with given fields: ctx, module, params
func (_m *MockNakamaModule) MatchCreate(ctx context.Context, module string, params map[string]interface{}) (string, error) {
	ret := _m.Called(ctx, module, params)

	if len(ret) == 0 {
		panic("no return value specified for MatchCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) (string, error)); ok {
		return rf(ctx, module, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) string); ok {
		r0 = rf(ctx, module, params)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]interface{}) error); ok {
		r1 = rf(ctx, module, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_MatchCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchCreate'
type MockNakamaModule_MatchCreate_Call struct {
	*mock.Call
}

// MatchCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - module string
//   - params map[string]interface{}
func (_e *MockNakamaModule_Expecter) MatchCreate(ctx interface{}, module interface{}, params interface{}) *MockNakamaModule_MatchCreate_Call {
	return &MockNakamaModule_MatchCreate_Call{Call: _e.mock.On("MatchCreate", ctx, module, params)}
}

func (_c *MockNakamaModule_MatchCreate_Call) Run(run func(ctx context.Context, module string, params map[string]interface{})) *MockNakamaModule_MatchCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]interface{}))
	})
	return _c
}

func (_c *MockNakamaModule_MatchCreate_Call) Return(_a0 string, _a1 error) *MockNakamaModule_MatchCreate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_MatchCreate_Call) RunAndReturn(run func(context.Context, string, map[string]interface{}) (string, error)) *MockNakamaModule_MatchCreate_Call {
	_c.Call.Return(run)
	return _c
}

// MatchGet provides a mock function with given fields: ctx, id
func (_m *MockNakamaModule) MatchGet(ctx context.Context, id string) (*api.Match, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for MatchGet")
	}

	var r0 *api.Match
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*api.Match, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.Match); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Match)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_MatchGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchGet'
type MockNakamaModule_MatchGet_Call struct {
	*mock.Call
}

// MatchGet is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockNakamaModule_Expecter) MatchGet(ctx interface{}, id interface{}) *MockNakamaModule_MatchGet_Call {
	return &MockNakamaModule_MatchGet_Call{Call: _e.mock.On("MatchGet", ctx, id)}
}

func (_c *MockNakamaModule_MatchGet_Call) Run(run func(ctx context.Context, id string)) *MockNakamaModule_MatchGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockNakamaModule_MatchGet_Call) Return(_a0 *api.Match, _a1 error) *MockNakamaModule_MatchGet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_MatchGet_Call) RunAndReturn(run func(context.Context, string) (*api.Match, error)) *MockNakamaModule_MatchGet_Call {
	_c.Call.Return(run)
	return _c
}

// MatchList provides a mock function with given fields: ctx, limit, authoritative, label, minSize, maxSize, query
func (_m *MockNakamaModule) MatchList(ctx context.Context, limit int, authoritative bool, label string, minSize *int, maxSize *int, query string) ([]*api.Match, error) {
	ret := _m.Called(ctx, limit, authoritative, label, minSize, maxSize, query)

	if len(ret) == 0 {
		panic("no return value specified for MatchList")
	}

	var r0 []*api.Match
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, bool, string, *int, *int, string) ([]*api.Match, error)); ok {
		return rf(ctx, limit, authoritative, label, minSize, maxSize, query)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, bool, string, *int, *int, string) []*api.Match); ok {
		r0 = rf(ctx, limit, authoritative, label, minSize, maxSize, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Match)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, bool, string, *int, *int, string) error); ok {
		r1 = rf(ctx, limit, authoritative, label, minSize, maxSize, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_MatchList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchList'
type MockNakamaModule_MatchList_Call struct {
	*mock.Call
}

// MatchList is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - authoritative bool
//   - label string
//   - minSize *int
//   - maxSize *int
//   - query string
func (_e *MockNakamaModule_Expecter) MatchList(ctx interface{}, limit interface{}, authoritative interface{}, label interface{}, minSize interface{}, maxSize interface{}, query interface{}) *MockNakamaModule_MatchList_Call {
	return &MockNakamaModule_MatchList_Call{Call: _e.mock.On("MatchList", ctx, limit, authoritative, label, minSize, maxSize, query)}
}

func (_c *MockNakamaModule_MatchList_Call) Run(run func(ctx context.Context, limit int, authoritative bool, label string, minSize *int, maxSize *int, query string)) *MockNakamaModule_MatchList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(bool), args[3].(string), args[4].(*int), args[5].(*int), args[6].(string))
	})
	return _c
}

func (_c *MockNakamaModule_MatchList_Call) Return(_a0 []*api.Match, _a1 error) *MockNakamaModule_MatchList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_MatchList_Call) RunAndReturn(run func(context.Context, int, bool, string, *int, *int, string) ([]*api.Match, error)) *MockNakamaModule_MatchList_Call {
	_c.Call.Return(run)
	return _c
}

// MatchSignal provides a mock function with given fields: ctx, id, data
func (_m *MockNakamaModule) MatchSignal(ctx context.Context, id string, data string) (string, error) {
	ret := _m.Called(ctx, id, data)

	if len(ret) == 0 {
		panic("no return value specified for MatchSignal")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, id, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, id, data)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, id, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_MatchSignal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchSignal'
type MockNakamaModule_MatchSignal_Call struct {
	*mock.Call
}

// MatchSignal is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - data string
func (_e *MockNakamaModule_Expecter) MatchSignal(ctx interface{}, id interface{}, data interface{}) *MockNakamaModule_MatchSignal_Call {
	return &MockNakamaModule_MatchSignal_Call{Call: _e.mock.On("MatchSignal", ctx, id, data)}
}

func (_c *MockNakamaModule_MatchSignal_Call) Run(run func(ctx context.Context, id string, data string)) *MockNakamaModule_MatchSignal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_MatchSignal_Call) Return(_a0 string, _a1 error) *MockNakamaModule_MatchSignal_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_MatchSignal_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *MockNakamaModule_MatchSignal_Call {
	_c.Call.Return(run)
	return _c
}

// MetricsCounterAdd provides a mock function with given fields: name, tags, delta
func (_m *MockNakamaModule) MetricsCounterAdd(name string, tags map[string]string, delta int64) {
	_m.Called(name, tags, delta)
}

// MockNakamaModule_MetricsCounterAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MetricsCounterAdd'
type MockNakamaModule_MetricsCounterAdd_Call struct {
	*mock.Call
}

// MetricsCounterAdd is a helper method to define mock.On call
//   - name string
//   - tags map[string]string
//   - delta int64
func (_e *MockNakamaModule_Expecter) MetricsCounterAdd(name interface{}, tags interface{}, delta interface{}) *MockNakamaModule_MetricsCounterAdd_Call {
	return &MockNakamaModule_MetricsCounterAdd_Call{Call: _e.mock.On("MetricsCounterAdd", name, tags, delta)}
}

func (_c *MockNakamaModule_MetricsCounterAdd_Call) Run(run func(name string, tags map[string]string, delta int64)) *MockNakamaModule_MetricsCounterAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]string), args[2].(int64))
	})
	return _c
}

func (_c *MockNakamaModule_MetricsCounterAdd_Call) Return() *MockNakamaModule_MetricsCounterAdd_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockNakamaModule_MetricsCounterAdd_Call) RunAndReturn(run func(string, map[string]string, int64)) *MockNakamaModule_MetricsCounterAdd_Call {
	_c.Run(run)
	return _c
}

// MetricsGaugeSet provides a mock function with given fields: name, tags, value
func (_m *MockNakamaModule) MetricsGaugeSet(name string, tags map[string]string, value float64) {
	_m.Called(name, tags, value)
}

// MockNakamaModule_MetricsGaugeSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MetricsGaugeSet'
type MockNakamaModule_MetricsGaugeSet_Call struct {
	*mock.Call
}

// MetricsGaugeSet is a helper method to define mock.On call
//   - name string
//   - tags map[string]string
//   - value float64
func (_e *MockNakamaModule_Expecter) MetricsGaugeSet(name interface{}, tags interface{}, value interface{}) *MockNakamaModule_MetricsGaugeSet_Call {
	return &MockNakamaModule_MetricsGaugeSet_Call{Call: _e.mock.On("MetricsGaugeSet", name, tags, value)}
}

func (_c *MockNakamaModule_MetricsGaugeSet_Call) Run(run func(name string, tags map[string]string, value float64)) *MockNakamaModule_MetricsGaugeSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]string), args[2].(float64))
	})
	return _c
}

func (_c *MockNakamaModule_MetricsGaugeSet_Call) Return() *MockNakamaModule_MetricsGaugeSet_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockNakamaModule_MetricsGaugeSet_Call) RunAndReturn(run func(string, map[string]string, float64)) *MockNakamaModule_MetricsGaugeSet_Call {
	_c.Run(run)
	return _c
}

// MetricsTimerRecord provides a mock function with given fields: name, tags, value
func (_m *MockNakamaModule) MetricsTimerRecord(name string, tags map[string]string, value time.Duration) {
	_m.Called(name, tags, value)
}

// MockNakamaModule_MetricsTimerRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MetricsTimerRecord'
type MockNakamaModule_MetricsTimerRecord_Call struct {
	*mock.Call
}

// MetricsTimerRecord is a helper method to define mock.On call
//   - name string
//   - tags map[string]string
//   - value time.Duration
func (_e *MockNakamaModule_Expecter) MetricsTimerRecord(name interface{}, tags interface{}, value interface{}) *MockNakamaModule_MetricsTimerRecord_Call {
	return &MockNakamaModule_MetricsTimerRecord_Call{Call: _e.mock.On("MetricsTimerRecord", name, tags, value)}
}

func (_c *MockNakamaModule_MetricsTimerRecord_Call) Run(run func(name string, tags map[string]string, value time.Duration)) *MockNakamaModule_MetricsTimerRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockNakamaModule_MetricsTimerRecord_Call) Return() *MockNakamaModule_MetricsTimerRecord_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockNakamaModule_MetricsTimerRecord_Call) RunAndReturn(run func(string, map[string]string, time.Duration)) *MockNakamaModule_MetricsTimerRecord_Call {
	_c.Run(run)
	return _c
}

// MultiUpdate provides a mock function with given fields: ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger
func (_m *MockNakamaModule) MultiUpdate(ctx context.Context, accountUpdates []*runtime.AccountUpdate, storageWrites []*runtime.StorageWrite, storageDeletes []*runtime.StorageDelete, walletUpdates []*runtime.WalletUpdate, updateLedger bool) ([]*api.StorageObjectAck, []*runtime.WalletUpdateResult, error) {
	ret := _m.Called(ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)

	if len(ret) == 0 {
		panic("no return value specified for MultiUpdate")
	}

	var r0 []*api.StorageObjectAck
	var r1 []*runtime.WalletUpdateResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.StorageDelete, []*runtime.WalletUpdate, bool) ([]*api.StorageObjectAck, []*runtime.WalletUpdateResult, error)); ok {
		return rf(ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.StorageDelete, []*runtime.WalletUpdate, bool) []*api.StorageObjectAck); ok {
		r0 = rf(ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObjectAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.StorageDelete, []*runtime.WalletUpdate, bool) []*runtime.WalletUpdateResult); ok {
		r1 = rf(ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*runtime.WalletUpdateResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.StorageDelete, []*runtime.WalletUpdate, bool) error); ok {
		r2 = rf(ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_MultiUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MultiUpdate'
type MockNakamaModule_MultiUpdate_Call struct {
	*mock.Call
}

// MultiUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - accountUpdates []*runtime.AccountUpdate
//   - storageWrites []*runtime.StorageWrite
//   - storageDeletes []*runtime.StorageDelete
//   - walletUpdates []*runtime.WalletUpdate
//   - updateLedger bool
func (_e *MockNakamaModule_Expecter) MultiUpdate(ctx interface{}, accountUpdates interface{}, storageWrites interface{}, storageDeletes interface{}, walletUpdates interface{}, updateLedger interface{}) *MockNakamaModule_MultiUpdate_Call {
	return &MockNakamaModule_MultiUpdate_Call{Call: _e.mock.On("MultiUpdate", ctx, accountUpdates, storageWrites, storageDeletes, walletUpdates, updateLedger)}
}

func (_c *MockNakamaModule_MultiUpdate_Call) Run(run func(ctx context.Context, accountUpdates []*runtime.AccountUpdate, storageWrites []*runtime.StorageWrite, storageDeletes []*runtime.StorageDelete, walletUpdates []*runtime.WalletUpdate, updateLedger bool)) *MockNakamaModule_MultiUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.AccountUpdate), args[2].([]*runtime.StorageWrite), args[3].([]*runtime.StorageDelete), args[4].([]*runtime.WalletUpdate), args[5].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_MultiUpdate_Call) Return(_a0 []*api.StorageObjectAck, _a1 []*runtime.WalletUpdateResult, _a2 error) *MockNakamaModule_MultiUpdate_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_MultiUpdate_Call) RunAndReturn(run func(context.Context, []*runtime.AccountUpdate, []*runtime.StorageWrite, []*runtime.StorageDelete, []*runtime.WalletUpdate, bool) ([]*api.StorageObjectAck, []*runtime.WalletUpdateResult, error)) *MockNakamaModule_MultiUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationSend provides a mock function with given fields: ctx, userID, subject, content, code, sender, persistent
func (_m *MockNakamaModule) NotificationSend(ctx context.Context, userID string, subject string, content map[string]interface{}, code int, sender string, persistent bool) error {
	ret := _m.Called(ctx, userID, subject, content, code, sender, persistent)

	if len(ret) == 0 {
		panic("no return value specified for NotificationSend")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, int, string, bool) error); ok {
		r0 = rf(ctx, userID, subject, content, code, sender, persistent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_NotificationSend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationSend'
type MockNakamaModule_NotificationSend_Call struct {
	*mock.Call
}

// NotificationSend is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - subject string
//   - content map[string]interface{}
//   - code int
//   - sender string
//   - persistent bool
func (_e *MockNakamaModule_Expecter) NotificationSend(ctx interface{}, userID interface{}, subject interface{}, content interface{}, code interface{}, sender interface{}, persistent interface{}) *MockNakamaModule_NotificationSend_Call {
	return &MockNakamaModule_NotificationSend_Call{Call: _e.mock.On("NotificationSend", ctx, userID, subject, content, code, sender, persistent)}
}

func (_c *MockNakamaModule_NotificationSend_Call) Run(run func(ctx context.Context, userID string, subject string, content map[string]interface{}, code int, sender string, persistent bool)) *MockNakamaModule_NotificationSend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string]interface{}), args[4].(int), args[5].(string), args[6].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_NotificationSend_Call) Return(_a0 error) *MockNakamaModule_NotificationSend_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_NotificationSend_Call) RunAndReturn(run func(context.Context, string, string, map[string]interface{}, int, string, bool) error) *MockNakamaModule_NotificationSend_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationSendAll provides a mock function with given fields: ctx, subject, content, code, persistent
func (_m *MockNakamaModule) NotificationSendAll(ctx context.Context, subject string, content map[string]interface{}, code int, persistent bool) error {
	ret := _m.Called(ctx, subject, content, code, persistent)

	if len(ret) == 0 {
		panic("no return value specified for NotificationSendAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, int, bool) error); ok {
		r0 = rf(ctx, subject, content, code, persistent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_NotificationSendAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationSendAll'
type MockNakamaModule_NotificationSendAll_Call struct {
	*mock.Call
}

// NotificationSendAll is a helper method to define mock.On call
//   - ctx context.Context
//   - subject string
//   - content map[string]interface{}
//   - code int
//   - persistent bool
func (_e *MockNakamaModule_Expecter) NotificationSendAll(ctx interface{}, subject interface{}, content interface{}, code interface{}, persistent interface{}) *MockNakamaModule_NotificationSendAll_Call {
	return &MockNakamaModule_NotificationSendAll_Call{Call: _e.mock.On("NotificationSendAll", ctx, subject, content, code, persistent)}
}

func (_c *MockNakamaModule_NotificationSendAll_Call) Run(run func(ctx context.Context, subject string, content map[string]interface{}, code int, persistent bool)) *MockNakamaModule_NotificationSendAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]interface{}), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_NotificationSendAll_Call) Return(_a0 error) *MockNakamaModule_NotificationSendAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_NotificationSendAll_Call) RunAndReturn(run func(context.Context, string, map[string]interface{}, int, bool) error) *MockNakamaModule_NotificationSendAll_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationsDelete provides a mock function with given fields: ctx, notifications
func (_m *MockNakamaModule) NotificationsDelete(ctx context.Context, notifications []*runtime.NotificationDelete) error {
	ret := _m.Called(ctx, notifications)

	if len(ret) == 0 {
		panic("no return value specified for NotificationsDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.NotificationDelete) error); ok {
		r0 = rf(ctx, notifications)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_NotificationsDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationsDelete'
type MockNakamaModule_NotificationsDelete_Call struct {
	*mock.Call
}

// NotificationsDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - notifications []*runtime.NotificationDelete
func (_e *MockNakamaModule_Expecter) NotificationsDelete(ctx interface{}, notifications interface{}) *MockNakamaModule_NotificationsDelete_Call {
	return &MockNakamaModule_NotificationsDelete_Call{Call: _e.mock.On("NotificationsDelete", ctx, notifications)}
}

func (_c *MockNakamaModule_NotificationsDelete_Call) Run(run func(ctx context.Context, notifications []*runtime.NotificationDelete)) *MockNakamaModule_NotificationsDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.NotificationDelete))
	})
	return _c
}

func (_c *MockNakamaModule_NotificationsDelete_Call) Return(_a0 error) *MockNakamaModule_NotificationsDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_NotificationsDelete_Call) RunAndReturn(run func(context.Context, []*runtime.NotificationDelete) error) *MockNakamaModule_NotificationsDelete_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationsDeleteId provides a mock function with given fields: ctx, userID, ids
func (_m *MockNakamaModule) NotificationsDeleteId(ctx context.Context, userID string, ids []string) error {
	ret := _m.Called(ctx, userID, ids)

	if len(ret) == 0 {
		panic("no return value specified for NotificationsDeleteId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) error); ok {
		r0 = rf(ctx, userID, ids)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_NotificationsDeleteId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationsDeleteId'
type MockNakamaModule_NotificationsDeleteId_Call struct {
	*mock.Call
}

// NotificationsDeleteId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - ids []string
func (_e *MockNakamaModule_Expecter) NotificationsDeleteId(ctx interface{}, userID interface{}, ids interface{}) *MockNakamaModule_NotificationsDeleteId_Call {
	return &MockNakamaModule_NotificationsDeleteId_Call{Call: _e.mock.On("NotificationsDeleteId", ctx, userID, ids)}
}

func (_c *MockNakamaModule_NotificationsDeleteId_Call) Run(run func(ctx context.Context, userID string, ids []string)) *MockNakamaModule_NotificationsDeleteId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_NotificationsDeleteId_Call) Return(_a0 error) *MockNakamaModule_NotificationsDeleteId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_NotificationsDeleteId_Call) RunAndReturn(run func(context.Context, string, []string) error) *MockNakamaModule_NotificationsDeleteId_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationsGetId provides a mock function with given fields: ctx, userID, ids
func (_m *MockNakamaModule) NotificationsGetId(ctx context.Context, userID string, ids []string) ([]*runtime.Notification, error) {
	ret := _m.Called(ctx, userID, ids)

	if len(ret) == 0 {
		panic("no return value specified for NotificationsGetId")
	}

	var r0 []*runtime.Notification
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) ([]*runtime.Notification, error)); ok {
		return rf(ctx, userID, ids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) []*runtime.Notification); ok {
		r0 = rf(ctx, userID, ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*runtime.Notification)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, userID, ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_NotificationsGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationsGetId'
type MockNakamaModule_NotificationsGetId_Call struct {
	*mock.Call
}

// NotificationsGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - ids []string
func (_e *MockNakamaModule_Expecter) NotificationsGetId(ctx interface{}, userID interface{}, ids interface{}) *MockNakamaModule_NotificationsGetId_Call {
	return &MockNakamaModule_NotificationsGetId_Call{Call: _e.mock.On("NotificationsGetId", ctx, userID, ids)}
}

func (_c *MockNakamaModule_NotificationsGetId_Call) Run(run func(ctx context.Context, userID string, ids []string)) *MockNakamaModule_NotificationsGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_NotificationsGetId_Call) Return(_a0 []*runtime.Notification, _a1 error) *MockNakamaModule_NotificationsGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_NotificationsGetId_Call) RunAndReturn(run func(context.Context, string, []string) ([]*runtime.Notification, error)) *MockNakamaModule_NotificationsGetId_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationsList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *MockNakamaModule) NotificationsList(ctx context.Context, userID string, limit int, cursor string) ([]*api.Notification, string, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for NotificationsList")
	}

	var r0 []*api.Notification
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) ([]*api.Notification, string, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) []*api.Notification); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Notification)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) string); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, string) error); ok {
		r2 = rf(ctx, userID, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_NotificationsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationsList'
type MockNakamaModule_NotificationsList_Call struct {
	*mock.Call
}

// NotificationsList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - cursor string
func (_e *MockNakamaModule_Expecter) NotificationsList(ctx interface{}, userID interface{}, limit interface{}, cursor interface{}) *MockNakamaModule_NotificationsList_Call {
	return &MockNakamaModule_NotificationsList_Call{Call: _e.mock.On("NotificationsList", ctx, userID, limit, cursor)}
}

func (_c *MockNakamaModule_NotificationsList_Call) Run(run func(ctx context.Context, userID string, limit int, cursor string)) *MockNakamaModule_NotificationsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_NotificationsList_Call) Return(_a0 []*api.Notification, _a1 string, _a2 error) *MockNakamaModule_NotificationsList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_NotificationsList_Call) RunAndReturn(run func(context.Context, string, int, string) ([]*api.Notification, string, error)) *MockNakamaModule_NotificationsList_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationsSend provides a mock function with given fields: ctx, notifications
func (_m *MockNakamaModule) NotificationsSend(ctx context.Context, notifications []*runtime.NotificationSend) error {
	ret := _m.Called(ctx, notifications)

	if len(ret) == 0 {
		panic("no return value specified for NotificationsSend")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.NotificationSend) error); ok {
		r0 = rf(ctx, notifications)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_NotificationsSend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationsSend'
type MockNakamaModule_NotificationsSend_Call struct {
	*mock.Call
}

// NotificationsSend is a helper method to define mock.On call
//   - ctx context.Context
//   - notifications []*runtime.NotificationSend
func (_e *MockNakamaModule_Expecter) NotificationsSend(ctx interface{}, notifications interface{}) *MockNakamaModule_NotificationsSend_Call {
	return &MockNakamaModule_NotificationsSend_Call{Call: _e.mock.On("NotificationsSend", ctx, notifications)}
}

func (_c *MockNakamaModule_NotificationsSend_Call) Run(run func(ctx context.Context, notifications []*runtime.NotificationSend)) *MockNakamaModule_NotificationsSend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.NotificationSend))
	})
	return _c
}

func (_c *MockNakamaModule_NotificationsSend_Call) Return(_a0 error) *MockNakamaModule_NotificationsSend_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_NotificationsSend_Call) RunAndReturn(run func(context.Context, []*runtime.NotificationSend) error) *MockNakamaModule_NotificationsSend_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationsUpdate provides a mock function with given fields: ctx, updates
func (_m *MockNakamaModule) NotificationsUpdate(ctx context.Context, updates ...runtime.NotificationUpdate) error {
	_va := make([]interface{}, len(updates))
	for _i := range updates {
		_va[_i] = updates[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NotificationsUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...runtime.NotificationUpdate) error); ok {
		r0 = rf(ctx, updates...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_NotificationsUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationsUpdate'
type MockNakamaModule_NotificationsUpdate_Call struct {
	*mock.Call
}

// NotificationsUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - updates ...runtime.NotificationUpdate
func (_e *MockNakamaModule_Expecter) NotificationsUpdate(ctx interface{}, updates ...interface{}) *MockNakamaModule_NotificationsUpdate_Call {
	return &MockNakamaModule_NotificationsUpdate_Call{Call: _e.mock.On("NotificationsUpdate",
		append([]interface{}{ctx}, updates...)...)}
}

func (_c *MockNakamaModule_NotificationsUpdate_Call) Run(run func(ctx context.Context, updates ...runtime.NotificationUpdate)) *MockNakamaModule_NotificationsUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]runtime.NotificationUpdate, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(runtime.NotificationUpdate)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockNakamaModule_NotificationsUpdate_Call) Return(_a0 error) *MockNakamaModule_NotificationsUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_NotificationsUpdate_Call) RunAndReturn(run func(context.Context, ...runtime.NotificationUpdate) error) *MockNakamaModule_NotificationsUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseGetByTransactionId provides a mock function with given fields: ctx, transactionID
func (_m *MockNakamaModule) PurchaseGetByTransactionId(ctx context.Context, transactionID string) (*api.ValidatedPurchase, error) {
	ret := _m.Called(ctx, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseGetByTransactionId")
	}

	var r0 *api.ValidatedPurchase
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*api.ValidatedPurchase, error)); ok {
		return rf(ctx, transactionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.ValidatedPurchase); ok {
		r0 = rf(ctx, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatedPurchase)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, transactionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_PurchaseGetByTransactionId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseGetByTransactionId'
type MockNakamaModule_PurchaseGetByTransactionId_Call struct {
	*mock.Call
}

// PurchaseGetByTransactionId is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionID string
func (_e *MockNakamaModule_Expecter) PurchaseGetByTransactionId(ctx interface{}, transactionID interface{}) *MockNakamaModule_PurchaseGetByTransactionId_Call {
	return &MockNakamaModule_PurchaseGetByTransactionId_Call{Call: _e.mock.On("PurchaseGetByTransactionId", ctx, transactionID)}
}

func (_c *MockNakamaModule_PurchaseGetByTransactionId_Call) Run(run func(ctx context.Context, transactionID string)) *MockNakamaModule_PurchaseGetByTransactionId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockNakamaModule_PurchaseGetByTransactionId_Call) Return(_a0 *api.ValidatedPurchase, _a1 error) *MockNakamaModule_PurchaseGetByTransactionId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_PurchaseGetByTransactionId_Call) RunAndReturn(run func(context.Context, string) (*api.ValidatedPurchase, error)) *MockNakamaModule_PurchaseGetByTransactionId_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseValidateApple provides a mock function with given fields: ctx, userID, receipt, persist, passwordOverride
func (_m *MockNakamaModule) PurchaseValidateApple(ctx context.Context, userID string, receipt string, persist bool, passwordOverride ...string) (*api.ValidatePurchaseResponse, error) {
	_va := make([]interface{}, len(passwordOverride))
	for _i := range passwordOverride {
		_va[_i] = passwordOverride[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseValidateApple")
	}

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, passwordOverride...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...string) error); ok {
		r1 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_PurchaseValidateApple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseValidateApple'
type MockNakamaModule_PurchaseValidateApple_Call struct {
	*mock.Call
}

// PurchaseValidateApple is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - receipt string
//   - persist bool
//   - passwordOverride ...string
func (_e *MockNakamaModule_Expecter) PurchaseValidateApple(ctx interface{}, userID interface{}, receipt interface{}, persist interface{}, passwordOverride ...interface{}) *MockNakamaModule_PurchaseValidateApple_Call {
	return &MockNakamaModule_PurchaseValidateApple_Call{Call: _e.mock.On("PurchaseValidateApple",
		append([]interface{}{ctx, userID, receipt, persist}, passwordOverride...)...)}
}

func (_c *MockNakamaModule_PurchaseValidateApple_Call) Run(run func(ctx context.Context, userID string, receipt string, persist bool, passwordOverride ...string)) *MockNakamaModule_PurchaseValidateApple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool), variadicArgs...)
	})
	return _c
}

func (_c *MockNakamaModule_PurchaseValidateApple_Call) Return(_a0 *api.ValidatePurchaseResponse, _a1 error) *MockNakamaModule_PurchaseValidateApple_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_PurchaseValidateApple_Call) RunAndReturn(run func(context.Context, string, string, bool, ...string) (*api.ValidatePurchaseResponse, error)) *MockNakamaModule_PurchaseValidateApple_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseValidateFacebookInstant provides a mock function with given fields: ctx, userID, signedRequest, persist
func (_m *MockNakamaModule) PurchaseValidateFacebookInstant(ctx context.Context, userID string, signedRequest string, persist bool) (*api.ValidatePurchaseResponse, error) {
	ret := _m.Called(ctx, userID, signedRequest, persist)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseValidateFacebookInstant")
	}

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, signedRequest, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, signedRequest, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) error); ok {
		r1 = rf(ctx, userID, signedRequest, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_PurchaseValidateFacebookInstant_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseValidateFacebookInstant'
type MockNakamaModule_PurchaseValidateFacebookInstant_Call struct {
	*mock.Call
}

// PurchaseValidateFacebookInstant is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - signedRequest string
//   - persist bool
func (_e *MockNakamaModule_Expecter) PurchaseValidateFacebookInstant(ctx interface{}, userID interface{}, signedRequest interface{}, persist interface{}) *MockNakamaModule_PurchaseValidateFacebookInstant_Call {
	return &MockNakamaModule_PurchaseValidateFacebookInstant_Call{Call: _e.mock.On("PurchaseValidateFacebookInstant", ctx, userID, signedRequest, persist)}
}

func (_c *MockNakamaModule_PurchaseValidateFacebookInstant_Call) Run(run func(ctx context.Context, userID string, signedRequest string, persist bool)) *MockNakamaModule_PurchaseValidateFacebookInstant_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_PurchaseValidateFacebookInstant_Call) Return(_a0 *api.ValidatePurchaseResponse, _a1 error) *MockNakamaModule_PurchaseValidateFacebookInstant_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_PurchaseValidateFacebookInstant_Call) RunAndReturn(run func(context.Context, string, string, bool) (*api.ValidatePurchaseResponse, error)) *MockNakamaModule_PurchaseValidateFacebookInstant_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseValidateGoogle provides a mock function with given fields: ctx, userID, receipt, persist, overrides
func (_m *MockNakamaModule) PurchaseValidateGoogle(ctx context.Context, userID string, receipt string, persist bool, overrides ...struct {
	ClientEmail string
	PrivateKey  string
}) (*api.ValidatePurchaseResponse, error) {
	_va := make([]interface{}, len(overrides))
	for _i := range overrides {
		_va[_i] = overrides[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseValidateGoogle")
	}

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, overrides...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) error); ok {
		r1 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_PurchaseValidateGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseValidateGoogle'
type MockNakamaModule_PurchaseValidateGoogle_Call struct {
	*mock.Call
}

// PurchaseValidateGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - receipt string
//   - persist bool
//   - overrides ...struct{ClientEmail string;PrivateKey string}
func (_e *MockNakamaModule_Expecter) PurchaseValidateGoogle(ctx interface{}, userID interface{}, receipt interface{}, persist interface{}, overrides ...interface{}) *MockNakamaModule_PurchaseValidateGoogle_Call {
	return &MockNakamaModule_PurchaseValidateGoogle_Call{Call: _e.mock.On("PurchaseValidateGoogle",
		append([]interface{}{ctx, userID, receipt, persist}, overrides...)...)}
}

func (_c *MockNakamaModule_PurchaseValidateGoogle_Call) Run(run func(ctx context.Context, userID string, receipt string, persist bool, overrides ...struct {
	ClientEmail string
	PrivateKey  string
})) *MockNakamaModule_PurchaseValidateGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]struct {
			ClientEmail string
			PrivateKey  string
		}, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(struct {
					ClientEmail string
					PrivateKey  string
				})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool), variadicArgs...)
	})
	return _c
}

func (_c *MockNakamaModule_PurchaseValidateGoogle_Call) Return(_a0 *api.ValidatePurchaseResponse, _a1 error) *MockNakamaModule_PurchaseValidateGoogle_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_PurchaseValidateGoogle_Call) RunAndReturn(run func(context.Context, string, string, bool, ...struct {
	ClientEmail string
	PrivateKey  string
}) (*api.ValidatePurchaseResponse, error)) *MockNakamaModule_PurchaseValidateGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseValidateHuawei provides a mock function with given fields: ctx, userID, signature, inAppPurchaseData, persist
func (_m *MockNakamaModule) PurchaseValidateHuawei(ctx context.Context, userID string, signature string, inAppPurchaseData string, persist bool) (*api.ValidatePurchaseResponse, error) {
	ret := _m.Called(ctx, userID, signature, inAppPurchaseData, persist)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseValidateHuawei")
	}

	var r0 *api.ValidatePurchaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) (*api.ValidatePurchaseResponse, error)); ok {
		return rf(ctx, userID, signature, inAppPurchaseData, persist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, bool) *api.ValidatePurchaseResponse); ok {
		r0 = rf(ctx, userID, signature, inAppPurchaseData, persist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatePurchaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, bool) error); ok {
		r1 = rf(ctx, userID, signature, inAppPurchaseData, persist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_PurchaseValidateHuawei_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseValidateHuawei'
type MockNakamaModule_PurchaseValidateHuawei_Call struct {
	*mock.Call
}

// PurchaseValidateHuawei is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - signature string
//   - inAppPurchaseData string
//   - persist bool
func (_e *MockNakamaModule_Expecter) PurchaseValidateHuawei(ctx interface{}, userID interface{}, signature interface{}, inAppPurchaseData interface{}, persist interface{}) *MockNakamaModule_PurchaseValidateHuawei_Call {
	return &MockNakamaModule_PurchaseValidateHuawei_Call{Call: _e.mock.On("PurchaseValidateHuawei", ctx, userID, signature, inAppPurchaseData, persist)}
}

func (_c *MockNakamaModule_PurchaseValidateHuawei_Call) Run(run func(ctx context.Context, userID string, signature string, inAppPurchaseData string, persist bool)) *MockNakamaModule_PurchaseValidateHuawei_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_PurchaseValidateHuawei_Call) Return(_a0 *api.ValidatePurchaseResponse, _a1 error) *MockNakamaModule_PurchaseValidateHuawei_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_PurchaseValidateHuawei_Call) RunAndReturn(run func(context.Context, string, string, string, bool) (*api.ValidatePurchaseResponse, error)) *MockNakamaModule_PurchaseValidateHuawei_Call {
	_c.Call.Return(run)
	return _c
}

// PurchasesList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *MockNakamaModule) PurchasesList(ctx context.Context, userID string, limit int, cursor string) (*api.PurchaseList, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for PurchasesList")
	}

	var r0 *api.PurchaseList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*api.PurchaseList, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *api.PurchaseList); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PurchaseList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_PurchasesList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchasesList'
type MockNakamaModule_PurchasesList_Call struct {
	*mock.Call
}

// PurchasesList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - cursor string
func (_e *MockNakamaModule_Expecter) PurchasesList(ctx interface{}, userID interface{}, limit interface{}, cursor interface{}) *MockNakamaModule_PurchasesList_Call {
	return &MockNakamaModule_PurchasesList_Call{Call: _e.mock.On("PurchasesList", ctx, userID, limit, cursor)}
}

func (_c *MockNakamaModule_PurchasesList_Call) Run(run func(ctx context.Context, userID string, limit int, cursor string)) *MockNakamaModule_PurchasesList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_PurchasesList_Call) Return(_a0 *api.PurchaseList, _a1 error) *MockNakamaModule_PurchasesList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_PurchasesList_Call) RunAndReturn(run func(context.Context, string, int, string) (*api.PurchaseList, error)) *MockNakamaModule_PurchasesList_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFile provides a mock function with given fields: path
func (_m *MockNakamaModule) ReadFile(path string) (*os.File, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for ReadFile")
	}

	var r0 *os.File
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*os.File, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) *os.File); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*os.File)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_ReadFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFile'
type MockNakamaModule_ReadFile_Call struct {
	*mock.Call
}

// ReadFile is a helper method to define mock.On call
//   - path string
func (_e *MockNakamaModule_Expecter) ReadFile(path interface{}) *MockNakamaModule_ReadFile_Call {
	return &MockNakamaModule_ReadFile_Call{Call: _e.mock.On("ReadFile", path)}
}

func (_c *MockNakamaModule_ReadFile_Call) Run(run func(path string)) *MockNakamaModule_ReadFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockNakamaModule_ReadFile_Call) Return(_a0 *os.File, _a1 error) *MockNakamaModule_ReadFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_ReadFile_Call) RunAndReturn(run func(string) (*os.File, error)) *MockNakamaModule_ReadFile_Call {
	_c.Call.Return(run)
	return _c
}

// SessionDisconnect provides a mock function with given fields: ctx, sessionID, reason
func (_m *MockNakamaModule) SessionDisconnect(ctx context.Context, sessionID string, reason ...runtime.PresenceReason) error {
	_va := make([]interface{}, len(reason))
	for _i := range reason {
		_va[_i] = reason[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, sessionID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SessionDisconnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...runtime.PresenceReason) error); ok {
		r0 = rf(ctx, sessionID, reason...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_SessionDisconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SessionDisconnect'
type MockNakamaModule_SessionDisconnect_Call struct {
	*mock.Call
}

// SessionDisconnect is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID string
//   - reason ...runtime.PresenceReason
func (_e *MockNakamaModule_Expecter) SessionDisconnect(ctx interface{}, sessionID interface{}, reason ...interface{}) *MockNakamaModule_SessionDisconnect_Call {
	return &MockNakamaModule_SessionDisconnect_Call{Call: _e.mock.On("SessionDisconnect",
		append([]interface{}{ctx, sessionID}, reason...)...)}
}

func (_c *MockNakamaModule_SessionDisconnect_Call) Run(run func(ctx context.Context, sessionID string, reason ...runtime.PresenceReason)) *MockNakamaModule_SessionDisconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]runtime.PresenceReason, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(runtime.PresenceReason)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockNakamaModule_SessionDisconnect_Call) Return(_a0 error) *MockNakamaModule_SessionDisconnect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_SessionDisconnect_Call) RunAndReturn(run func(context.Context, string, ...runtime.PresenceReason) error) *MockNakamaModule_SessionDisconnect_Call {
	_c.Call.Return(run)
	return _c
}

// SessionLogout provides a mock function with given fields: userID, token, refreshToken
func (_m *MockNakamaModule) SessionLogout(userID string, token string, refreshToken string) error {
	ret := _m.Called(userID, token, refreshToken)

	if len(ret) == 0 {
		panic("no return value specified for SessionLogout")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(userID, token, refreshToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_SessionLogout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SessionLogout'
type MockNakamaModule_SessionLogout_Call struct {
	*mock.Call
}

// SessionLogout is a helper method to define mock.On call
//   - userID string
//   - token string
//   - refreshToken string
func (_e *MockNakamaModule_Expecter) SessionLogout(userID interface{}, token interface{}, refreshToken interface{}) *MockNakamaModule_SessionLogout_Call {
	return &MockNakamaModule_SessionLogout_Call{Call: _e.mock.On("SessionLogout", userID, token, refreshToken)}
}

func (_c *MockNakamaModule_SessionLogout_Call) Run(run func(userID string, token string, refreshToken string)) *MockNakamaModule_SessionLogout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_SessionLogout_Call) Return(_a0 error) *MockNakamaModule_SessionLogout_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_SessionLogout_Call) RunAndReturn(run func(string, string, string) error) *MockNakamaModule_SessionLogout_Call {
	_c.Call.Return(run)
	return _c
}

// StatusFollow provides a mock function with given fields: sessionID, userIDs
func (_m *MockNakamaModule) StatusFollow(sessionID string, userIDs []string) error {
	ret := _m.Called(sessionID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for StatusFollow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []string) error); ok {
		r0 = rf(sessionID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_StatusFollow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatusFollow'
type MockNakamaModule_StatusFollow_Call struct {
	*mock.Call
}

// StatusFollow is a helper method to define mock.On call
//   - sessionID string
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) StatusFollow(sessionID interface{}, userIDs interface{}) *MockNakamaModule_StatusFollow_Call {
	return &MockNakamaModule_StatusFollow_Call{Call: _e.mock.On("StatusFollow", sessionID, userIDs)}
}

func (_c *MockNakamaModule_StatusFollow_Call) Run(run func(sessionID string, userIDs []string)) *MockNakamaModule_StatusFollow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_StatusFollow_Call) Return(_a0 error) *MockNakamaModule_StatusFollow_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_StatusFollow_Call) RunAndReturn(run func(string, []string) error) *MockNakamaModule_StatusFollow_Call {
	_c.Call.Return(run)
	return _c
}

// StatusUnfollow provides a mock function with given fields: sessionID, userIDs
func (_m *MockNakamaModule) StatusUnfollow(sessionID string, userIDs []string) error {
	ret := _m.Called(sessionID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for StatusUnfollow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []string) error); ok {
		r0 = rf(sessionID, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_StatusUnfollow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatusUnfollow'
type MockNakamaModule_StatusUnfollow_Call struct {
	*mock.Call
}

// StatusUnfollow is a helper method to define mock.On call
//   - sessionID string
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) StatusUnfollow(sessionID interface{}, userIDs interface{}) *MockNakamaModule_StatusUnfollow_Call {
	return &MockNakamaModule_StatusUnfollow_Call{Call: _e.mock.On("StatusUnfollow", sessionID, userIDs)}
}

func (_c *MockNakamaModule_StatusUnfollow_Call) Run(run func(sessionID string, userIDs []string)) *MockNakamaModule_StatusUnfollow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_StatusUnfollow_Call) Return(_a0 error) *MockNakamaModule_StatusUnfollow_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_StatusUnfollow_Call) RunAndReturn(run func(string, []string) error) *MockNakamaModule_StatusUnfollow_Call {
	_c.Call.Return(run)
	return _c
}

// StorageDelete provides a mock function with given fields: ctx, deletes
func (_m *MockNakamaModule) StorageDelete(ctx context.Context, deletes []*runtime.StorageDelete) error {
	ret := _m.Called(ctx, deletes)

	if len(ret) == 0 {
		panic("no return value specified for StorageDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageDelete) error); ok {
		r0 = rf(ctx, deletes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_StorageDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StorageDelete'
type MockNakamaModule_StorageDelete_Call struct {
	*mock.Call
}

// StorageDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - deletes []*runtime.StorageDelete
func (_e *MockNakamaModule_Expecter) StorageDelete(ctx interface{}, deletes interface{}) *MockNakamaModule_StorageDelete_Call {
	return &MockNakamaModule_StorageDelete_Call{Call: _e.mock.On("StorageDelete", ctx, deletes)}
}

func (_c *MockNakamaModule_StorageDelete_Call) Run(run func(ctx context.Context, deletes []*runtime.StorageDelete)) *MockNakamaModule_StorageDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.StorageDelete))
	})
	return _c
}

func (_c *MockNakamaModule_StorageDelete_Call) Return(_a0 error) *MockNakamaModule_StorageDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_StorageDelete_Call) RunAndReturn(run func(context.Context, []*runtime.StorageDelete) error) *MockNakamaModule_StorageDelete_Call {
	_c.Call.Return(run)
	return _c
}

// StorageIndexList provides a mock function with given fields: ctx, callerID, indexName, query, limit, order, cursor
func (_m *MockNakamaModule) StorageIndexList(ctx context.Context, callerID string, indexName string, query string, limit int, order []string, cursor string) (*api.StorageObjects, string, error) {
	ret := _m.Called(ctx, callerID, indexName, query, limit, order, cursor)

	if len(ret) == 0 {
		panic("no return value specified for StorageIndexList")
	}

	var r0 *api.StorageObjects
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, []string, string) (*api.StorageObjects, string, error)); ok {
		return rf(ctx, callerID, indexName, query, limit, order, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, []string, string) *api.StorageObjects); ok {
		r0 = rf(ctx, callerID, indexName, query, limit, order, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.StorageObjects)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int, []string, string) string); ok {
		r1 = rf(ctx, callerID, indexName, query, limit, order, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, int, []string, string) error); ok {
		r2 = rf(ctx, callerID, indexName, query, limit, order, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_StorageIndexList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StorageIndexList'
type MockNakamaModule_StorageIndexList_Call struct {
	*mock.Call
}

// StorageIndexList is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - indexName string
//   - query string
//   - limit int
//   - order []string
//   - cursor string
func (_e *MockNakamaModule_Expecter) StorageIndexList(ctx interface{}, callerID interface{}, indexName interface{}, query interface{}, limit interface{}, order interface{}, cursor interface{}) *MockNakamaModule_StorageIndexList_Call {
	return &MockNakamaModule_StorageIndexList_Call{Call: _e.mock.On("StorageIndexList", ctx, callerID, indexName, query, limit, order, cursor)}
}

func (_c *MockNakamaModule_StorageIndexList_Call) Run(run func(ctx context.Context, callerID string, indexName string, query string, limit int, order []string, cursor string)) *MockNakamaModule_StorageIndexList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int), args[5].([]string), args[6].(string))
	})
	return _c
}

func (_c *MockNakamaModule_StorageIndexList_Call) Return(_a0 *api.StorageObjects, _a1 string, _a2 error) *MockNakamaModule_StorageIndexList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_StorageIndexList_Call) RunAndReturn(run func(context.Context, string, string, string, int, []string, string) (*api.StorageObjects, string, error)) *MockNakamaModule_StorageIndexList_Call {
	_c.Call.Return(run)
	return _c
}

// StorageList provides a mock function with given fields: ctx, callerID, userID, collection, limit, cursor
func (_m *MockNakamaModule) StorageList(ctx context.Context, callerID string, userID string, collection string, limit int, cursor string) ([]*api.StorageObject, string, error) {
	ret := _m.Called(ctx, callerID, userID, collection, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for StorageList")
	}

	var r0 []*api.StorageObject
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, string) ([]*api.StorageObject, string, error)); ok {
		return rf(ctx, callerID, userID, collection, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, string) []*api.StorageObject); ok {
		r0 = rf(ctx, callerID, userID, collection, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObject)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int, string) string); ok {
		r1 = rf(ctx, callerID, userID, collection, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, int, string) error); ok {
		r2 = rf(ctx, callerID, userID, collection, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_StorageList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StorageList'
type MockNakamaModule_StorageList_Call struct {
	*mock.Call
}

// StorageList is a helper method to define mock.On call
//   - ctx context.Context
//   - callerID string
//   - userID string
//   - collection string
//   - limit int
//   - cursor string
func (_e *MockNakamaModule_Expecter) StorageList(ctx interface{}, callerID interface{}, userID interface{}, collection interface{}, limit interface{}, cursor interface{}) *MockNakamaModule_StorageList_Call {
	return &MockNakamaModule_StorageList_Call{Call: _e.mock.On("StorageList", ctx, callerID, userID, collection, limit, cursor)}
}

func (_c *MockNakamaModule_StorageList_Call) Run(run func(ctx context.Context, callerID string, userID string, collection string, limit int, cursor string)) *MockNakamaModule_StorageList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int), args[5].(string))
	})
	return _c
}

func (_c *MockNakamaModule_StorageList_Call) Return(_a0 []*api.StorageObject, _a1 string, _a2 error) *MockNakamaModule_StorageList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_StorageList_Call) RunAndReturn(run func(context.Context, string, string, string, int, string) ([]*api.StorageObject, string, error)) *MockNakamaModule_StorageList_Call {
	_c.Call.Return(run)
	return _c
}

// StorageRead provides a mock function with given fields: ctx, reads
func (_m *MockNakamaModule) StorageRead(ctx context.Context, reads []*runtime.StorageRead) ([]*api.StorageObject, error) {
	ret := _m.Called(ctx, reads)

	if len(ret) == 0 {
		panic("no return value specified for StorageRead")
	}

	var r0 []*api.StorageObject
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageRead) ([]*api.StorageObject, error)); ok {
		return rf(ctx, reads)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageRead) []*api.StorageObject); ok {
		r0 = rf(ctx, reads)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObject)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.StorageRead) error); ok {
		r1 = rf(ctx, reads)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_StorageRead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StorageRead'
type MockNakamaModule_StorageRead_Call struct {
	*mock.Call
}

// StorageRead is a helper method to define mock.On call
//   - ctx context.Context
//   - reads []*runtime.StorageRead
func (_e *MockNakamaModule_Expecter) StorageRead(ctx interface{}, reads interface{}) *MockNakamaModule_StorageRead_Call {
	return &MockNakamaModule_StorageRead_Call{Call: _e.mock.On("StorageRead", ctx, reads)}
}

func (_c *MockNakamaModule_StorageRead_Call) Run(run func(ctx context.Context, reads []*runtime.StorageRead)) *MockNakamaModule_StorageRead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.StorageRead))
	})
	return _c
}

func (_c *MockNakamaModule_StorageRead_Call) Return(_a0 []*api.StorageObject, _a1 error) *MockNakamaModule_StorageRead_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_StorageRead_Call) RunAndReturn(run func(context.Context, []*runtime.StorageRead) ([]*api.StorageObject, error)) *MockNakamaModule_StorageRead_Call {
	_c.Call.Return(run)
	return _c
}

// StorageWrite provides a mock function with given fields: ctx, writes
func (_m *MockNakamaModule) StorageWrite(ctx context.Context, writes []*runtime.StorageWrite) ([]*api.StorageObjectAck, error) {
	ret := _m.Called(ctx, writes)

	if len(ret) == 0 {
		panic("no return value specified for StorageWrite")
	}

	var r0 []*api.StorageObjectAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageWrite) ([]*api.StorageObjectAck, error)); ok {
		return rf(ctx, writes)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.StorageWrite) []*api.StorageObjectAck); ok {
		r0 = rf(ctx, writes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.StorageObjectAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.StorageWrite) error); ok {
		r1 = rf(ctx, writes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_StorageWrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StorageWrite'
type MockNakamaModule_StorageWrite_Call struct {
	*mock.Call
}

// StorageWrite is a helper method to define mock.On call
//   - ctx context.Context
//   - writes []*runtime.StorageWrite
func (_e *MockNakamaModule_Expecter) StorageWrite(ctx interface{}, writes interface{}) *MockNakamaModule_StorageWrite_Call {
	return &MockNakamaModule_StorageWrite_Call{Call: _e.mock.On("StorageWrite", ctx, writes)}
}

func (_c *MockNakamaModule_StorageWrite_Call) Run(run func(ctx context.Context, writes []*runtime.StorageWrite)) *MockNakamaModule_StorageWrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.StorageWrite))
	})
	return _c
}

func (_c *MockNakamaModule_StorageWrite_Call) Return(_a0 []*api.StorageObjectAck, _a1 error) *MockNakamaModule_StorageWrite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_StorageWrite_Call) RunAndReturn(run func(context.Context, []*runtime.StorageWrite) ([]*api.StorageObjectAck, error)) *MockNakamaModule_StorageWrite_Call {
	_c.Call.Return(run)
	return _c
}

// StreamClose provides a mock function with given fields: mode, subject, subcontext, label
func (_m *MockNakamaModule) StreamClose(mode uint8, subject string, subcontext string, label string) error {
	ret := _m.Called(mode, subject, subcontext, label)

	if len(ret) == 0 {
		panic("no return value specified for StreamClose")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string) error); ok {
		r0 = rf(mode, subject, subcontext, label)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_StreamClose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamClose'
type MockNakamaModule_StreamClose_Call struct {
	*mock.Call
}

// StreamClose is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
func (_e *MockNakamaModule_Expecter) StreamClose(mode interface{}, subject interface{}, subcontext interface{}, label interface{}) *MockNakamaModule_StreamClose_Call {
	return &MockNakamaModule_StreamClose_Call{Call: _e.mock.On("StreamClose", mode, subject, subcontext, label)}
}

func (_c *MockNakamaModule_StreamClose_Call) Run(run func(mode uint8, subject string, subcontext string, label string)) *MockNakamaModule_StreamClose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_StreamClose_Call) Return(_a0 error) *MockNakamaModule_StreamClose_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_StreamClose_Call) RunAndReturn(run func(uint8, string, string, string) error) *MockNakamaModule_StreamClose_Call {
	_c.Call.Return(run)
	return _c
}

// StreamCount provides a mock function with given fields: mode, subject, subcontext, label
func (_m *MockNakamaModule) StreamCount(mode uint8, subject string, subcontext string, label string) (int, error) {
	ret := _m.Called(mode, subject, subcontext, label)

	if len(ret) == 0 {
		panic("no return value specified for StreamCount")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string) (int, error)); ok {
		return rf(mode, subject, subcontext, label)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string) int); ok {
		r0 = rf(mode, subject, subcontext, label)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string) error); ok {
		r1 = rf(mode, subject, subcontext, label)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_StreamCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamCount'
type MockNakamaModule_StreamCount_Call struct {
	*mock.Call
}

// StreamCount is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
func (_e *MockNakamaModule_Expecter) StreamCount(mode interface{}, subject interface{}, subcontext interface{}, label interface{}) *MockNakamaModule_StreamCount_Call {
	return &MockNakamaModule_StreamCount_Call{Call: _e.mock.On("StreamCount", mode, subject, subcontext, label)}
}

func (_c *MockNakamaModule_StreamCount_Call) Run(run func(mode uint8, subject string, subcontext string, label string)) *MockNakamaModule_StreamCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_StreamCount_Call) Return(_a0 int, _a1 error) *MockNakamaModule_StreamCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_StreamCount_Call) RunAndReturn(run func(uint8, string, string, string) (int, error)) *MockNakamaModule_StreamCount_Call {
	_c.Call.Return(run)
	return _c
}

// StreamSend provides a mock function with given fields: mode, subject, subcontext, label, data, presences, reliable
func (_m *MockNakamaModule) StreamSend(mode uint8, subject string, subcontext string, label string, data string, presences []runtime.Presence, reliable bool) error {
	ret := _m.Called(mode, subject, subcontext, label, data, presences, reliable)

	if len(ret) == 0 {
		panic("no return value specified for StreamSend")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, []runtime.Presence, bool) error); ok {
		r0 = rf(mode, subject, subcontext, label, data, presences, reliable)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_StreamSend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamSend'
type MockNakamaModule_StreamSend_Call struct {
	*mock.Call
}

// StreamSend is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - data string
//   - presences []runtime.Presence
//   - reliable bool
func (_e *MockNakamaModule_Expecter) StreamSend(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, data interface{}, presences interface{}, reliable interface{}) *MockNakamaModule_StreamSend_Call {
	return &MockNakamaModule_StreamSend_Call{Call: _e.mock.On("StreamSend", mode, subject, subcontext, label, data, presences, reliable)}
}

func (_c *MockNakamaModule_StreamSend_Call) Run(run func(mode uint8, subject string, subcontext string, label string, data string, presences []runtime.Presence, reliable bool)) *MockNakamaModule_StreamSend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].([]runtime.Presence), args[6].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_StreamSend_Call) Return(_a0 error) *MockNakamaModule_StreamSend_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_StreamSend_Call) RunAndReturn(run func(uint8, string, string, string, string, []runtime.Presence, bool) error) *MockNakamaModule_StreamSend_Call {
	_c.Call.Return(run)
	return _c
}

// StreamSendRaw provides a mock function with given fields: mode, subject, subcontext, label, msg, presences, reliable
func (_m *MockNakamaModule) StreamSendRaw(mode uint8, subject string, subcontext string, label string, msg *rtapi.Envelope, presences []runtime.Presence, reliable bool) error {
	ret := _m.Called(mode, subject, subcontext, label, msg, presences, reliable)

	if len(ret) == 0 {
		panic("no return value specified for StreamSendRaw")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, *rtapi.Envelope, []runtime.Presence, bool) error); ok {
		r0 = rf(mode, subject, subcontext, label, msg, presences, reliable)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_StreamSendRaw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamSendRaw'
type MockNakamaModule_StreamSendRaw_Call struct {
	*mock.Call
}

// StreamSendRaw is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - msg *rtapi.Envelope
//   - presences []runtime.Presence
//   - reliable bool
func (_e *MockNakamaModule_Expecter) StreamSendRaw(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, msg interface{}, presences interface{}, reliable interface{}) *MockNakamaModule_StreamSendRaw_Call {
	return &MockNakamaModule_StreamSendRaw_Call{Call: _e.mock.On("StreamSendRaw", mode, subject, subcontext, label, msg, presences, reliable)}
}

func (_c *MockNakamaModule_StreamSendRaw_Call) Run(run func(mode uint8, subject string, subcontext string, label string, msg *rtapi.Envelope, presences []runtime.Presence, reliable bool)) *MockNakamaModule_StreamSendRaw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(*rtapi.Envelope), args[5].([]runtime.Presence), args[6].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_StreamSendRaw_Call) Return(_a0 error) *MockNakamaModule_StreamSendRaw_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_StreamSendRaw_Call) RunAndReturn(run func(uint8, string, string, string, *rtapi.Envelope, []runtime.Presence, bool) error) *MockNakamaModule_StreamSendRaw_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserGet provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID
func (_m *MockNakamaModule) StreamUserGet(mode uint8, subject string, subcontext string, label string, userID string, sessionID string) (runtime.PresenceMeta, error) {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserGet")
	}

	var r0 runtime.PresenceMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string) (runtime.PresenceMeta, error)); ok {
		return rf(mode, subject, subcontext, label, userID, sessionID)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string) runtime.PresenceMeta); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.PresenceMeta)
		}
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string, string, string) error); ok {
		r1 = rf(mode, subject, subcontext, label, userID, sessionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_StreamUserGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserGet'
type MockNakamaModule_StreamUserGet_Call struct {
	*mock.Call
}

// StreamUserGet is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - userID string
//   - sessionID string
func (_e *MockNakamaModule_Expecter) StreamUserGet(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, userID interface{}, sessionID interface{}) *MockNakamaModule_StreamUserGet_Call {
	return &MockNakamaModule_StreamUserGet_Call{Call: _e.mock.On("StreamUserGet", mode, subject, subcontext, label, userID, sessionID)}
}

func (_c *MockNakamaModule_StreamUserGet_Call) Run(run func(mode uint8, subject string, subcontext string, label string, userID string, sessionID string)) *MockNakamaModule_StreamUserGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string))
	})
	return _c
}

func (_c *MockNakamaModule_StreamUserGet_Call) Return(_a0 runtime.PresenceMeta, _a1 error) *MockNakamaModule_StreamUserGet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_StreamUserGet_Call) RunAndReturn(run func(uint8, string, string, string, string, string) (runtime.PresenceMeta, error)) *MockNakamaModule_StreamUserGet_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserJoin provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status
func (_m *MockNakamaModule) StreamUserJoin(mode uint8, subject string, subcontext string, label string, userID string, sessionID string, hidden bool, persistence bool, status string) (bool, error) {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserJoin")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string, bool, bool, string) (bool, error)); ok {
		return rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string, bool, bool, string) bool); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string, string, string, bool, bool, string) error); ok {
		r1 = rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_StreamUserJoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserJoin'
type MockNakamaModule_StreamUserJoin_Call struct {
	*mock.Call
}

// StreamUserJoin is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - userID string
//   - sessionID string
//   - hidden bool
//   - persistence bool
//   - status string
func (_e *MockNakamaModule_Expecter) StreamUserJoin(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, userID interface{}, sessionID interface{}, hidden interface{}, persistence interface{}, status interface{}) *MockNakamaModule_StreamUserJoin_Call {
	return &MockNakamaModule_StreamUserJoin_Call{Call: _e.mock.On("StreamUserJoin", mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)}
}

func (_c *MockNakamaModule_StreamUserJoin_Call) Run(run func(mode uint8, subject string, subcontext string, label string, userID string, sessionID string, hidden bool, persistence bool, status string)) *MockNakamaModule_StreamUserJoin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string), args[6].(bool), args[7].(bool), args[8].(string))
	})
	return _c
}

func (_c *MockNakamaModule_StreamUserJoin_Call) Return(_a0 bool, _a1 error) *MockNakamaModule_StreamUserJoin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_StreamUserJoin_Call) RunAndReturn(run func(uint8, string, string, string, string, string, bool, bool, string) (bool, error)) *MockNakamaModule_StreamUserJoin_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserKick provides a mock function with given fields: mode, subject, subcontext, label, presence
func (_m *MockNakamaModule) StreamUserKick(mode uint8, subject string, subcontext string, label string, presence runtime.Presence) error {
	ret := _m.Called(mode, subject, subcontext, label, presence)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserKick")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, runtime.Presence) error); ok {
		r0 = rf(mode, subject, subcontext, label, presence)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_StreamUserKick_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserKick'
type MockNakamaModule_StreamUserKick_Call struct {
	*mock.Call
}

// StreamUserKick is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - presence runtime.Presence
func (_e *MockNakamaModule_Expecter) StreamUserKick(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, presence interface{}) *MockNakamaModule_StreamUserKick_Call {
	return &MockNakamaModule_StreamUserKick_Call{Call: _e.mock.On("StreamUserKick", mode, subject, subcontext, label, presence)}
}

func (_c *MockNakamaModule_StreamUserKick_Call) Run(run func(mode uint8, subject string, subcontext string, label string, presence runtime.Presence)) *MockNakamaModule_StreamUserKick_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(runtime.Presence))
	})
	return _c
}

func (_c *MockNakamaModule_StreamUserKick_Call) Return(_a0 error) *MockNakamaModule_StreamUserKick_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_StreamUserKick_Call) RunAndReturn(run func(uint8, string, string, string, runtime.Presence) error) *MockNakamaModule_StreamUserKick_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserLeave provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID
func (_m *MockNakamaModule) StreamUserLeave(mode uint8, subject string, subcontext string, label string, userID string, sessionID string) error {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserLeave")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string) error); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_StreamUserLeave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserLeave'
type MockNakamaModule_StreamUserLeave_Call struct {
	*mock.Call
}

// StreamUserLeave is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - userID string
//   - sessionID string
func (_e *MockNakamaModule_Expecter) StreamUserLeave(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, userID interface{}, sessionID interface{}) *MockNakamaModule_StreamUserLeave_Call {
	return &MockNakamaModule_StreamUserLeave_Call{Call: _e.mock.On("StreamUserLeave", mode, subject, subcontext, label, userID, sessionID)}
}

func (_c *MockNakamaModule_StreamUserLeave_Call) Run(run func(mode uint8, subject string, subcontext string, label string, userID string, sessionID string)) *MockNakamaModule_StreamUserLeave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string))
	})
	return _c
}

func (_c *MockNakamaModule_StreamUserLeave_Call) Return(_a0 error) *MockNakamaModule_StreamUserLeave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_StreamUserLeave_Call) RunAndReturn(run func(uint8, string, string, string, string, string) error) *MockNakamaModule_StreamUserLeave_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserList provides a mock function with given fields: mode, subject, subcontext, label, includeHidden, includeNotHidden
func (_m *MockNakamaModule) StreamUserList(mode uint8, subject string, subcontext string, label string, includeHidden bool, includeNotHidden bool) ([]runtime.Presence, error) {
	ret := _m.Called(mode, subject, subcontext, label, includeHidden, includeNotHidden)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserList")
	}

	var r0 []runtime.Presence
	var r1 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, bool, bool) ([]runtime.Presence, error)); ok {
		return rf(mode, subject, subcontext, label, includeHidden, includeNotHidden)
	}
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, bool, bool) []runtime.Presence); ok {
		r0 = rf(mode, subject, subcontext, label, includeHidden, includeNotHidden)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.Presence)
		}
	}

	if rf, ok := ret.Get(1).(func(uint8, string, string, string, bool, bool) error); ok {
		r1 = rf(mode, subject, subcontext, label, includeHidden, includeNotHidden)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_StreamUserList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserList'
type MockNakamaModule_StreamUserList_Call struct {
	*mock.Call
}

// StreamUserList is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - includeHidden bool
//   - includeNotHidden bool
func (_e *MockNakamaModule_Expecter) StreamUserList(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, includeHidden interface{}, includeNotHidden interface{}) *MockNakamaModule_StreamUserList_Call {
	return &MockNakamaModule_StreamUserList_Call{Call: _e.mock.On("StreamUserList", mode, subject, subcontext, label, includeHidden, includeNotHidden)}
}

func (_c *MockNakamaModule_StreamUserList_Call) Run(run func(mode uint8, subject string, subcontext string, label string, includeHidden bool, includeNotHidden bool)) *MockNakamaModule_StreamUserList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(bool), args[5].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_StreamUserList_Call) Return(_a0 []runtime.Presence, _a1 error) *MockNakamaModule_StreamUserList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_StreamUserList_Call) RunAndReturn(run func(uint8, string, string, string, bool, bool) ([]runtime.Presence, error)) *MockNakamaModule_StreamUserList_Call {
	_c.Call.Return(run)
	return _c
}

// StreamUserUpdate provides a mock function with given fields: mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status
func (_m *MockNakamaModule) StreamUserUpdate(mode uint8, subject string, subcontext string, label string, userID string, sessionID string, hidden bool, persistence bool, status string) error {
	ret := _m.Called(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)

	if len(ret) == 0 {
		panic("no return value specified for StreamUserUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint8, string, string, string, string, string, bool, bool, string) error); ok {
		r0 = rf(mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_StreamUserUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamUserUpdate'
type MockNakamaModule_StreamUserUpdate_Call struct {
	*mock.Call
}

// StreamUserUpdate is a helper method to define mock.On call
//   - mode uint8
//   - subject string
//   - subcontext string
//   - label string
//   - userID string
//   - sessionID string
//   - hidden bool
//   - persistence bool
//   - status string
func (_e *MockNakamaModule_Expecter) StreamUserUpdate(mode interface{}, subject interface{}, subcontext interface{}, label interface{}, userID interface{}, sessionID interface{}, hidden interface{}, persistence interface{}, status interface{}) *MockNakamaModule_StreamUserUpdate_Call {
	return &MockNakamaModule_StreamUserUpdate_Call{Call: _e.mock.On("StreamUserUpdate", mode, subject, subcontext, label, userID, sessionID, hidden, persistence, status)}
}

func (_c *MockNakamaModule_StreamUserUpdate_Call) Run(run func(mode uint8, subject string, subcontext string, label string, userID string, sessionID string, hidden bool, persistence bool, status string)) *MockNakamaModule_StreamUserUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint8), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string), args[6].(bool), args[7].(bool), args[8].(string))
	})
	return _c
}

func (_c *MockNakamaModule_StreamUserUpdate_Call) Return(_a0 error) *MockNakamaModule_StreamUserUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_StreamUserUpdate_Call) RunAndReturn(run func(uint8, string, string, string, string, string, bool, bool, string) error) *MockNakamaModule_StreamUserUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// SubscriptionGetByProductId provides a mock function with given fields: ctx, userID, productID
func (_m *MockNakamaModule) SubscriptionGetByProductId(ctx context.Context, userID string, productID string) (*api.ValidatedSubscription, error) {
	ret := _m.Called(ctx, userID, productID)

	if len(ret) == 0 {
		panic("no return value specified for SubscriptionGetByProductId")
	}

	var r0 *api.ValidatedSubscription
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*api.ValidatedSubscription, error)); ok {
		return rf(ctx, userID, productID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *api.ValidatedSubscription); ok {
		r0 = rf(ctx, userID, productID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidatedSubscription)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userID, productID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_SubscriptionGetByProductId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscriptionGetByProductId'
type MockNakamaModule_SubscriptionGetByProductId_Call struct {
	*mock.Call
}

// SubscriptionGetByProductId is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - productID string
func (_e *MockNakamaModule_Expecter) SubscriptionGetByProductId(ctx interface{}, userID interface{}, productID interface{}) *MockNakamaModule_SubscriptionGetByProductId_Call {
	return &MockNakamaModule_SubscriptionGetByProductId_Call{Call: _e.mock.On("SubscriptionGetByProductId", ctx, userID, productID)}
}

func (_c *MockNakamaModule_SubscriptionGetByProductId_Call) Run(run func(ctx context.Context, userID string, productID string)) *MockNakamaModule_SubscriptionGetByProductId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_SubscriptionGetByProductId_Call) Return(_a0 *api.ValidatedSubscription, _a1 error) *MockNakamaModule_SubscriptionGetByProductId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_SubscriptionGetByProductId_Call) RunAndReturn(run func(context.Context, string, string) (*api.ValidatedSubscription, error)) *MockNakamaModule_SubscriptionGetByProductId_Call {
	_c.Call.Return(run)
	return _c
}

// SubscriptionValidateApple provides a mock function with given fields: ctx, userID, receipt, persist, passwordOverride
func (_m *MockNakamaModule) SubscriptionValidateApple(ctx context.Context, userID string, receipt string, persist bool, passwordOverride ...string) (*api.ValidateSubscriptionResponse, error) {
	_va := make([]interface{}, len(passwordOverride))
	for _i := range passwordOverride {
		_va[_i] = passwordOverride[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubscriptionValidateApple")
	}

	var r0 *api.ValidateSubscriptionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) (*api.ValidateSubscriptionResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, passwordOverride...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...string) *api.ValidateSubscriptionResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidateSubscriptionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...string) error); ok {
		r1 = rf(ctx, userID, receipt, persist, passwordOverride...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_SubscriptionValidateApple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscriptionValidateApple'
type MockNakamaModule_SubscriptionValidateApple_Call struct {
	*mock.Call
}

// SubscriptionValidateApple is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - receipt string
//   - persist bool
//   - passwordOverride ...string
func (_e *MockNakamaModule_Expecter) SubscriptionValidateApple(ctx interface{}, userID interface{}, receipt interface{}, persist interface{}, passwordOverride ...interface{}) *MockNakamaModule_SubscriptionValidateApple_Call {
	return &MockNakamaModule_SubscriptionValidateApple_Call{Call: _e.mock.On("SubscriptionValidateApple",
		append([]interface{}{ctx, userID, receipt, persist}, passwordOverride...)...)}
}

func (_c *MockNakamaModule_SubscriptionValidateApple_Call) Run(run func(ctx context.Context, userID string, receipt string, persist bool, passwordOverride ...string)) *MockNakamaModule_SubscriptionValidateApple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool), variadicArgs...)
	})
	return _c
}

func (_c *MockNakamaModule_SubscriptionValidateApple_Call) Return(_a0 *api.ValidateSubscriptionResponse, _a1 error) *MockNakamaModule_SubscriptionValidateApple_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_SubscriptionValidateApple_Call) RunAndReturn(run func(context.Context, string, string, bool, ...string) (*api.ValidateSubscriptionResponse, error)) *MockNakamaModule_SubscriptionValidateApple_Call {
	_c.Call.Return(run)
	return _c
}

// SubscriptionValidateGoogle provides a mock function with given fields: ctx, userID, receipt, persist, overrides
func (_m *MockNakamaModule) SubscriptionValidateGoogle(ctx context.Context, userID string, receipt string, persist bool, overrides ...struct {
	ClientEmail string
	PrivateKey  string
}) (*api.ValidateSubscriptionResponse, error) {
	_va := make([]interface{}, len(overrides))
	for _i := range overrides {
		_va[_i] = overrides[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, userID, receipt, persist)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubscriptionValidateGoogle")
	}

	var r0 *api.ValidateSubscriptionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) (*api.ValidateSubscriptionResponse, error)); ok {
		return rf(ctx, userID, receipt, persist, overrides...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) *api.ValidateSubscriptionResponse); ok {
		r0 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidateSubscriptionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, ...struct {
		ClientEmail string
		PrivateKey  string
	}) error); ok {
		r1 = rf(ctx, userID, receipt, persist, overrides...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_SubscriptionValidateGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscriptionValidateGoogle'
type MockNakamaModule_SubscriptionValidateGoogle_Call struct {
	*mock.Call
}

// SubscriptionValidateGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - receipt string
//   - persist bool
//   - overrides ...struct{ClientEmail string;PrivateKey string}
func (_e *MockNakamaModule_Expecter) SubscriptionValidateGoogle(ctx interface{}, userID interface{}, receipt interface{}, persist interface{}, overrides ...interface{}) *MockNakamaModule_SubscriptionValidateGoogle_Call {
	return &MockNakamaModule_SubscriptionValidateGoogle_Call{Call: _e.mock.On("SubscriptionValidateGoogle",
		append([]interface{}{ctx, userID, receipt, persist}, overrides...)...)}
}

func (_c *MockNakamaModule_SubscriptionValidateGoogle_Call) Run(run func(ctx context.Context, userID string, receipt string, persist bool, overrides ...struct {
	ClientEmail string
	PrivateKey  string
})) *MockNakamaModule_SubscriptionValidateGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]struct {
			ClientEmail string
			PrivateKey  string
		}, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(struct {
					ClientEmail string
					PrivateKey  string
				})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool), variadicArgs...)
	})
	return _c
}

func (_c *MockNakamaModule_SubscriptionValidateGoogle_Call) Return(_a0 *api.ValidateSubscriptionResponse, _a1 error) *MockNakamaModule_SubscriptionValidateGoogle_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_SubscriptionValidateGoogle_Call) RunAndReturn(run func(context.Context, string, string, bool, ...struct {
	ClientEmail string
	PrivateKey  string
}) (*api.ValidateSubscriptionResponse, error)) *MockNakamaModule_SubscriptionValidateGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// SubscriptionsList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *MockNakamaModule) SubscriptionsList(ctx context.Context, userID string, limit int, cursor string) (*api.SubscriptionList, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for SubscriptionsList")
	}

	var r0 *api.SubscriptionList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*api.SubscriptionList, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *api.SubscriptionList); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.SubscriptionList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_SubscriptionsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscriptionsList'
type MockNakamaModule_SubscriptionsList_Call struct {
	*mock.Call
}

// SubscriptionsList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - cursor string
func (_e *MockNakamaModule_Expecter) SubscriptionsList(ctx interface{}, userID interface{}, limit interface{}, cursor interface{}) *MockNakamaModule_SubscriptionsList_Call {
	return &MockNakamaModule_SubscriptionsList_Call{Call: _e.mock.On("SubscriptionsList", ctx, userID, limit, cursor)}
}

func (_c *MockNakamaModule_SubscriptionsList_Call) Run(run func(ctx context.Context, userID string, limit int, cursor string)) *MockNakamaModule_SubscriptionsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_SubscriptionsList_Call) Return(_a0 *api.SubscriptionList, _a1 error) *MockNakamaModule_SubscriptionsList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_SubscriptionsList_Call) RunAndReturn(run func(context.Context, string, int, string) (*api.SubscriptionList, error)) *MockNakamaModule_SubscriptionsList_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentAddAttempt provides a mock function with given fields: ctx, id, ownerID, count
func (_m *MockNakamaModule) TournamentAddAttempt(ctx context.Context, id string, ownerID string, count int) error {
	ret := _m.Called(ctx, id, ownerID, count)

	if len(ret) == 0 {
		panic("no return value specified for TournamentAddAttempt")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) error); ok {
		r0 = rf(ctx, id, ownerID, count)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_TournamentAddAttempt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentAddAttempt'
type MockNakamaModule_TournamentAddAttempt_Call struct {
	*mock.Call
}

// TournamentAddAttempt is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - count int
func (_e *MockNakamaModule_Expecter) TournamentAddAttempt(ctx interface{}, id interface{}, ownerID interface{}, count interface{}) *MockNakamaModule_TournamentAddAttempt_Call {
	return &MockNakamaModule_TournamentAddAttempt_Call{Call: _e.mock.On("TournamentAddAttempt", ctx, id, ownerID, count)}
}

func (_c *MockNakamaModule_TournamentAddAttempt_Call) Run(run func(ctx context.Context, id string, ownerID string, count int)) *MockNakamaModule_TournamentAddAttempt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentAddAttempt_Call) Return(_a0 error) *MockNakamaModule_TournamentAddAttempt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_TournamentAddAttempt_Call) RunAndReturn(run func(context.Context, string, string, int) error) *MockNakamaModule_TournamentAddAttempt_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentCreate provides a mock function with given fields: ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired, enableRanks
func (_m *MockNakamaModule) TournamentCreate(ctx context.Context, id string, authoritative bool, sortOrder string, operator string, resetSchedule string, metadata map[string]interface{}, title string, description string, category int, startTime int, endTime int, duration int, maxSize int, maxNumScore int, joinRequired bool, enableRanks bool) error {
	ret := _m.Called(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired, enableRanks)

	if len(ret) == 0 {
		panic("no return value specified for TournamentCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, string, string, string, map[string]interface{}, string, string, int, int, int, int, int, int, bool, bool) error); ok {
		r0 = rf(ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired, enableRanks)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_TournamentCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentCreate'
type MockNakamaModule_TournamentCreate_Call struct {
	*mock.Call
}

// TournamentCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - authoritative bool
//   - sortOrder string
//   - operator string
//   - resetSchedule string
//   - metadata map[string]interface{}
//   - title string
//   - description string
//   - category int
//   - startTime int
//   - endTime int
//   - duration int
//   - maxSize int
//   - maxNumScore int
//   - joinRequired bool
//   - enableRanks bool
func (_e *MockNakamaModule_Expecter) TournamentCreate(ctx interface{}, id interface{}, authoritative interface{}, sortOrder interface{}, operator interface{}, resetSchedule interface{}, metadata interface{}, title interface{}, description interface{}, category interface{}, startTime interface{}, endTime interface{}, duration interface{}, maxSize interface{}, maxNumScore interface{}, joinRequired interface{}, enableRanks interface{}) *MockNakamaModule_TournamentCreate_Call {
	return &MockNakamaModule_TournamentCreate_Call{Call: _e.mock.On("TournamentCreate", ctx, id, authoritative, sortOrder, operator, resetSchedule, metadata, title, description, category, startTime, endTime, duration, maxSize, maxNumScore, joinRequired, enableRanks)}
}

func (_c *MockNakamaModule_TournamentCreate_Call) Run(run func(ctx context.Context, id string, authoritative bool, sortOrder string, operator string, resetSchedule string, metadata map[string]interface{}, title string, description string, category int, startTime int, endTime int, duration int, maxSize int, maxNumScore int, joinRequired bool, enableRanks bool)) *MockNakamaModule_TournamentCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool), args[3].(string), args[4].(string), args[5].(string), args[6].(map[string]interface{}), args[7].(string), args[8].(string), args[9].(int), args[10].(int), args[11].(int), args[12].(int), args[13].(int), args[14].(int), args[15].(bool), args[16].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentCreate_Call) Return(_a0 error) *MockNakamaModule_TournamentCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_TournamentCreate_Call) RunAndReturn(run func(context.Context, string, bool, string, string, string, map[string]interface{}, string, string, int, int, int, int, int, int, bool, bool) error) *MockNakamaModule_TournamentCreate_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentDelete provides a mock function with given fields: ctx, id
func (_m *MockNakamaModule) TournamentDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for TournamentDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_TournamentDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentDelete'
type MockNakamaModule_TournamentDelete_Call struct {
	*mock.Call
}

// TournamentDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockNakamaModule_Expecter) TournamentDelete(ctx interface{}, id interface{}) *MockNakamaModule_TournamentDelete_Call {
	return &MockNakamaModule_TournamentDelete_Call{Call: _e.mock.On("TournamentDelete", ctx, id)}
}

func (_c *MockNakamaModule_TournamentDelete_Call) Run(run func(ctx context.Context, id string)) *MockNakamaModule_TournamentDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentDelete_Call) Return(_a0 error) *MockNakamaModule_TournamentDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_TournamentDelete_Call) RunAndReturn(run func(context.Context, string) error) *MockNakamaModule_TournamentDelete_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentJoin provides a mock function with given fields: ctx, id, ownerID, username
func (_m *MockNakamaModule) TournamentJoin(ctx context.Context, id string, ownerID string, username string) error {
	ret := _m.Called(ctx, id, ownerID, username)

	if len(ret) == 0 {
		panic("no return value specified for TournamentJoin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, id, ownerID, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_TournamentJoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentJoin'
type MockNakamaModule_TournamentJoin_Call struct {
	*mock.Call
}

// TournamentJoin is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - username string
func (_e *MockNakamaModule_Expecter) TournamentJoin(ctx interface{}, id interface{}, ownerID interface{}, username interface{}) *MockNakamaModule_TournamentJoin_Call {
	return &MockNakamaModule_TournamentJoin_Call{Call: _e.mock.On("TournamentJoin", ctx, id, ownerID, username)}
}

func (_c *MockNakamaModule_TournamentJoin_Call) Run(run func(ctx context.Context, id string, ownerID string, username string)) *MockNakamaModule_TournamentJoin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentJoin_Call) Return(_a0 error) *MockNakamaModule_TournamentJoin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_TournamentJoin_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockNakamaModule_TournamentJoin_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentList provides a mock function with given fields: ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor
func (_m *MockNakamaModule) TournamentList(ctx context.Context, categoryStart int, categoryEnd int, startTime int, endTime int, limit int, cursor string) (*api.TournamentList, error) {
	ret := _m.Called(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for TournamentList")
	}

	var r0 *api.TournamentList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, int, int, string) (*api.TournamentList, error)); ok {
		return rf(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, int, int, string) *api.TournamentList); ok {
		r0 = rf(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.TournamentList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int, int, int, string) error); ok {
		r1 = rf(ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_TournamentList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentList'
type MockNakamaModule_TournamentList_Call struct {
	*mock.Call
}

// TournamentList is a helper method to define mock.On call
//   - ctx context.Context
//   - categoryStart int
//   - categoryEnd int
//   - startTime int
//   - endTime int
//   - limit int
//   - cursor string
func (_e *MockNakamaModule_Expecter) TournamentList(ctx interface{}, categoryStart interface{}, categoryEnd interface{}, startTime interface{}, endTime interface{}, limit interface{}, cursor interface{}) *MockNakamaModule_TournamentList_Call {
	return &MockNakamaModule_TournamentList_Call{Call: _e.mock.On("TournamentList", ctx, categoryStart, categoryEnd, startTime, endTime, limit, cursor)}
}

func (_c *MockNakamaModule_TournamentList_Call) Run(run func(ctx context.Context, categoryStart int, categoryEnd int, startTime int, endTime int, limit int, cursor string)) *MockNakamaModule_TournamentList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int), args[4].(int), args[5].(int), args[6].(string))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentList_Call) Return(_a0 *api.TournamentList, _a1 error) *MockNakamaModule_TournamentList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_TournamentList_Call) RunAndReturn(run func(context.Context, int, int, int, int, int, string) (*api.TournamentList, error)) *MockNakamaModule_TournamentList_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentRanksDisable provides a mock function with given fields: ctx, id
func (_m *MockNakamaModule) TournamentRanksDisable(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for TournamentRanksDisable")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_TournamentRanksDisable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentRanksDisable'
type MockNakamaModule_TournamentRanksDisable_Call struct {
	*mock.Call
}

// TournamentRanksDisable is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockNakamaModule_Expecter) TournamentRanksDisable(ctx interface{}, id interface{}) *MockNakamaModule_TournamentRanksDisable_Call {
	return &MockNakamaModule_TournamentRanksDisable_Call{Call: _e.mock.On("TournamentRanksDisable", ctx, id)}
}

func (_c *MockNakamaModule_TournamentRanksDisable_Call) Run(run func(ctx context.Context, id string)) *MockNakamaModule_TournamentRanksDisable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentRanksDisable_Call) Return(_a0 error) *MockNakamaModule_TournamentRanksDisable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_TournamentRanksDisable_Call) RunAndReturn(run func(context.Context, string) error) *MockNakamaModule_TournamentRanksDisable_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentRecordDelete provides a mock function with given fields: ctx, id, ownerID
func (_m *MockNakamaModule) TournamentRecordDelete(ctx context.Context, id string, ownerID string) error {
	ret := _m.Called(ctx, id, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for TournamentRecordDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, id, ownerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_TournamentRecordDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentRecordDelete'
type MockNakamaModule_TournamentRecordDelete_Call struct {
	*mock.Call
}

// TournamentRecordDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
func (_e *MockNakamaModule_Expecter) TournamentRecordDelete(ctx interface{}, id interface{}, ownerID interface{}) *MockNakamaModule_TournamentRecordDelete_Call {
	return &MockNakamaModule_TournamentRecordDelete_Call{Call: _e.mock.On("TournamentRecordDelete", ctx, id, ownerID)}
}

func (_c *MockNakamaModule_TournamentRecordDelete_Call) Run(run func(ctx context.Context, id string, ownerID string)) *MockNakamaModule_TournamentRecordDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentRecordDelete_Call) Return(_a0 error) *MockNakamaModule_TournamentRecordDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_TournamentRecordDelete_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_TournamentRecordDelete_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentRecordWrite provides a mock function with given fields: ctx, id, ownerID, username, score, subscore, metadata, operatorOverride
func (_m *MockNakamaModule) TournamentRecordWrite(ctx context.Context, id string, ownerID string, username string, score int64, subscore int64, metadata map[string]interface{}, operatorOverride *int) (*api.LeaderboardRecord, error) {
	ret := _m.Called(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)

	if len(ret) == 0 {
		panic("no return value specified for TournamentRecordWrite")
	}

	var r0 *api.LeaderboardRecord
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) (*api.LeaderboardRecord, error)); ok {
		return rf(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) *api.LeaderboardRecord); ok {
		r0 = rf(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) error); ok {
		r1 = rf(ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_TournamentRecordWrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentRecordWrite'
type MockNakamaModule_TournamentRecordWrite_Call struct {
	*mock.Call
}

// TournamentRecordWrite is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - username string
//   - score int64
//   - subscore int64
//   - metadata map[string]interface{}
//   - operatorOverride *int
func (_e *MockNakamaModule_Expecter) TournamentRecordWrite(ctx interface{}, id interface{}, ownerID interface{}, username interface{}, score interface{}, subscore interface{}, metadata interface{}, operatorOverride interface{}) *MockNakamaModule_TournamentRecordWrite_Call {
	return &MockNakamaModule_TournamentRecordWrite_Call{Call: _e.mock.On("TournamentRecordWrite", ctx, id, ownerID, username, score, subscore, metadata, operatorOverride)}
}

func (_c *MockNakamaModule_TournamentRecordWrite_Call) Run(run func(ctx context.Context, id string, ownerID string, username string, score int64, subscore int64, metadata map[string]interface{}, operatorOverride *int)) *MockNakamaModule_TournamentRecordWrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64), args[5].(int64), args[6].(map[string]interface{}), args[7].(*int))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentRecordWrite_Call) Return(_a0 *api.LeaderboardRecord, _a1 error) *MockNakamaModule_TournamentRecordWrite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_TournamentRecordWrite_Call) RunAndReturn(run func(context.Context, string, string, string, int64, int64, map[string]interface{}, *int) (*api.LeaderboardRecord, error)) *MockNakamaModule_TournamentRecordWrite_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentRecordsHaystack provides a mock function with given fields: ctx, id, ownerID, limit, cursor, expiry
func (_m *MockNakamaModule) TournamentRecordsHaystack(ctx context.Context, id string, ownerID string, limit int, cursor string, expiry int64) (*api.TournamentRecordList, error) {
	ret := _m.Called(ctx, id, ownerID, limit, cursor, expiry)

	if len(ret) == 0 {
		panic("no return value specified for TournamentRecordsHaystack")
	}

	var r0 *api.TournamentRecordList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) (*api.TournamentRecordList, error)); ok {
		return rf(ctx, id, ownerID, limit, cursor, expiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, string, int64) *api.TournamentRecordList); ok {
		r0 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.TournamentRecordList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int, string, int64) error); ok {
		r1 = rf(ctx, id, ownerID, limit, cursor, expiry)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_TournamentRecordsHaystack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentRecordsHaystack'
type MockNakamaModule_TournamentRecordsHaystack_Call struct {
	*mock.Call
}

// TournamentRecordsHaystack is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ownerID string
//   - limit int
//   - cursor string
//   - expiry int64
func (_e *MockNakamaModule_Expecter) TournamentRecordsHaystack(ctx interface{}, id interface{}, ownerID interface{}, limit interface{}, cursor interface{}, expiry interface{}) *MockNakamaModule_TournamentRecordsHaystack_Call {
	return &MockNakamaModule_TournamentRecordsHaystack_Call{Call: _e.mock.On("TournamentRecordsHaystack", ctx, id, ownerID, limit, cursor, expiry)}
}

func (_c *MockNakamaModule_TournamentRecordsHaystack_Call) Run(run func(ctx context.Context, id string, ownerID string, limit int, cursor string, expiry int64)) *MockNakamaModule_TournamentRecordsHaystack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(string), args[5].(int64))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentRecordsHaystack_Call) Return(_a0 *api.TournamentRecordList, _a1 error) *MockNakamaModule_TournamentRecordsHaystack_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_TournamentRecordsHaystack_Call) RunAndReturn(run func(context.Context, string, string, int, string, int64) (*api.TournamentRecordList, error)) *MockNakamaModule_TournamentRecordsHaystack_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentRecordsList provides a mock function with given fields: ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry
func (_m *MockNakamaModule) TournamentRecordsList(ctx context.Context, tournamentId string, ownerIDs []string, limit int, cursor string, overrideExpiry int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error) {
	ret := _m.Called(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)

	if len(ret) == 0 {
		panic("no return value specified for TournamentRecordsList")
	}

	var r0 []*api.LeaderboardRecord
	var r1 []*api.LeaderboardRecord
	var r2 string
	var r3 string
	var r4 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error)); ok {
		return rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r0 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, int, string, int64) []*api.LeaderboardRecord); ok {
		r1 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*api.LeaderboardRecord)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, []string, int, string, int64) string); ok {
		r2 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, []string, int, string, int64) string); ok {
		r3 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		r3 = ret.Get(3).(string)
	}

	if rf, ok := ret.Get(4).(func(context.Context, string, []string, int, string, int64) error); ok {
		r4 = rf(ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MockNakamaModule_TournamentRecordsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentRecordsList'
type MockNakamaModule_TournamentRecordsList_Call struct {
	*mock.Call
}

// TournamentRecordsList is a helper method to define mock.On call
//   - ctx context.Context
//   - tournamentId string
//   - ownerIDs []string
//   - limit int
//   - cursor string
//   - overrideExpiry int64
func (_e *MockNakamaModule_Expecter) TournamentRecordsList(ctx interface{}, tournamentId interface{}, ownerIDs interface{}, limit interface{}, cursor interface{}, overrideExpiry interface{}) *MockNakamaModule_TournamentRecordsList_Call {
	return &MockNakamaModule_TournamentRecordsList_Call{Call: _e.mock.On("TournamentRecordsList", ctx, tournamentId, ownerIDs, limit, cursor, overrideExpiry)}
}

func (_c *MockNakamaModule_TournamentRecordsList_Call) Run(run func(ctx context.Context, tournamentId string, ownerIDs []string, limit int, cursor string, overrideExpiry int64)) *MockNakamaModule_TournamentRecordsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(int), args[4].(string), args[5].(int64))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentRecordsList_Call) Return(records []*api.LeaderboardRecord, ownerRecords []*api.LeaderboardRecord, prevCursor string, nextCursor string, err error) *MockNakamaModule_TournamentRecordsList_Call {
	_c.Call.Return(records, ownerRecords, prevCursor, nextCursor, err)
	return _c
}

func (_c *MockNakamaModule_TournamentRecordsList_Call) RunAndReturn(run func(context.Context, string, []string, int, string, int64) ([]*api.LeaderboardRecord, []*api.LeaderboardRecord, string, string, error)) *MockNakamaModule_TournamentRecordsList_Call {
	_c.Call.Return(run)
	return _c
}

// TournamentsGetId provides a mock function with given fields: ctx, tournamentIDs
func (_m *MockNakamaModule) TournamentsGetId(ctx context.Context, tournamentIDs []string) ([]*api.Tournament, error) {
	ret := _m.Called(ctx, tournamentIDs)

	if len(ret) == 0 {
		panic("no return value specified for TournamentsGetId")
	}

	var r0 []*api.Tournament
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.Tournament, error)); ok {
		return rf(ctx, tournamentIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.Tournament); ok {
		r0 = rf(ctx, tournamentIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Tournament)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, tournamentIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_TournamentsGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TournamentsGetId'
type MockNakamaModule_TournamentsGetId_Call struct {
	*mock.Call
}

// TournamentsGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - tournamentIDs []string
func (_e *MockNakamaModule_Expecter) TournamentsGetId(ctx interface{}, tournamentIDs interface{}) *MockNakamaModule_TournamentsGetId_Call {
	return &MockNakamaModule_TournamentsGetId_Call{Call: _e.mock.On("TournamentsGetId", ctx, tournamentIDs)}
}

func (_c *MockNakamaModule_TournamentsGetId_Call) Run(run func(ctx context.Context, tournamentIDs []string)) *MockNakamaModule_TournamentsGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_TournamentsGetId_Call) Return(_a0 []*api.Tournament, _a1 error) *MockNakamaModule_TournamentsGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_TournamentsGetId_Call) RunAndReturn(run func(context.Context, []string) ([]*api.Tournament, error)) *MockNakamaModule_TournamentsGetId_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkApple provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) UnlinkApple(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkApple")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UnlinkApple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkApple'
type MockNakamaModule_UnlinkApple_Call struct {
	*mock.Call
}

// UnlinkApple is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *MockNakamaModule_Expecter) UnlinkApple(ctx interface{}, userID interface{}, token interface{}) *MockNakamaModule_UnlinkApple_Call {
	return &MockNakamaModule_UnlinkApple_Call{Call: _e.mock.On("UnlinkApple", ctx, userID, token)}
}

func (_c *MockNakamaModule_UnlinkApple_Call) Run(run func(ctx context.Context, userID string, token string)) *MockNakamaModule_UnlinkApple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_UnlinkApple_Call) Return(_a0 error) *MockNakamaModule_UnlinkApple_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UnlinkApple_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_UnlinkApple_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkCustom provides a mock function with given fields: ctx, userID, customID
func (_m *MockNakamaModule) UnlinkCustom(ctx context.Context, userID string, customID string) error {
	ret := _m.Called(ctx, userID, customID)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkCustom")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, customID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UnlinkCustom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkCustom'
type MockNakamaModule_UnlinkCustom_Call struct {
	*mock.Call
}

// UnlinkCustom is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - customID string
func (_e *MockNakamaModule_Expecter) UnlinkCustom(ctx interface{}, userID interface{}, customID interface{}) *MockNakamaModule_UnlinkCustom_Call {
	return &MockNakamaModule_UnlinkCustom_Call{Call: _e.mock.On("UnlinkCustom", ctx, userID, customID)}
}

func (_c *MockNakamaModule_UnlinkCustom_Call) Run(run func(ctx context.Context, userID string, customID string)) *MockNakamaModule_UnlinkCustom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_UnlinkCustom_Call) Return(_a0 error) *MockNakamaModule_UnlinkCustom_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UnlinkCustom_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_UnlinkCustom_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkDevice provides a mock function with given fields: ctx, userID, deviceID
func (_m *MockNakamaModule) UnlinkDevice(ctx context.Context, userID string, deviceID string) error {
	ret := _m.Called(ctx, userID, deviceID)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkDevice")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, deviceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UnlinkDevice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkDevice'
type MockNakamaModule_UnlinkDevice_Call struct {
	*mock.Call
}

// UnlinkDevice is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - deviceID string
func (_e *MockNakamaModule_Expecter) UnlinkDevice(ctx interface{}, userID interface{}, deviceID interface{}) *MockNakamaModule_UnlinkDevice_Call {
	return &MockNakamaModule_UnlinkDevice_Call{Call: _e.mock.On("UnlinkDevice", ctx, userID, deviceID)}
}

func (_c *MockNakamaModule_UnlinkDevice_Call) Run(run func(ctx context.Context, userID string, deviceID string)) *MockNakamaModule_UnlinkDevice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_UnlinkDevice_Call) Return(_a0 error) *MockNakamaModule_UnlinkDevice_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UnlinkDevice_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_UnlinkDevice_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkEmail provides a mock function with given fields: ctx, userID, email
func (_m *MockNakamaModule) UnlinkEmail(ctx context.Context, userID string, email string) error {
	ret := _m.Called(ctx, userID, email)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkEmail")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, email)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UnlinkEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkEmail'
type MockNakamaModule_UnlinkEmail_Call struct {
	*mock.Call
}

// UnlinkEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - email string
func (_e *MockNakamaModule_Expecter) UnlinkEmail(ctx interface{}, userID interface{}, email interface{}) *MockNakamaModule_UnlinkEmail_Call {
	return &MockNakamaModule_UnlinkEmail_Call{Call: _e.mock.On("UnlinkEmail", ctx, userID, email)}
}

func (_c *MockNakamaModule_UnlinkEmail_Call) Run(run func(ctx context.Context, userID string, email string)) *MockNakamaModule_UnlinkEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_UnlinkEmail_Call) Return(_a0 error) *MockNakamaModule_UnlinkEmail_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UnlinkEmail_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_UnlinkEmail_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkFacebook provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) UnlinkFacebook(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkFacebook")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UnlinkFacebook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkFacebook'
type MockNakamaModule_UnlinkFacebook_Call struct {
	*mock.Call
}

// UnlinkFacebook is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *MockNakamaModule_Expecter) UnlinkFacebook(ctx interface{}, userID interface{}, token interface{}) *MockNakamaModule_UnlinkFacebook_Call {
	return &MockNakamaModule_UnlinkFacebook_Call{Call: _e.mock.On("UnlinkFacebook", ctx, userID, token)}
}

func (_c *MockNakamaModule_UnlinkFacebook_Call) Run(run func(ctx context.Context, userID string, token string)) *MockNakamaModule_UnlinkFacebook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_UnlinkFacebook_Call) Return(_a0 error) *MockNakamaModule_UnlinkFacebook_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UnlinkFacebook_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_UnlinkFacebook_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkFacebookInstantGame provides a mock function with given fields: ctx, userID, signedPlayerInfo
func (_m *MockNakamaModule) UnlinkFacebookInstantGame(ctx context.Context, userID string, signedPlayerInfo string) error {
	ret := _m.Called(ctx, userID, signedPlayerInfo)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkFacebookInstantGame")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, signedPlayerInfo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UnlinkFacebookInstantGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkFacebookInstantGame'
type MockNakamaModule_UnlinkFacebookInstantGame_Call struct {
	*mock.Call
}

// UnlinkFacebookInstantGame is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - signedPlayerInfo string
func (_e *MockNakamaModule_Expecter) UnlinkFacebookInstantGame(ctx interface{}, userID interface{}, signedPlayerInfo interface{}) *MockNakamaModule_UnlinkFacebookInstantGame_Call {
	return &MockNakamaModule_UnlinkFacebookInstantGame_Call{Call: _e.mock.On("UnlinkFacebookInstantGame", ctx, userID, signedPlayerInfo)}
}

func (_c *MockNakamaModule_UnlinkFacebookInstantGame_Call) Run(run func(ctx context.Context, userID string, signedPlayerInfo string)) *MockNakamaModule_UnlinkFacebookInstantGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_UnlinkFacebookInstantGame_Call) Return(_a0 error) *MockNakamaModule_UnlinkFacebookInstantGame_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UnlinkFacebookInstantGame_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_UnlinkFacebookInstantGame_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkGameCenter provides a mock function with given fields: ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl
func (_m *MockNakamaModule) UnlinkGameCenter(ctx context.Context, userID string, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string) error {
	ret := _m.Called(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkGameCenter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64, string, string, string) error); ok {
		r0 = rf(ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UnlinkGameCenter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkGameCenter'
type MockNakamaModule_UnlinkGameCenter_Call struct {
	*mock.Call
}

// UnlinkGameCenter is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - playerID string
//   - bundleID string
//   - timestamp int64
//   - salt string
//   - signature string
//   - publicKeyUrl string
func (_e *MockNakamaModule_Expecter) UnlinkGameCenter(ctx interface{}, userID interface{}, playerID interface{}, bundleID interface{}, timestamp interface{}, salt interface{}, signature interface{}, publicKeyUrl interface{}) *MockNakamaModule_UnlinkGameCenter_Call {
	return &MockNakamaModule_UnlinkGameCenter_Call{Call: _e.mock.On("UnlinkGameCenter", ctx, userID, playerID, bundleID, timestamp, salt, signature, publicKeyUrl)}
}

func (_c *MockNakamaModule_UnlinkGameCenter_Call) Run(run func(ctx context.Context, userID string, playerID string, bundleID string, timestamp int64, salt string, signature string, publicKeyUrl string)) *MockNakamaModule_UnlinkGameCenter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64), args[5].(string), args[6].(string), args[7].(string))
	})
	return _c
}

func (_c *MockNakamaModule_UnlinkGameCenter_Call) Return(_a0 error) *MockNakamaModule_UnlinkGameCenter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UnlinkGameCenter_Call) RunAndReturn(run func(context.Context, string, string, string, int64, string, string, string) error) *MockNakamaModule_UnlinkGameCenter_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkGoogle provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) UnlinkGoogle(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkGoogle")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UnlinkGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkGoogle'
type MockNakamaModule_UnlinkGoogle_Call struct {
	*mock.Call
}

// UnlinkGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *MockNakamaModule_Expecter) UnlinkGoogle(ctx interface{}, userID interface{}, token interface{}) *MockNakamaModule_UnlinkGoogle_Call {
	return &MockNakamaModule_UnlinkGoogle_Call{Call: _e.mock.On("UnlinkGoogle", ctx, userID, token)}
}

func (_c *MockNakamaModule_UnlinkGoogle_Call) Run(run func(ctx context.Context, userID string, token string)) *MockNakamaModule_UnlinkGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_UnlinkGoogle_Call) Return(_a0 error) *MockNakamaModule_UnlinkGoogle_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UnlinkGoogle_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_UnlinkGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// UnlinkSteam provides a mock function with given fields: ctx, userID, token
func (_m *MockNakamaModule) UnlinkSteam(ctx context.Context, userID string, token string) error {
	ret := _m.Called(ctx, userID, token)

	if len(ret) == 0 {
		panic("no return value specified for UnlinkSteam")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UnlinkSteam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlinkSteam'
type MockNakamaModule_UnlinkSteam_Call struct {
	*mock.Call
}

// UnlinkSteam is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - token string
func (_e *MockNakamaModule_Expecter) UnlinkSteam(ctx interface{}, userID interface{}, token interface{}) *MockNakamaModule_UnlinkSteam_Call {
	return &MockNakamaModule_UnlinkSteam_Call{Call: _e.mock.On("UnlinkSteam", ctx, userID, token)}
}

func (_c *MockNakamaModule_UnlinkSteam_Call) Run(run func(ctx context.Context, userID string, token string)) *MockNakamaModule_UnlinkSteam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNakamaModule_UnlinkSteam_Call) Return(_a0 error) *MockNakamaModule_UnlinkSteam_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UnlinkSteam_Call) RunAndReturn(run func(context.Context, string, string) error) *MockNakamaModule_UnlinkSteam_Call {
	_c.Call.Return(run)
	return _c
}

// UserGroupsList provides a mock function with given fields: ctx, userID, limit, state, cursor
func (_m *MockNakamaModule) UserGroupsList(ctx context.Context, userID string, limit int, state *int, cursor string) ([]*api.UserGroupList_UserGroup, string, error) {
	ret := _m.Called(ctx, userID, limit, state, cursor)

	if len(ret) == 0 {
		panic("no return value specified for UserGroupsList")
	}

	var r0 []*api.UserGroupList_UserGroup
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) ([]*api.UserGroupList_UserGroup, string, error)); ok {
		return rf(ctx, userID, limit, state, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *int, string) []*api.UserGroupList_UserGroup); ok {
		r0 = rf(ctx, userID, limit, state, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.UserGroupList_UserGroup)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *int, string) string); ok {
		r1 = rf(ctx, userID, limit, state, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, *int, string) error); ok {
		r2 = rf(ctx, userID, limit, state, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_UserGroupsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserGroupsList'
type MockNakamaModule_UserGroupsList_Call struct {
	*mock.Call
}

// UserGroupsList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - state *int
//   - cursor string
func (_e *MockNakamaModule_Expecter) UserGroupsList(ctx interface{}, userID interface{}, limit interface{}, state interface{}, cursor interface{}) *MockNakamaModule_UserGroupsList_Call {
	return &MockNakamaModule_UserGroupsList_Call{Call: _e.mock.On("UserGroupsList", ctx, userID, limit, state, cursor)}
}

func (_c *MockNakamaModule_UserGroupsList_Call) Run(run func(ctx context.Context, userID string, limit int, state *int, cursor string)) *MockNakamaModule_UserGroupsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*int), args[4].(string))
	})
	return _c
}

func (_c *MockNakamaModule_UserGroupsList_Call) Return(_a0 []*api.UserGroupList_UserGroup, _a1 string, _a2 error) *MockNakamaModule_UserGroupsList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_UserGroupsList_Call) RunAndReturn(run func(context.Context, string, int, *int, string) ([]*api.UserGroupList_UserGroup, string, error)) *MockNakamaModule_UserGroupsList_Call {
	_c.Call.Return(run)
	return _c
}

// UsersBanId provides a mock function with given fields: ctx, userIDs
func (_m *MockNakamaModule) UsersBanId(ctx context.Context, userIDs []string) error {
	ret := _m.Called(ctx, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for UsersBanId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UsersBanId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersBanId'
type MockNakamaModule_UsersBanId_Call struct {
	*mock.Call
}

// UsersBanId is a helper method to define mock.On call
//   - ctx context.Context
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) UsersBanId(ctx interface{}, userIDs interface{}) *MockNakamaModule_UsersBanId_Call {
	return &MockNakamaModule_UsersBanId_Call{Call: _e.mock.On("UsersBanId", ctx, userIDs)}
}

func (_c *MockNakamaModule_UsersBanId_Call) Run(run func(ctx context.Context, userIDs []string)) *MockNakamaModule_UsersBanId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_UsersBanId_Call) Return(_a0 error) *MockNakamaModule_UsersBanId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UsersBanId_Call) RunAndReturn(run func(context.Context, []string) error) *MockNakamaModule_UsersBanId_Call {
	_c.Call.Return(run)
	return _c
}

// UsersGetFriendStatus provides a mock function with given fields: ctx, userID, userIDs
func (_m *MockNakamaModule) UsersGetFriendStatus(ctx context.Context, userID string, userIDs []string) ([]*api.Friend, error) {
	ret := _m.Called(ctx, userID, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for UsersGetFriendStatus")
	}

	var r0 []*api.Friend
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) ([]*api.Friend, error)); ok {
		return rf(ctx, userID, userIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) []*api.Friend); ok {
		r0 = rf(ctx, userID, userIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Friend)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, userID, userIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_UsersGetFriendStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersGetFriendStatus'
type MockNakamaModule_UsersGetFriendStatus_Call struct {
	*mock.Call
}

// UsersGetFriendStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) UsersGetFriendStatus(ctx interface{}, userID interface{}, userIDs interface{}) *MockNakamaModule_UsersGetFriendStatus_Call {
	return &MockNakamaModule_UsersGetFriendStatus_Call{Call: _e.mock.On("UsersGetFriendStatus", ctx, userID, userIDs)}
}

func (_c *MockNakamaModule_UsersGetFriendStatus_Call) Run(run func(ctx context.Context, userID string, userIDs []string)) *MockNakamaModule_UsersGetFriendStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_UsersGetFriendStatus_Call) Return(_a0 []*api.Friend, _a1 error) *MockNakamaModule_UsersGetFriendStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_UsersGetFriendStatus_Call) RunAndReturn(run func(context.Context, string, []string) ([]*api.Friend, error)) *MockNakamaModule_UsersGetFriendStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UsersGetId provides a mock function with given fields: ctx, userIDs, facebookIDs
func (_m *MockNakamaModule) UsersGetId(ctx context.Context, userIDs []string, facebookIDs []string) ([]*api.User, error) {
	ret := _m.Called(ctx, userIDs, facebookIDs)

	if len(ret) == 0 {
		panic("no return value specified for UsersGetId")
	}

	var r0 []*api.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, []string) ([]*api.User, error)); ok {
		return rf(ctx, userIDs, facebookIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, []string) []*api.User); ok {
		r0 = rf(ctx, userIDs, facebookIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, []string) error); ok {
		r1 = rf(ctx, userIDs, facebookIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_UsersGetId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersGetId'
type MockNakamaModule_UsersGetId_Call struct {
	*mock.Call
}

// UsersGetId is a helper method to define mock.On call
//   - ctx context.Context
//   - userIDs []string
//   - facebookIDs []string
func (_e *MockNakamaModule_Expecter) UsersGetId(ctx interface{}, userIDs interface{}, facebookIDs interface{}) *MockNakamaModule_UsersGetId_Call {
	return &MockNakamaModule_UsersGetId_Call{Call: _e.mock.On("UsersGetId", ctx, userIDs, facebookIDs)}
}

func (_c *MockNakamaModule_UsersGetId_Call) Run(run func(ctx context.Context, userIDs []string, facebookIDs []string)) *MockNakamaModule_UsersGetId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_UsersGetId_Call) Return(_a0 []*api.User, _a1 error) *MockNakamaModule_UsersGetId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_UsersGetId_Call) RunAndReturn(run func(context.Context, []string, []string) ([]*api.User, error)) *MockNakamaModule_UsersGetId_Call {
	_c.Call.Return(run)
	return _c
}

// UsersGetRandom provides a mock function with given fields: ctx, count
func (_m *MockNakamaModule) UsersGetRandom(ctx context.Context, count int) ([]*api.User, error) {
	ret := _m.Called(ctx, count)

	if len(ret) == 0 {
		panic("no return value specified for UsersGetRandom")
	}

	var r0 []*api.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*api.User, error)); ok {
		return rf(ctx, count)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*api.User); ok {
		r0 = rf(ctx, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_UsersGetRandom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersGetRandom'
type MockNakamaModule_UsersGetRandom_Call struct {
	*mock.Call
}

// UsersGetRandom is a helper method to define mock.On call
//   - ctx context.Context
//   - count int
func (_e *MockNakamaModule_Expecter) UsersGetRandom(ctx interface{}, count interface{}) *MockNakamaModule_UsersGetRandom_Call {
	return &MockNakamaModule_UsersGetRandom_Call{Call: _e.mock.On("UsersGetRandom", ctx, count)}
}

func (_c *MockNakamaModule_UsersGetRandom_Call) Run(run func(ctx context.Context, count int)) *MockNakamaModule_UsersGetRandom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockNakamaModule_UsersGetRandom_Call) Return(_a0 []*api.User, _a1 error) *MockNakamaModule_UsersGetRandom_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_UsersGetRandom_Call) RunAndReturn(run func(context.Context, int) ([]*api.User, error)) *MockNakamaModule_UsersGetRandom_Call {
	_c.Call.Return(run)
	return _c
}

// UsersGetUsername provides a mock function with given fields: ctx, usernames
func (_m *MockNakamaModule) UsersGetUsername(ctx context.Context, usernames []string) ([]*api.User, error) {
	ret := _m.Called(ctx, usernames)

	if len(ret) == 0 {
		panic("no return value specified for UsersGetUsername")
	}

	var r0 []*api.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*api.User, error)); ok {
		return rf(ctx, usernames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*api.User); ok {
		r0 = rf(ctx, usernames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, usernames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_UsersGetUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersGetUsername'
type MockNakamaModule_UsersGetUsername_Call struct {
	*mock.Call
}

// UsersGetUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - usernames []string
func (_e *MockNakamaModule_Expecter) UsersGetUsername(ctx interface{}, usernames interface{}) *MockNakamaModule_UsersGetUsername_Call {
	return &MockNakamaModule_UsersGetUsername_Call{Call: _e.mock.On("UsersGetUsername", ctx, usernames)}
}

func (_c *MockNakamaModule_UsersGetUsername_Call) Run(run func(ctx context.Context, usernames []string)) *MockNakamaModule_UsersGetUsername_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_UsersGetUsername_Call) Return(_a0 []*api.User, _a1 error) *MockNakamaModule_UsersGetUsername_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_UsersGetUsername_Call) RunAndReturn(run func(context.Context, []string) ([]*api.User, error)) *MockNakamaModule_UsersGetUsername_Call {
	_c.Call.Return(run)
	return _c
}

// UsersUnbanId provides a mock function with given fields: ctx, userIDs
func (_m *MockNakamaModule) UsersUnbanId(ctx context.Context, userIDs []string) error {
	ret := _m.Called(ctx, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for UsersUnbanId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, userIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockNakamaModule_UsersUnbanId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersUnbanId'
type MockNakamaModule_UsersUnbanId_Call struct {
	*mock.Call
}

// UsersUnbanId is a helper method to define mock.On call
//   - ctx context.Context
//   - userIDs []string
func (_e *MockNakamaModule_Expecter) UsersUnbanId(ctx interface{}, userIDs interface{}) *MockNakamaModule_UsersUnbanId_Call {
	return &MockNakamaModule_UsersUnbanId_Call{Call: _e.mock.On("UsersUnbanId", ctx, userIDs)}
}

func (_c *MockNakamaModule_UsersUnbanId_Call) Run(run func(ctx context.Context, userIDs []string)) *MockNakamaModule_UsersUnbanId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockNakamaModule_UsersUnbanId_Call) Return(_a0 error) *MockNakamaModule_UsersUnbanId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockNakamaModule_UsersUnbanId_Call) RunAndReturn(run func(context.Context, []string) error) *MockNakamaModule_UsersUnbanId_Call {
	_c.Call.Return(run)
	return _c
}

// WalletLedgerList provides a mock function with given fields: ctx, userID, limit, cursor
func (_m *MockNakamaModule) WalletLedgerList(ctx context.Context, userID string, limit int, cursor string) ([]runtime.WalletLedgerItem, string, error) {
	ret := _m.Called(ctx, userID, limit, cursor)

	if len(ret) == 0 {
		panic("no return value specified for WalletLedgerList")
	}

	var r0 []runtime.WalletLedgerItem
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) ([]runtime.WalletLedgerItem, string, error)); ok {
		return rf(ctx, userID, limit, cursor)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) []runtime.WalletLedgerItem); ok {
		r0 = rf(ctx, userID, limit, cursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.WalletLedgerItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) string); ok {
		r1 = rf(ctx, userID, limit, cursor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, string) error); ok {
		r2 = rf(ctx, userID, limit, cursor)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_WalletLedgerList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletLedgerList'
type MockNakamaModule_WalletLedgerList_Call struct {
	*mock.Call
}

// WalletLedgerList is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - cursor string
func (_e *MockNakamaModule_Expecter) WalletLedgerList(ctx interface{}, userID interface{}, limit interface{}, cursor interface{}) *MockNakamaModule_WalletLedgerList_Call {
	return &MockNakamaModule_WalletLedgerList_Call{Call: _e.mock.On("WalletLedgerList", ctx, userID, limit, cursor)}
}

func (_c *MockNakamaModule_WalletLedgerList_Call) Run(run func(ctx context.Context, userID string, limit int, cursor string)) *MockNakamaModule_WalletLedgerList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *MockNakamaModule_WalletLedgerList_Call) Return(_a0 []runtime.WalletLedgerItem, _a1 string, _a2 error) *MockNakamaModule_WalletLedgerList_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockNakamaModule_WalletLedgerList_Call) RunAndReturn(run func(context.Context, string, int, string) ([]runtime.WalletLedgerItem, string, error)) *MockNakamaModule_WalletLedgerList_Call {
	_c.Call.Return(run)
	return _c
}

// WalletLedgerUpdate provides a mock function with given fields: ctx, itemID, metadata
func (_m *MockNakamaModule) WalletLedgerUpdate(ctx context.Context, itemID string, metadata map[string]interface{}) (runtime.WalletLedgerItem, error) {
	ret := _m.Called(ctx, itemID, metadata)

	if len(ret) == 0 {
		panic("no return value specified for WalletLedgerUpdate")
	}

	var r0 runtime.WalletLedgerItem
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) (runtime.WalletLedgerItem, error)); ok {
		return rf(ctx, itemID, metadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}) runtime.WalletLedgerItem); ok {
		r0 = rf(ctx, itemID, metadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.WalletLedgerItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]interface{}) error); ok {
		r1 = rf(ctx, itemID, metadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_WalletLedgerUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletLedgerUpdate'
type MockNakamaModule_WalletLedgerUpdate_Call struct {
	*mock.Call
}

// WalletLedgerUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - itemID string
//   - metadata map[string]interface{}
func (_e *MockNakamaModule_Expecter) WalletLedgerUpdate(ctx interface{}, itemID interface{}, metadata interface{}) *MockNakamaModule_WalletLedgerUpdate_Call {
	return &MockNakamaModule_WalletLedgerUpdate_Call{Call: _e.mock.On("WalletLedgerUpdate", ctx, itemID, metadata)}
}

func (_c *MockNakamaModule_WalletLedgerUpdate_Call) Run(run func(ctx context.Context, itemID string, metadata map[string]interface{})) *MockNakamaModule_WalletLedgerUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]interface{}))
	})
	return _c
}

func (_c *MockNakamaModule_WalletLedgerUpdate_Call) Return(_a0 runtime.WalletLedgerItem, _a1 error) *MockNakamaModule_WalletLedgerUpdate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_WalletLedgerUpdate_Call) RunAndReturn(run func(context.Context, string, map[string]interface{}) (runtime.WalletLedgerItem, error)) *MockNakamaModule_WalletLedgerUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// WalletUpdate provides a mock function with given fields: ctx, userID, changeset, metadata, updateLedger
func (_m *MockNakamaModule) WalletUpdate(ctx context.Context, userID string, changeset map[string]int64, metadata map[string]interface{}, updateLedger bool) (map[string]int64, map[string]int64, error) {
	ret := _m.Called(ctx, userID, changeset, metadata, updateLedger)

	if len(ret) == 0 {
		panic("no return value specified for WalletUpdate")
	}

	var r0 map[string]int64
	var r1 map[string]int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) (map[string]int64, map[string]int64, error)); ok {
		return rf(ctx, userID, changeset, metadata, updateLedger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) map[string]int64); ok {
		r0 = rf(ctx, userID, changeset, metadata, updateLedger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) map[string]int64); ok {
		r1 = rf(ctx, userID, changeset, metadata, updateLedger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[string]int64)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, map[string]int64, map[string]interface{}, bool) error); ok {
		r2 = rf(ctx, userID, changeset, metadata, updateLedger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockNakamaModule_WalletUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletUpdate'
type MockNakamaModule_WalletUpdate_Call struct {
	*mock.Call
}

// WalletUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - changeset map[string]int64
//   - metadata map[string]interface{}
//   - updateLedger bool
func (_e *MockNakamaModule_Expecter) WalletUpdate(ctx interface{}, userID interface{}, changeset interface{}, metadata interface{}, updateLedger interface{}) *MockNakamaModule_WalletUpdate_Call {
	return &MockNakamaModule_WalletUpdate_Call{Call: _e.mock.On("WalletUpdate", ctx, userID, changeset, metadata, updateLedger)}
}

func (_c *MockNakamaModule_WalletUpdate_Call) Run(run func(ctx context.Context, userID string, changeset map[string]int64, metadata map[string]interface{}, updateLedger bool)) *MockNakamaModule_WalletUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]int64), args[3].(map[string]interface{}), args[4].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_WalletUpdate_Call) Return(updated map[string]int64, previous map[string]int64, err error) *MockNakamaModule_WalletUpdate_Call {
	_c.Call.Return(updated, previous, err)
	return _c
}

func (_c *MockNakamaModule_WalletUpdate_Call) RunAndReturn(run func(context.Context, string, map[string]int64, map[string]interface{}, bool) (map[string]int64, map[string]int64, error)) *MockNakamaModule_WalletUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// WalletsUpdate provides a mock function with given fields: ctx, updates, updateLedger
func (_m *MockNakamaModule) WalletsUpdate(ctx context.Context, updates []*runtime.WalletUpdate, updateLedger bool) ([]*runtime.WalletUpdateResult, error) {
	ret := _m.Called(ctx, updates, updateLedger)

	if len(ret) == 0 {
		panic("no return value specified for WalletsUpdate")
	}

	var r0 []*runtime.WalletUpdateResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.WalletUpdate, bool) ([]*runtime.WalletUpdateResult, error)); ok {
		return rf(ctx, updates, updateLedger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*runtime.WalletUpdate, bool) []*runtime.WalletUpdateResult); ok {
		r0 = rf(ctx, updates, updateLedger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*runtime.WalletUpdateResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*runtime.WalletUpdate, bool) error); ok {
		r1 = rf(ctx, updates, updateLedger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockNakamaModule_WalletsUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletsUpdate'
type MockNakamaModule_WalletsUpdate_Call struct {
	*mock.Call
}

// WalletsUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - updates []*runtime.WalletUpdate
//   - updateLedger bool
func (_e *MockNakamaModule_Expecter) WalletsUpdate(ctx interface{}, updates interface{}, updateLedger interface{}) *MockNakamaModule_WalletsUpdate_Call {
	return &MockNakamaModule_WalletsUpdate_Call{Call: _e.mock.On("WalletsUpdate", ctx, updates, updateLedger)}
}

func (_c *MockNakamaModule_WalletsUpdate_Call) Run(run func(ctx context.Context, updates []*runtime.WalletUpdate, updateLedger bool)) *MockNakamaModule_WalletsUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*runtime.WalletUpdate), args[2].(bool))
	})
	return _c
}

func (_c *MockNakamaModule_WalletsUpdate_Call) Return(_a0 []*runtime.WalletUpdateResult, _a1 error) *MockNakamaModule_WalletsUpdate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockNakamaModule_WalletsUpdate_Call) RunAndReturn(run func(context.Context, []*runtime.WalletUpdate, bool) ([]*runtime.WalletUpdateResult, error)) *MockNakamaModule_WalletsUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockNakamaModule creates a new instance of MockNakamaModule. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockNakamaModule(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockNakamaModule {
	mock := &MockNakamaModule{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
