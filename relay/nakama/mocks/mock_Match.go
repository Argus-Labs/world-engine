// Code generated by mockery v2.38.0. DO NOT EDIT.

package mocks

import (
	context "context"

	runtime "github.com/heroiclabs/nakama-common/runtime"
	mock "github.com/stretchr/testify/mock"

	sql "database/sql"
)

// Match is an autogenerated mock type for the Match type
type Match struct {
	mock.Mock
}

type Match_Expecter struct {
	mock *mock.Mock
}

func (_m *Match) EXPECT() *Match_Expecter {
	return &Match_Expecter{mock: &_m.Mock}
}

// MatchInit provides a mock function with given fields: ctx, logger, db, nk, params
func (_m *Match) MatchInit(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, params map[string]interface{}) (interface{}, int, string) {
	ret := _m.Called(ctx, logger, db, nk, params)

	if len(ret) == 0 {
		panic("no return value specified for MatchInit")
	}

	var r0 interface{}
	var r1 int
	var r2 string
	if rf, ok := ret.Get(0).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, map[string]interface{}) (interface{}, int, string)); ok {
		return rf(ctx, logger, db, nk, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, map[string]interface{}) interface{}); ok {
		r0 = rf(ctx, logger, db, nk, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, map[string]interface{}) int); ok {
		r1 = rf(ctx, logger, db, nk, params)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, map[string]interface{}) string); ok {
		r2 = rf(ctx, logger, db, nk, params)
	} else {
		r2 = ret.Get(2).(string)
	}

	return r0, r1, r2
}

// Match_MatchInit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchInit'
type Match_MatchInit_Call struct {
	*mock.Call
}

// MatchInit is a helper method to define mock.On call
//   - ctx context.Context
//   - logger runtime.Logger
//   - db *sql.DB
//   - nk runtime.NakamaModule
//   - params map[string]interface{}
func (_e *Match_Expecter) MatchInit(ctx interface{}, logger interface{}, db interface{}, nk interface{}, params interface{}) *Match_MatchInit_Call {
	return &Match_MatchInit_Call{Call: _e.mock.On("MatchInit", ctx, logger, db, nk, params)}
}

func (_c *Match_MatchInit_Call) Run(run func(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, params map[string]interface{})) *Match_MatchInit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(runtime.Logger), args[2].(*sql.DB), args[3].(runtime.NakamaModule), args[4].(map[string]interface{}))
	})
	return _c
}

func (_c *Match_MatchInit_Call) Return(_a0 interface{}, _a1 int, _a2 string) *Match_MatchInit_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Match_MatchInit_Call) RunAndReturn(run func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, map[string]interface{}) (interface{}, int, string)) *Match_MatchInit_Call {
	_c.Call.Return(run)
	return _c
}

// MatchJoin provides a mock function with given fields: ctx, logger, db, nk, receipt, tick, state, presences
func (_m *Match) MatchJoin(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, presences []runtime.Presence) interface{} {
	ret := _m.Called(ctx, logger, db, nk, dispatcher, tick, state, presences)

	if len(ret) == 0 {
		panic("no return value specified for MatchJoin")
	}

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, []runtime.Presence) interface{}); ok {
		r0 = rf(ctx, logger, db, nk, dispatcher, tick, state, presences)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Match_MatchJoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchJoin'
type Match_MatchJoin_Call struct {
	*mock.Call
}

// MatchJoin is a helper method to define mock.On call
//   - ctx context.Context
//   - logger runtime.Logger
//   - db *sql.DB
//   - nk runtime.NakamaModule
//   - receipt runtime.MatchDispatcher
//   - tick int64
//   - state interface{}
//   - presences []runtime.Presence
func (_e *Match_Expecter) MatchJoin(ctx interface{}, logger interface{}, db interface{}, nk interface{}, dispatcher interface{}, tick interface{}, state interface{}, presences interface{}) *Match_MatchJoin_Call {
	return &Match_MatchJoin_Call{Call: _e.mock.On("MatchJoin", ctx, logger, db, nk, dispatcher, tick, state, presences)}
}

func (_c *Match_MatchJoin_Call) Run(run func(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, presences []runtime.Presence)) *Match_MatchJoin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(runtime.Logger), args[2].(*sql.DB), args[3].(runtime.NakamaModule), args[4].(runtime.MatchDispatcher), args[5].(int64), args[6].(interface{}), args[7].([]runtime.Presence))
	})
	return _c
}

func (_c *Match_MatchJoin_Call) Return(_a0 interface{}) *Match_MatchJoin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Match_MatchJoin_Call) RunAndReturn(run func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, []runtime.Presence) interface{}) *Match_MatchJoin_Call {
	_c.Call.Return(run)
	return _c
}

// MatchJoinAttempt provides a mock function with given fields: ctx, logger, db, nk, receipt, tick, state, presence, metadata
func (_m *Match) MatchJoinAttempt(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, presence runtime.Presence, metadata map[string]string) (interface{}, bool, string) {
	ret := _m.Called(ctx, logger, db, nk, dispatcher, tick, state, presence, metadata)

	if len(ret) == 0 {
		panic("no return value specified for MatchJoinAttempt")
	}

	var r0 interface{}
	var r1 bool
	var r2 string
	if rf, ok := ret.Get(0).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, runtime.Presence, map[string]string) (interface{}, bool, string)); ok {
		return rf(ctx, logger, db, nk, dispatcher, tick, state, presence, metadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, runtime.Presence, map[string]string) interface{}); ok {
		r0 = rf(ctx, logger, db, nk, dispatcher, tick, state, presence, metadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, runtime.Presence, map[string]string) bool); ok {
		r1 = rf(ctx, logger, db, nk, dispatcher, tick, state, presence, metadata)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, runtime.Presence, map[string]string) string); ok {
		r2 = rf(ctx, logger, db, nk, dispatcher, tick, state, presence, metadata)
	} else {
		r2 = ret.Get(2).(string)
	}

	return r0, r1, r2
}

// Match_MatchJoinAttempt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchJoinAttempt'
type Match_MatchJoinAttempt_Call struct {
	*mock.Call
}

// MatchJoinAttempt is a helper method to define mock.On call
//   - ctx context.Context
//   - logger runtime.Logger
//   - db *sql.DB
//   - nk runtime.NakamaModule
//   - receipt runtime.MatchDispatcher
//   - tick int64
//   - state interface{}
//   - presence runtime.Presence
//   - metadata map[string]string
func (_e *Match_Expecter) MatchJoinAttempt(ctx interface{}, logger interface{}, db interface{}, nk interface{}, dispatcher interface{}, tick interface{}, state interface{}, presence interface{}, metadata interface{}) *Match_MatchJoinAttempt_Call {
	return &Match_MatchJoinAttempt_Call{Call: _e.mock.On("MatchJoinAttempt", ctx, logger, db, nk, dispatcher, tick, state, presence, metadata)}
}

func (_c *Match_MatchJoinAttempt_Call) Run(run func(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, presence runtime.Presence, metadata map[string]string)) *Match_MatchJoinAttempt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(runtime.Logger), args[2].(*sql.DB), args[3].(runtime.NakamaModule), args[4].(runtime.MatchDispatcher), args[5].(int64), args[6].(interface{}), args[7].(runtime.Presence), args[8].(map[string]string))
	})
	return _c
}

func (_c *Match_MatchJoinAttempt_Call) Return(_a0 interface{}, _a1 bool, _a2 string) *Match_MatchJoinAttempt_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Match_MatchJoinAttempt_Call) RunAndReturn(run func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, runtime.Presence, map[string]string) (interface{}, bool, string)) *Match_MatchJoinAttempt_Call {
	_c.Call.Return(run)
	return _c
}

// MatchLeave provides a mock function with given fields: ctx, logger, db, nk, receipt, tick, state, presences
func (_m *Match) MatchLeave(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, presences []runtime.Presence) interface{} {
	ret := _m.Called(ctx, logger, db, nk, dispatcher, tick, state, presences)

	if len(ret) == 0 {
		panic("no return value specified for MatchLeave")
	}

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, []runtime.Presence) interface{}); ok {
		r0 = rf(ctx, logger, db, nk, dispatcher, tick, state, presences)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Match_MatchLeave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchLeave'
type Match_MatchLeave_Call struct {
	*mock.Call
}

// MatchLeave is a helper method to define mock.On call
//   - ctx context.Context
//   - logger runtime.Logger
//   - db *sql.DB
//   - nk runtime.NakamaModule
//   - receipt runtime.MatchDispatcher
//   - tick int64
//   - state interface{}
//   - presences []runtime.Presence
func (_e *Match_Expecter) MatchLeave(ctx interface{}, logger interface{}, db interface{}, nk interface{}, dispatcher interface{}, tick interface{}, state interface{}, presences interface{}) *Match_MatchLeave_Call {
	return &Match_MatchLeave_Call{Call: _e.mock.On("MatchLeave", ctx, logger, db, nk, dispatcher, tick, state, presences)}
}

func (_c *Match_MatchLeave_Call) Run(run func(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, presences []runtime.Presence)) *Match_MatchLeave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(runtime.Logger), args[2].(*sql.DB), args[3].(runtime.NakamaModule), args[4].(runtime.MatchDispatcher), args[5].(int64), args[6].(interface{}), args[7].([]runtime.Presence))
	})
	return _c
}

func (_c *Match_MatchLeave_Call) Return(_a0 interface{}) *Match_MatchLeave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Match_MatchLeave_Call) RunAndReturn(run func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, []runtime.Presence) interface{}) *Match_MatchLeave_Call {
	_c.Call.Return(run)
	return _c
}

// MatchLoop provides a mock function with given fields: ctx, logger, db, nk, receipt, tick, state, messages
func (_m *Match) MatchLoop(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, messages []runtime.MatchData) interface{} {
	ret := _m.Called(ctx, logger, db, nk, dispatcher, tick, state, messages)

	if len(ret) == 0 {
		panic("no return value specified for MatchLoop")
	}

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, []runtime.MatchData) interface{}); ok {
		r0 = rf(ctx, logger, db, nk, dispatcher, tick, state, messages)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Match_MatchLoop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchLoop'
type Match_MatchLoop_Call struct {
	*mock.Call
}

// MatchLoop is a helper method to define mock.On call
//   - ctx context.Context
//   - logger runtime.Logger
//   - db *sql.DB
//   - nk runtime.NakamaModule
//   - receipt runtime.MatchDispatcher
//   - tick int64
//   - state interface{}
//   - messages []runtime.MatchData
func (_e *Match_Expecter) MatchLoop(ctx interface{}, logger interface{}, db interface{}, nk interface{}, dispatcher interface{}, tick interface{}, state interface{}, messages interface{}) *Match_MatchLoop_Call {
	return &Match_MatchLoop_Call{Call: _e.mock.On("MatchLoop", ctx, logger, db, nk, dispatcher, tick, state, messages)}
}

func (_c *Match_MatchLoop_Call) Run(run func(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, messages []runtime.MatchData)) *Match_MatchLoop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(runtime.Logger), args[2].(*sql.DB), args[3].(runtime.NakamaModule), args[4].(runtime.MatchDispatcher), args[5].(int64), args[6].(interface{}), args[7].([]runtime.MatchData))
	})
	return _c
}

func (_c *Match_MatchLoop_Call) Return(_a0 interface{}) *Match_MatchLoop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Match_MatchLoop_Call) RunAndReturn(run func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, []runtime.MatchData) interface{}) *Match_MatchLoop_Call {
	_c.Call.Return(run)
	return _c
}

// MatchSignal provides a mock function with given fields: ctx, logger, db, nk, receipt, tick, state, data
func (_m *Match) MatchSignal(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, data string) (interface{}, string) {
	ret := _m.Called(ctx, logger, db, nk, dispatcher, tick, state, data)

	if len(ret) == 0 {
		panic("no return value specified for MatchSignal")
	}

	var r0 interface{}
	var r1 string
	if rf, ok := ret.Get(0).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, string) (interface{}, string)); ok {
		return rf(ctx, logger, db, nk, dispatcher, tick, state, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, string) interface{}); ok {
		r0 = rf(ctx, logger, db, nk, dispatcher, tick, state, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, string) string); ok {
		r1 = rf(ctx, logger, db, nk, dispatcher, tick, state, data)
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// Match_MatchSignal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchSignal'
type Match_MatchSignal_Call struct {
	*mock.Call
}

// MatchSignal is a helper method to define mock.On call
//   - ctx context.Context
//   - logger runtime.Logger
//   - db *sql.DB
//   - nk runtime.NakamaModule
//   - receipt runtime.MatchDispatcher
//   - tick int64
//   - state interface{}
//   - data string
func (_e *Match_Expecter) MatchSignal(ctx interface{}, logger interface{}, db interface{}, nk interface{}, dispatcher interface{}, tick interface{}, state interface{}, data interface{}) *Match_MatchSignal_Call {
	return &Match_MatchSignal_Call{Call: _e.mock.On("MatchSignal", ctx, logger, db, nk, dispatcher, tick, state, data)}
}

func (_c *Match_MatchSignal_Call) Run(run func(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, data string)) *Match_MatchSignal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(runtime.Logger), args[2].(*sql.DB), args[3].(runtime.NakamaModule), args[4].(runtime.MatchDispatcher), args[5].(int64), args[6].(interface{}), args[7].(string))
	})
	return _c
}

func (_c *Match_MatchSignal_Call) Return(_a0 interface{}, _a1 string) *Match_MatchSignal_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Match_MatchSignal_Call) RunAndReturn(run func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, string) (interface{}, string)) *Match_MatchSignal_Call {
	_c.Call.Return(run)
	return _c
}

// MatchTerminate provides a mock function with given fields: ctx, logger, db, nk, receipt, tick, state, graceSeconds
func (_m *Match) MatchTerminate(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, graceSeconds int) interface{} {
	ret := _m.Called(ctx, logger, db, nk, dispatcher, tick, state, graceSeconds)

	if len(ret) == 0 {
		panic("no return value specified for MatchTerminate")
	}

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, int) interface{}); ok {
		r0 = rf(ctx, logger, db, nk, dispatcher, tick, state, graceSeconds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Match_MatchTerminate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MatchTerminate'
type Match_MatchTerminate_Call struct {
	*mock.Call
}

// MatchTerminate is a helper method to define mock.On call
//   - ctx context.Context
//   - logger runtime.Logger
//   - db *sql.DB
//   - nk runtime.NakamaModule
//   - receipt runtime.MatchDispatcher
//   - tick int64
//   - state interface{}
//   - graceSeconds int
func (_e *Match_Expecter) MatchTerminate(ctx interface{}, logger interface{}, db interface{}, nk interface{}, dispatcher interface{}, tick interface{}, state interface{}, graceSeconds interface{}) *Match_MatchTerminate_Call {
	return &Match_MatchTerminate_Call{Call: _e.mock.On("MatchTerminate", ctx, logger, db, nk, dispatcher, tick, state, graceSeconds)}
}

func (_c *Match_MatchTerminate_Call) Run(run func(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, dispatcher runtime.MatchDispatcher, tick int64, state interface{}, graceSeconds int)) *Match_MatchTerminate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(runtime.Logger), args[2].(*sql.DB), args[3].(runtime.NakamaModule), args[4].(runtime.MatchDispatcher), args[5].(int64), args[6].(interface{}), args[7].(int))
	})
	return _c
}

func (_c *Match_MatchTerminate_Call) Return(_a0 interface{}) *Match_MatchTerminate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Match_MatchTerminate_Call) RunAndReturn(run func(context.Context, runtime.Logger, *sql.DB, runtime.NakamaModule, runtime.MatchDispatcher, int64, interface{}, int) interface{}) *Match_MatchTerminate_Call {
	_c.Call.Return(run)
	return _c
}

// NewMatch creates a new instance of Match. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMatch(t interface {
	mock.TestingT
	Cleanup(func())
}) *Match {
	mock := &Match{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
