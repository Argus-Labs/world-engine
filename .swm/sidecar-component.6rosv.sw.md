---
id: 6rosv
title: Sidecar Component
file_version: 1.1.2
app_version: 1.6.3
---

## Introduction

This doc gives a high level overview of the Sidecar Component. It is located under `ðŸ“„ chain/sidecar`.

## How Sidecar Works

Sidecar is a separate go routine that gets spun up from the cosmos application in `ðŸ“„ .archive.chain/app/app.go`.

<br/>

starts the sidecar service if `USE_SIDECAR` flag is set to `true` in the host's environment variables.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ .archive.chain/app/app.go
```go
226    	startSideCarIfFlagSet(app.MsgServiceRouter(), app.GRPCQueryRouter(), app.BankKeeper, app.GetBaseApp().CommitMultiStore().CacheMultiStore(), app.Logger(), app.msgPool)
```

<br/>

<br/>

At its core, Sidecar is a gRPC service that handles requests from the Argus ECS server (Nakama), and routes them to the Cosmos application.

> Tip:
> 
> To get a quick overview of what Sidecar can do, take a look at the protobuf definitions in `ðŸ“„ .archive.chain/proto/sidecar/v1/sidecar.proto`
> 
> The implementations for the protobuf service can be found in `ðŸ“„ chain/sidecar/sidecar.go`.

Sidecar can execute and route both queries and transactions. It does so with the `GRPCQueryRouter`<swm-token data-swm-token=":.archive.chain/app/app.go:226:12:12:`	startSideCarIfFlagSet(app.MsgServiceRouter(), app.GRPCQueryRouter(), app.BankKeeper, app.GetBaseApp().CommitMultiStore().CacheMultiStore(), app.Logger(), app.msgPool)`"/>, and `MsgServiceRouter`<swm-token data-swm-token=":.archive.chain/app/app.go:226:5:5:`	startSideCarIfFlagSet(app.MsgServiceRouter(), app.GRPCQueryRouter(), app.BankKeeper, app.GetBaseApp().CommitMultiStore().CacheMultiStore(), app.Logger(), app.msgPool)`"/>. In order to utilize these routers, the message must be constructed in the Sidecar gRPC server implementation. The handler for the message can be obtained by calling `Handler(msg)` on the router. This returns the function associated with the message. Once the function is called, you MUST call `Write` on the cache multi store. For example:

<br/>

<br/>

Calling s.cms.Write() before ending the function ensures all state transitions are recorded and will be committed.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ chain/sidecar/sidecar.go
```go
60     func (s Sidecar) MintCoins(ctx context.Context, msg *sidecarv1.MsgMintCoins) (*sidecarv1.MsgMintCoinsResponse, error) {
61     	sdkCtx := s.getSDKCtx().WithContext(ctx)
62     	err := s.bk.MintCoins(sdkCtx, ModuleName, types.Coins{types.NewInt64Coin(msg.Denom, msg.Amount)})
63     	if err != nil {
64     		return nil, err
65     	}
66     	s.cms.Write()
67     	return &sidecarv1.MsgMintCoinsResponse{}, nil
```

<br/>

<br/>

## Extending Sidecar

#### Adding a new RPC Endpoint

If you need to add new functionality to Sidecar, start by updating the proto file in `ðŸ“„ .archive.chain/proto/sidecar/v1/sidecar.proto`. You will need to write a new RPC endpoint and both a new message request type and message return type. NOTE: is it a protobuf best practice to define unique request and return types and to avoid reusing types across different RPC endpoints.

#### Pushing to Buf

Once you've added your new rpc and message types, push your code to [https://buf.build/](https://buf.build/). To do this, change directory into `ðŸ“„ .archive.chain/proto/sidecar` and enter `buf push`. This will trigger a code regeneration on buf. You will then need to `go get` the new assets with the associated with the commit hash for both `grpc/go` and `protocolbuffers/go`.

#### Implementing the RPC Endpoint

Now that the code has been updated with the new buf code, you should see an error in `ðŸ“„ chain/sidecar/sidecar.go` on the interface guard shown below:

<br/>

<br/>

Sidecar interface guard against the gRPC server interface.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ chain/sidecar/sidecar.go
```go
58     var _ sidecarv1grpc.SidecarServer = Sidecar{}
```

<br/>

The error message will give you the function you need to implement. Copy and paste the function and implement the desired behavior.

## Testing Sidecar

End-to-end tests for Sidecar can be found in `ðŸ“„ chain/tests/e2e/sidecar`. This test suite spins up an in memory blockchain node to run transactions and queries against. You can directly call the Sidecar client functions and then check if the desired behavior was applied by querying the node.

<br/>

This file was generated by Swimm. [Click here to view it in the app](https://app.swimm.io/repos/Z2l0aHViJTNBJTNBd29ybGQtZW5naW5lJTNBJTNBQXJndXMtTGFicw==/docs/6rosv).
