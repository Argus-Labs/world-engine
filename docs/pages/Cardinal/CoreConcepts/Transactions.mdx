# Transactions

Transactions define the types of messages that can be sent from a game client and be processed in
systems. Additionally, all registered transactions in Cardinal create a transaction endpoint, that automatically injects the transaction into the World's transaction queue. To create a Cardinal transaction type, you must first define the transaction input and output. Both of
these are just normal Go structs.

```go
type PickUpItemInput struct {
	ItemID uint64
}

type PickUpItemOutput struct {
	Success bool
}
```

Then create the Cardinal transaction type using the `NewTransactionType` function in the ecs package. Note, this
function takes a `name` argument. The name passed into the transaction gets used as the endpoint on the game server
to execute this transaction. For example, if the transaction passed in was "foo-bar", the resulting endpoint would
be `address:port/tx/foo-bar` (TODO: update this after we finalize how we want to handle endpoints)

```go
import "github.com/argus-labs/world-engine/cardinal/ecs"


var PickUpTransaction = ecs.NewTransactionType[PickUpItemInput, PickupItemOutput]("pick-up-item")
```

## Options

The `NewTransactionType` function accepts Options to alter the transaction.

### WithTxEVMSupport

import { Callout } from 'nextra/components'

import Link from 'next/link'

<Callout type={"warning"}>
   Not all Go types are supported when using `WithTxEVMSupport`. <Link href="/cardinal/CoreConcepts/evm-support">Read More</Link>
</Callout>

`WithTxEVMSupport` enables this transaction to be sent via smart contracts in the EVM.

```go
var PickUpTransaction = ecs.NewTransactionType[PickUpItemInput, PickupItemOutput]("pick-up-item", ecs.WithTxEVMSupport[PickUpItemInput, PickupItemOutput])
```