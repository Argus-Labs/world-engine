# Transactions

Transactions define the types of messages that can be sent from a game client and be processed in
systems. Additionally, all registered transactions in Cardinal create a transaction endpoint, that automatically injects the transaction into the World's transaction queue. To create a Cardinal transaction type, first define the transaction input and output. Both of these are just normal Go structs.

```go
type PickupItemInput struct {
	ItemID uint64
}

type PickupItemOutput struct {
	Success bool
}
```

Then create the Cardinal transaction type using the `NewTransactionType` function in the ecs package. Note, this
function takes a `name` argument. The name passed into the transaction gets used as the endpoint on the game server
to execute this transaction. For example, if the transaction name passed in was "foo-bar", the resulting endpoint would
be `address:port/tx/foo-bar` (TODO: update this after we finalize how we want to handle endpoints) https://linear.app/arguslabs/issue/CAR-139/refactor-http-endpoints-to-follow-a-clear-readtx-pattern

```go
import "github.com/argus-labs/world-engine/cardinal/ecs"


var PickupTransaction = ecs.NewTransactionType[PickupItemInput, PickupItemOutput]("pick-up-item")
```

## Options

The `NewTransactionType` function accepts Options to alter the transaction.

### WithTxEVMSupport

import { Callout } from 'nextra/components'

import Link from 'next/link'

<Callout type={"warning"}>
   Not all Go types are supported when using `WithTxEVMSupport`. <Link href="/Cardinal/API-Reference/evm-support">Read More</Link>
</Callout>

`WithTxEVMSupport` enables this transaction to be sent via smart contracts in the EVM.

```go
var PickupTransaction = ecs.NewTransactionType[PickupItemInput, PickupItemOutput]("pickup-item", ecs.WithTxEVMSupport[PickupItemInput, PickupItemOutput])
```