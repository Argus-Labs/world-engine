# Reads

Reads define the request and reply types to read game state data. When reads are created, Cardinal automatically sets up an endpoint in the game server to process the read.

## Creating a Read

To create a read, first define a Request struct and a Reply struct:

```go

type PlayerRequest struct {
    ID string
}

type PlayerReply struct {
    Items       []Item
    Position    Coordinates
}
```

Once the request and reply structs have been defined, instantiate the Read. Note that the `NewReadType` function takes a name argument of type string. Cardinal uses this name to automatically create the endpoint for this read. For example, passing "foo-bar" would result in the endpoint
`address:port/read/foo-bar`. (TODO: update this after we finalize how we want to handle endpoints) https://linear.app/arguslabs/issue/CAR-139/refactor-http-endpoints-to-follow-a-clear-readtx-pattern

```go
import "github.com/argus-labs/world-engine/cardinal/ecs"

var ReadPlayer = ecs.NewReadType[PlayerRequest, PlayerReply](
	"player-info",
	func(world *ecs.World, req PlayerRequest) (PlayerReply, error) {
		reply := PlayerReply{}
		// impl read...
		return reply, nil
	},
	)
```

## Options

The `NewReadType` function accepts Options to alter the read.

### WithReadEVMSupport

import { Callout } from 'nextra/components'

import Link from 'next/link'

<Callout type={"warning"}>
    Not all Go types are supported when using `WithReadEVMSupport`. <Link href="/Cardinal/API-Reference/evm-support">Read More</Link>
</Callout>

`WithReadEVMSupport` enables this read to be called from smart contracts in the EVM.


```go
import "github.com/argus-labs/world-engine/cardinal/ecs"

var ReadPlayer = ecs.NewReadType[PlayerRequest, PlayerReply](
	"player-info",
	func(world *ecs.World, req PlayerRequest) (PlayerReply, error) {
		reply := PlayerReply{}
		// impl read...
		return reply, nil
	},
    ecs.WithReadEVMSupport[PlayerRequest, PlayerReply],
	)
```