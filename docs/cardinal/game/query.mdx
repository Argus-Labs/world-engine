---
title: 'Query'
description: 'How to define and register a query'
---

Queries are predefined API endpoints that provide access to the game state data and other information that a game client might need.

In Cardinal, queries are defined as a pair of Go structs representing a `Request` and `Response` along with a handler function with the following signature:

```go
func Query(worldCtx cardinal.WorldContext, req *Request) (*Response, error)
```

**Example:**
- A `WorldVars` static query used to provide the client with game constants.
- A `PlayerLocation` query used to provide the client with the location of the player.

---

## Defining Queries

By convention, queries are defined in the `query` directory with each query definition in its own separate file.

You can easily create a new query and register it to the world by following these steps:

<Steps>
    <Step title="Define the request/response struct and the handler function">
        A query is defined using a pair of Go structs and a handler function. You can write any arbitrary logic in the handler function and access the game state using `cardinal.WorldContext`.

        ```go /query/player_health.go
        package query

        import "pkg.world.dev/world-engine/cardinal"

        type PlayerHealthRequest struct {
            Nickname string
        }

        type PlayerHealthResponse struct {
            HP int
        }

        func PlayerHealth(world cardinal.WorldContext, req *PlayerHealthRequest) (*PlayerHealthResponse, error) {
            // Handle PlayerHealthRequest -> PlayerHealthResponse here
        }
        ```
    </Step>
    <Step title="Register the query in the world">
        Queries must be registered in the world before they can be used. This is done by calling the `RegisterQuery` function and passing in the name of the endpoint and the function handler.

        ```go main.go
        package main

        import (
            "pkg.world.dev/world-engine/cardinal"
            "github.com/argus-labs/starter-game-template/cardinal/query"
        )

        func main() {
            w, err := cardinal.NewWorld()
            if err != nil {
                log.Fatal().Err(err).Msg("failed to create world")
            }

            // Register queries
            // NOTE: You must register your queries here for it to be accessible.
            err := cardinal.RegisterQuery[query.PlayerHealthRequest, query.PlayerHealthResponse](w, "world-vars", query.PlayerHealth))
            if err != nil {
                log.Fatal().Err(err).Msg("failed to register query")
            }

            // ...
        }
        ```
    </Step>
</Steps>

---

## Query Options

### Custom Query Groups

Queries can be organized into logical groups using the `WithCustomQueryGroup` option. This helps organize related queries and enables group-specific handling.

```go
import (
    "pkg.world.dev/world-engine/cardinal"
    qry "pkg.world.dev/world-engine/cardinal/query"
)

// Register query in the "player" group
err := cardinal.RegisterQuery[PlayerHealthRequest, PlayerHealthResponse](
    w,
    "player-health",
    PlayerHealth,
    qry.WithCustomQueryGroup[PlayerHealthRequest, PlayerHealthResponse]("player"),
)
```

Query groups can be used for:
- API organization
- Access control
- Rate limiting
- Metrics and monitoring

### EVM Support

Queries can be accessed by EVM smart contracts using the `WithQueryEVMSupport` option. This generates the necessary ABI types for smart contract interaction.

```go
// Register query with EVM support
err := cardinal.RegisterQuery[PlayerHealthRequest, PlayerHealthResponse](
    w,
    "player-health",
    PlayerHealth,
    qry.WithQueryEVMSupport[PlayerHealthRequest, PlayerHealthResponse](),
)
```

#### Supported Types for EVM Queries

<Note>
When using EVM support, query struct fields must use EVM-compatible types:
</Note>

```go
// Supported types
type EVMCompatibleQuery struct {
    IntValue    int64
    UintValue   uint64
    BoolValue   bool
    StringValue string
    BytesValue  []byte
    Address     common.Address
}
```

#### Smart Contract Integration

```solidity
// Solidity interface for the query
interface IPlayerHealth {
    struct PlayerHealthRequest {
        string nickname;
    }

    struct PlayerHealthResponse {
        uint256 hp;
    }

    function PlayerHealth(PlayerHealthRequest calldata request)
        external view returns (PlayerHealthResponse memory);
}
```

### Multiple Options

You can combine multiple query options:

```go
err := cardinal.RegisterQuery[PlayerHealthRequest, PlayerHealthResponse](
    w,
    "player-health",
    PlayerHealth,
    qry.WithQueryEVMSupport[PlayerHealthRequest, PlayerHealthResponse](),
    qry.WithCustomQueryGroup[PlayerHealthRequest, PlayerHealthResponse]("player"),
)
```

## Best Practices

1. **Query Organization**
   - Use meaningful group names
   - Keep related queries in the same group
   - Document group purposes

2. **EVM Integration**
   - Test EVM queries thoroughly
   - Handle type conversions carefully
   - Document ABI interfaces

3. **Performance**
   - Keep queries focused and efficient
   - Consider caching strategies
   - Monitor query latency

4. **Error Handling**
   - Return meaningful error messages
   - Validate input parameters
   - Handle edge cases

## Common Pitfalls

1. **EVM Type Mismatches**
   - Using unsupported types in EVM queries
   - Incorrect type mappings
   - Missing type conversions

2. **Query Group Management**
   - Inconsistent group naming
   - Missing group documentation
   - Unclear group purposes

3. **Performance Issues**
   - Inefficient query implementations
   - Missing indexes
   - Unnecessary data fetching

## Related Documentation
- [EVM Integration](/cardinal/game/evm)
- [Query Performance](/cardinal/game/query-performance)
- [API Best Practices](/cardinal/game/api-best-practices)
